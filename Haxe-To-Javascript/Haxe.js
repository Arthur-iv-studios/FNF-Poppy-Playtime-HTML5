// Generated by Haxe 4.2.1+bf9ff69
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var App = function() { };
$hxClasses["App"] = App;
App.__name__ = "App";
App.main = function() {
	new Editor();
};
var Completion = function() {
	this.completions = [];
	this.RANGE = 500;
	this.WORD = new EReg("[A-Z]+$","i");
};
$hxClasses["Completion"] = Completion;
Completion.__name__ = "Completion";
Completion.prototype = {
	registerHelper: function(p_functionParametersHelper) {
		var _gthis = this;
		this.functionParametersHelper = p_functionParametersHelper;
		CodeMirror.registerHelper("hint","haxe",function(cm,options) {
			_gthis.word = null;
			_gthis.range = null;
			if(options != null && options.range != null) {
				_gthis.range = options.range;
			} else if(_gthis.RANGE != null) {
				_gthis.range = _gthis.RANGE;
			}
			_gthis.getCurrentWord(cm,options,cm.getCursor());
			_gthis.list = [];
			var _g = 0;
			var _g1 = _gthis.completions;
			while(_g < _g1.length) {
				var completion = _g1[_g];
				++_g;
				var completionItem = _gthis.generateCompletionItem(completion.n,completion.t,completion.d,completion.k);
				_gthis.list.push(completionItem);
			}
			_gthis.list = Filter.filter(_gthis.list,_gthis.curWord);
			var data = { list : _gthis.list, from : { line : _gthis.cur.line, ch : _gthis.start}, to : { line : _gthis.cur.line, ch : _gthis.end}};
			CodeMirror.attachContextInfo(cm,data);
			return data;
		});
	}
	,getCurrentWord: function(cm,options,pos) {
		if(options != null && options.word != null) {
			this.word = options.word;
		} else if(this.WORD != null) {
			this.word = this.WORD;
		}
		if(pos != null) {
			this.cur = pos;
		}
		var curLine = cm.getLine(this.cur.line);
		this.start = this.cur.ch;
		this.end = this.start;
		while(this.end < curLine.length && this.word.match(curLine.charAt(this.end))) ++this.end;
		while(this.start > 0 && this.word.match(curLine.charAt(this.start - 1))) --this.start;
		this.curWord = null;
		if(this.start != this.end) {
			this.curWord = curLine.substring(this.start,this.end);
		}
		return { word : this.curWord, from : { line : this.cur.line, ch : this.start}, to : { line : this.cur.line, ch : this.end}};
	}
	,searchImage: function(name,type,description,k) {
		var functionData = this.functionParametersHelper.parseFunctionParams(name,type,description);
		var info = null;
		var className = "CodeMirror-Tern-completion";
		if(functionData.parameters != null) {
			var data = this.generateFunctionCompletionItem(name,functionData.parameters);
			className = data.className;
			info = data.info + ":" + functionData.retType;
		} else if(type != null) {
			info = type;
			switch(info) {
			case "Bool":
				className += " CodeMirror-Tern-completion-bool";
				break;
			case "String":
				className += " CodeMirror-Tern-completion-string";
				break;
			case "Float":case "Int":case "UInt":
				className += " CodeMirror-Tern-completion-number";
				break;
			default:
				if(info.indexOf("Array") != -1) {
					className += " CodeMirror-Tern-completion-array";
				} else if(info.indexOf("Map") != -1 || info.indexOf("StringMap") != -1) {
					className += " CodeMirror-Tern-completion-map";
				} else {
					className += " CodeMirror-Tern-completion-object";
				}
			}
		}
		if(k != null) {
			switch(k) {
			case "package":
				className += " CodeMirror-Tern-completion-package";
				break;
			case "type":
				className += " CodeMirror-Tern-completion-type";
				break;
			}
		}
		return { className : className, info : info};
	}
	,generateFunctionCompletionItem: function(name,params) {
		var info = null;
		var className = "CodeMirror-Tern-completion";
		info = name + "(";
		if(params != null) {
			info += params.join(", ");
		}
		info += ")";
		className += " CodeMirror-Tern-completion-fn";
		return { className : className, info : info};
	}
	,generateCompletionItem: function(name,type,description,k) {
		var completionData = this.searchImage(name,type,description,k);
		return this.createCompletionItem(name,description,completionData);
	}
	,createCompletionItem: function(name,description,completionData) {
		var completionItem = { text : name};
		completionItem.className = completionData.className;
		var infoSpan = window.document.createElement("span");
		if(completionData.info != null) {
			var infoTypeSpan = window.document.createElement("span");
			infoTypeSpan.textContent = completionData.info;
			infoSpan.appendChild(infoTypeSpan);
			infoSpan.appendChild(window.document.createElement("br"));
		}
		if(description != null) {
			var infoDescriptionSpan = window.document.createElement("span");
			infoDescriptionSpan.className = "completionDescription";
			infoDescriptionSpan.innerHTML = description;
			infoSpan.appendChild(infoDescriptionSpan);
		}
		if(completionData.info != null || description != null) {
			completionItem.info = function(completionItem) {
				return infoSpan;
			};
		}
		return completionItem;
	}
	,__class__: Completion
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,__class__: EReg
};
var api_Async_$Compiler = function(c) {
	this.__cnx = c;
};
$hxClasses["api.Async_Compiler"] = api_Async_$Compiler;
api_Async_$Compiler.__name__ = "api.Async_Compiler";
api_Async_$Compiler.prototype = {
	prepareProgram: function(program) {
		this.__cnx.resolve("prepareProgram").call([program],null);
	}
	,getProgram: function(uid,__callb) {
		this.__cnx.resolve("getProgram").call([uid],__callb);
	}
	,autocomplete: function(program,module,idx,completionType,__callb) {
		this.__cnx.resolve("autocomplete").call([program,module,idx,completionType],__callb);
	}
	,compile: function(program,uiTheme,__callb) {
		this.__cnx.resolve("compile").call([program,uiTheme],__callb);
	}
	,getHaxeVersions: function(__callb) {
		this.__cnx.resolve("getHaxeVersions").call([],__callb);
	}
	,__class__: api_Async_$Compiler
};
var CompilerProxy = function(c) {
	api_Async_$Compiler.call(this,c);
};
$hxClasses["CompilerProxy"] = CompilerProxy;
CompilerProxy.__name__ = "CompilerProxy";
CompilerProxy.__super__ = api_Async_$Compiler;
CompilerProxy.prototype = $extend(api_Async_$Compiler.prototype,{
	__class__: CompilerProxy
});
var Editor = function() {
	this.haxeEditors = [];
	var _gthis = this;
	this.markers = [];
	this.lineHandles = [];
	this.selectedJsVersion = api_ECMAScriptVersion.ES6;
	CodeMirror.commands.compile = function(_) {
		_gthis.compile();
	};
	CodeMirror.commands.togglefullscreen = $bind(this,this.toggleFullscreenSource);
	this.functionParametersHelper = new FunctionParametersHelper();
	this.completionManager = new Completion();
	this.completionManager.registerHelper(this.functionParametersHelper);
	this.theme = js_Browser.getLocalStorage().getItem("theme");
	this.addHaxeSource($("input[name=module-a]"),$("textarea[name='hx-source']")[0]);
	this.addHaxeSource($("input[name=module-b]"),$("textarea[name='hx-source2']")[0]);
	this.jsSource = CodeMirror.fromTextArea($("textarea[name='js-source']")[0],{ mode : "javascript", theme : this.getCodeTheme(), lineWrapping : true, lineNumbers : true, readOnly : true});
	this.embedSource = CodeMirror.fromTextArea($("textarea[name='embed-source']")[0],{ theme : this.getCodeTheme(), mode : "xml", htmlMode : true, lineWrapping : true, readOnly : true});
	switch(this.theme) {
	case "dark":
		this.toggleTheme();
		break;
	case "light":
		break;
	default:
		this.theme = "light";
	}
	window.document.querySelector("#theme-toggle").addEventListener("click",function(event) {
		_gthis.toggleTheme();
		event.preventDefault();
		return false;
	});
	this.runner = $("iframe[name='js-run']");
	this.runner.on("load",null,function() {
		_gthis.updateIframeThemes();
	});
	this.messages = $(".messages");
	this.formatBtn = $(".format-btn");
	this.compileBtn = $(".compile-btn");
	this.libs = $("#hx-options-form .hx-libs");
	this.targets = $("#hx-options-form .hx-targets");
	this.jsVersion = $("#hx-options-form .hx-js-es-version");
	this.stage = $(".js-output .js-canvas");
	this.outputTab = $("#output");
	this.jsTab = $("a[href='#js-source']");
	this.embedTab = $("a[href='#embed-source']");
	this.errorTab = $("a[href='#tab-errors']");
	this.errorDiv = $("#tab-errors");
	this.compilerOutTab = $("a[href='#compiler-output']");
	this.compilerTimesTab = $("a[href='#compiler-times']");
	this.compilerOut = $("#compiler-output");
	this.compilerTimes = $("#compiler-times");
	this.embedPreview = $("#embed-preview");
	this.mainName = $("#hx-options-form input[name='main']");
	this.dceName = $("#hx-options-form .hx-dce-name");
	this.analyzerName = $("#hx-options-form .hx-analyzer-name");
	this.haxeVersion = $("#hx-options-form .hx-haxe-ver");
	this.jsTab.hide();
	this.embedTab.hide();
	this.errorTab.hide();
	this.compilerOutTab.hide();
	this.compilerTimesTab.hide();
	$(".link-btn").click(function(e) {
		var _this = $(e.target);
		if(_this.attr("href") == "#") {
			e.preventDefault();
		}
	});
	$(".fullscreen-btn").click($bind(this,this.toggleFullscreenRunner));
	$("a.hx-example").click($bind(this,this.toggleExampleClick));
	$("body").keyup($bind(this,this.onKey));
	$("a[data-toggle='tab']").on("shown.bs.tab",null,function(e) {
		_gthis.jsSource.refresh();
		var _g = 0;
		var _g1 = _gthis.haxeEditors;
		while(_g < _g1.length) {
			var src = _g1[_g];
			++_g;
			src.codeMirror.refresh();
		}
		_gthis.embedSource.refresh();
	});
	this.dceName.on("change","input[name='dce']",$bind(this,this.onDce));
	this.analyzerName.on("change","input[name='analyzer']",$bind(this,this.onAnalyzer));
	this.targets.on("change","input[name='target']",$bind(this,this.onTarget));
	this.jsVersion.on("change","input[name='js-es']",$bind(this,this.onJsVersion));
	this.haxeVersion.on("change","select",$bind(this,this.onHaxeVersion));
	this.formatBtn.click($bind(this,this.formatCode));
	this.compileBtn.click($bind(this,this.compile));
	this.apiRoot = $("body").data("api");
	this.cnx = haxe_remoting_HttpAsyncConnection.urlConnect(this.apiRoot + "/compiler");
	this.cnx.setErrorHandler(function(d) {
		console.log("src/Editor.hx:200:",d);
	});
	this.cnxCompiler = new CompilerProxy(this.cnx.resolve("Compiler"));
	var _g = [];
	var _g1 = 0;
	var _g2 = this.haxeEditors;
	while(_g1 < _g2.length) {
		var src = _g2[_g1];
		++_g1;
		_g.push({ name : src.nameElement.val(), source : src.codeMirror.getValue()});
	}
	this.program = { uid : null, mainClass : "Test", modules : _g, dce : "full", analyzer : "yes", haxeVersion : "4.1.5", target : api_TargetV2.JS("test",api_ECMAScriptVersion.ES6), libs : []};
	this.cnxCompiler.getHaxeVersions(function(versions) {
		var select = _gthis.haxeVersion.find("select");
		select.empty();
		if(versions.stable.length > 0) {
			_gthis.program.haxeVersion = versions.stable[0].dir;
		} else {
			_gthis.program.haxeVersion = versions.dev[0].dir;
		}
		if(versions.stable.length > 0) {
			var stableElem = $("<optgroup>");
			stableElem.attr("label","Stable releases");
			var _g = 0;
			var _g1 = versions.stable;
			while(_g < _g1.length) {
				var version = _g1[_g];
				++_g;
				stableElem.append("<option value=\"" + version.dir + "\">" + version.version + "</option>");
			}
			select.append(stableElem);
		}
		if(versions.dev.length > 0) {
			var devElem = $("<optgroup>");
			devElem.attr("label","Development releases");
			var _g = 0;
			var _g1 = versions.dev;
			while(_g < _g1.length) {
				var version = _g1[_g];
				++_g;
				devElem.append("<option value=\"" + version.dir + "\">" + version.version + "</option>");
			}
			select.append(devElem);
		}
	});
	this.initLibs();
	this.setTarget(api_TargetV2.JS("test",this.selectedJsVersion));
	var uid = window.location.hash;
	if(uid.length > 0) {
		uid = HxOverrides.substr(uid,1,null);
		this.cnxCompiler.getProgram(uid,$bind(this,this.onProgram));
	}
	window.addEventListener("resize",$bind(this,this.resize));
	this.resize();
};
$hxClasses["Editor"] = Editor;
Editor.__name__ = "Editor";
Editor.prototype = {
	isDarkTheme: function() {
		return window.document.querySelector("html").classList.contains("dark-theme");
	}
	,getCodeTheme: function() {
		if(this.isDarkTheme()) {
			return "material-darker";
		} else {
			return "default";
		}
	}
	,toggleTheme: function() {
		var htmlTag = window.document.querySelector("html");
		var isDark = this.isDarkTheme();
		if(isDark) {
			htmlTag.classList.remove("dark-theme");
		} else {
			htmlTag.classList.add("dark-theme");
		}
		isDark = this.isDarkTheme();
		this.theme = isDark ? "dark" : "light";
		js_Browser.getLocalStorage().setItem("theme",this.theme);
		var text = isDark ? "Lighter" : "Darker";
		window.document.querySelector("#theme-toggle .theme-label").innerText = text;
		var _g = 0;
		var _g1 = this.haxeEditors;
		while(_g < _g1.length) {
			var editor = _g1[_g];
			++_g;
			editor.codeMirror.setOption("theme",this.getCodeTheme());
		}
		this.jsSource.setOption("theme",this.getCodeTheme());
		this.embedSource.setOption("theme",this.getCodeTheme());
		this.updateIframeThemes();
	}
	,updateIframeThemes: function() {
		this.updateIframeTheme(".js-run");
		this.updateIframeTheme(".embed-preview iframe");
	}
	,updateIframeTheme: function(selector) {
		var isDark = this.isDarkTheme();
		var iframe = window.document.querySelector(selector);
		if(iframe == null || iframe.contentDocument == null) {
			return;
		}
		var iframeBody = iframe.contentDocument.querySelector("body");
		if(iframeBody == null) {
			return;
		}
		if(isDark) {
			iframeBody.classList.add("dark-theme");
		} else {
			iframeBody.classList.remove("dark-theme");
		}
		if(iframe.getAttribute("src") != "about:blank") {
			return;
		}
		var color = isDark ? "#111" : "#fff";
		iframeBody.style.backgroundColor = color;
	}
	,addHaxeSource: function(name,elem) {
		var _gthis = this;
		var lint = new HaxeLint();
		var haxeSource = CodeMirror.fromTextArea(elem,{ mode : "haxe", theme : this.getCodeTheme(), lineWrapping : true, lineNumbers : true, lint : { getAnnotations : $bind(lint,lint.getLintData), async : true}, matchBrackets : true, autoCloseBrackets : true, gutters : ["CodeMirror-linenumbers","CodeMirror-foldgutter","CodeMirror-lint-markers"], indentUnit : 2, tabSize : 2, keyMap : "sublime"});
		var colorPreview = new js_codemirror_ColorPreview(haxeSource);
		var editorData = { nameElement : name, codeMirror : haxeSource, colorPreview : colorPreview, completionManager : this.completionManager, functionParametersHelper : this.functionParametersHelper, lint : lint};
		this.haxeEditors.push(editorData);
		haxeSource.setOption("extraKeys",{ "Ctrl-Space" : function(cm) {
			_gthis.autocomplete(editorData);
		}, "Ctrl-Enter" : "compile", "F8" : "compile", "F5" : "compile", "F11" : "togglefullscreen"});
		CodeMirror.commands.save = function(instance) {
			_gthis.formatCode();
			_gthis.compile();
		};
		haxeSource.on("cursorActivity",function() {
			colorPreview.update(_gthis.completionManager,haxeSource);
			_gthis.functionParametersHelper.update(_gthis,editorData);
		});
		haxeSource.on("scroll",function() {
			colorPreview.scroll(haxeSource);
		});
		var _g = $bind(this,this.onChange);
		var editorData1 = editorData;
		var tmp = function(cm,e) {
			_g(cm,e,editorData1);
		};
		haxeSource.on("change",tmp);
	}
	,resize: function(_) {
		this.setHeight(10);
		var body = $(window.document.body);
		var main = $(".main");
		var h = window.innerHeight - 160;
		h -= $(".foot").height();
		h = Math.max(h,525);
		this.setHeight(h | 0);
	}
	,setHeight: function(h) {
		var _g = 0;
		var _g1 = this.haxeEditors;
		while(_g < _g1.length) {
			var src = _g1[_g];
			++_g;
			src.codeMirror.getScrollerElement().style.height = h + "px";
			src.codeMirror.getWrapperElement().style.height = h + "px";
			src.codeMirror.refresh();
		}
		this.runner.height(h - 12);
	}
	,onDce: function(e) {
		var cb = $(e.target);
		var name = cb.val();
		switch(name) {
		case "full":case "no":case "std":
			this.setDCE(name);
			break;
		default:
		}
	}
	,setDCE: function(dce) {
		this.program.dce = dce;
		var radio = $("input[name='dce'][value='" + dce + "']");
		radio.attr("checked","checked");
	}
	,onAnalyzer: function(e) {
		var cb = $(e.target);
		var name = cb.val();
		switch(name) {
		case "no":case "yes":
			this.setAnalyzer(name);
			break;
		default:
		}
	}
	,setAnalyzer: function(analyzer) {
		this.program.analyzer = analyzer;
		var radio = $("input[name='analyzer'][value='" + analyzer + "']");
		radio.attr("checked","checked");
	}
	,toggleExampleClick: function(e) {
		var _gthis = this;
		var _this = $(e.target);
		var ajax = $.ajax;
		ajax({ url : "examples/Example-" + Std.string(_this.data("value")) + ".hx", dataType : "text"}).done(function(data) {
			_gthis.haxeEditors[0].nameElement.val("Test");
			_gthis.haxeEditors[0].codeMirror.setValue(data);
			$("input[name='main']").val("Test");
			var requiredLibs = _this.data("libs");
			if(requiredLibs == null || requiredLibs == "") {
				return;
			}
			var e = _gthis.program.target;
			var sel = $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name;
			var _g = 0;
			var _g1 = requiredLibs.split(",");
			while(_g < _g1.length) {
				var lib = _g1[_g];
				++_g;
				$("#hx-options .hx-libs ." + sel + "-libs input[value=\"" + lib + "\"]").prop("checked",true);
			}
		});
		e.preventDefault();
	}
	,fullscreen: function() {
		var el = window.document.documentElement;
            var rfs = el.requestFullScreen
                || el.webkitRequestFullScreen
                || el.mozRequestFullScreen;
			rfs.call(el); ;
	}
	,toggleFullscreenRunner: function(e) {
		var _this = $(e.target);
		e.preventDefault();
		if(_this.attr("href") != "#") {
			$("body").addClass("fullscreen-runner");
			this.fullscreen();
		}
	}
	,toggleFullscreenSource: function(_) {
		$("body").toggleClass("fullscreen-source");
		var _g = 0;
		var _g1 = this.haxeEditors;
		while(_g < _g1.length) {
			var src = _g1[_g];
			++_g;
			src.codeMirror.refresh();
		}
		this.fullscreen();
	}
	,onTarget: function(e) {
		var cb = $(e.target);
		var name = cb.val();
		var target;
		switch(name) {
		case "EVAL":
			target = api_TargetV2.EVAL("test");
			break;
		case "HL":
			target = api_TargetV2.HL("test");
			break;
		case "NEKO":
			target = api_TargetV2.NEKO("test");
			break;
		default:
			target = api_TargetV2.JS("test",this.selectedJsVersion);
		}
		this.setTarget(target);
	}
	,onJsVersion: function(e) {
		var cb = $(e.target);
		var name = cb.val();
		this.selectedJsVersion = name == "ES5" ? api_ECMAScriptVersion.ES5 : api_ECMAScriptVersion.ES6;
		this.setTarget(api_TargetV2.JS("test",this.selectedJsVersion));
	}
	,setTarget: function(target) {
		this.program.target = target;
		this.libs.find(".controls").hide();
		var sel = $hxEnums[target.__enum__].__constructs__[target._hx_index]._hx_name;
		switch(target._hx_index) {
		case 0:
			var _g = target.name;
			var _g = target.version;
			this.jsVersion.fadeIn();
			break;
		case 1:
			var _g = target.name;
			this.jsVersion.hide();
			this.jsTab.hide();
			break;
		case 2:
			var _g = target.name;
			this.jsVersion.hide();
			this.jsTab.hide();
			break;
		case 3:
			var _g = target.name;
			this.jsVersion.hide();
			this.jsTab.hide();
			break;
		}
		var radio = $("input[name='target'][value='" + sel + "']");
		radio.attr("checked","checked");
		this.libs.find("." + sel + "-libs").fadeIn();
		var _g = 0;
		var _g1 = this.program.libs;
		while(_g < _g1.length) {
			var lib = _g1[_g];
			++_g;
			$("#hx-options .hx-libs ." + sel + "-libs input[value=\"" + lib + "\"]").prop("checked",true);
		}
	}
	,onHaxeVersion: function(e) {
		var opt = $(e.target);
		this.program.haxeVersion = opt.val();
	}
	,initLibs: function() {
		var _g = 0;
		var _this = api_Target.__constructs__;
		var result = new Array(_this.length);
		var _g1 = 0;
		var _g2 = _this.length;
		while(_g1 < _g2) {
			var i = _g1++;
			result[i] = _this[i]._hx_name;
		}
		var _g1 = result;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			var el = this.libs.find("." + t + "-libs");
			var libs = Libs.getLibsConfig(null,t);
			var def = Libs.getDefaultLibs(null,t);
			if(def == null) {
				def = [];
			}
			var _g2 = 0;
			while(_g2 < libs.length) {
				var l = libs[_g2];
				++_g2;
				el.append("<div class=\"checkbox\"><label><input class=\"lib\" type=\"checkbox\" value=\"" + l.name + "\"" + (Lambda.has(def,l.name) ? "checked='checked'" : "") + (" /> " + l.name + " ") + "<a href='" + (l.help == null ? "http://lib.haxe.org/p/" + l.name : l.help) + "' target='_blank'><i class='fa fa-question-circle'></i></a>" + "</label></div>");
			}
		}
	}
	,onProgram: function(p) {
		if(p != null) {
			this.program = p;
			this.program.uid = null;
			var _g = 0;
			var _g1 = this.haxeEditors.length;
			while(_g < _g1) {
				var i = _g++;
				this.haxeEditors[i].nameElement.val(this.program.modules[i].name);
				this.haxeEditors[i].codeMirror.setValue(this.program.modules[i].source);
			}
			this.setTarget(this.program.target);
			this.setDCE(this.program.dce);
			this.setAnalyzer(this.program.analyzer);
			var versionElem = this.haxeVersion.find("select option[value=\"" + this.program.haxeVersion + "\"]");
			if(versionElem.length == 0) {
				versionElem = this.haxeVersion.find("select option").first();
				this.program.haxeVersion = versionElem.val();
			}
			versionElem.prop("selected",true);
			if(this.program.libs != null) {
				var _g2_i = 0;
				var _g2_j = this.libs.find("input.lib");
				while(_g2_i < _g2_j.length) {
					var lib = _g2_j[_g2_i++];
					if(Lambda.has(this.program.libs,$(lib).val())) {
						lib.setAttribute("checked","checked");
					} else {
						lib.removeAttribute("checked");
					}
				}
			}
			this.mainName.val(this.program.mainClass);
		}
	}
	,saveCompletion: function(editorData,comps,onComplete) {
		this.completionManager.completions = [];
		if(comps.list != null) {
			this.completionManager.completions = comps.list;
		}
		onComplete(editorData.codeMirror,comps);
	}
	,getCompletion: function(editorData,onComplete,pos,targetCompletionType) {
		var _gthis = this;
		this.updateProgram();
		var cm = editorData.codeMirror;
		var src = cm.getValue();
		var completionType = 0;
		var cursorPos = pos;
		if(cursorPos == null) {
			cursorPos = cm.getCursor();
		}
		var idx = SourceTools.getAutocompleteIndex(src,cursorPos);
		if(idx == null) {
			idx = SourceTools.posToIndex(src,cm.getCursor());
			completionType = 1;
		}
		this.completionIndex = idx;
		var module = Lambda.find(this.program.modules,function(m) {
			return m.name == editorData.nameElement.val();
		});
		if(targetCompletionType == null) {
			this.cnxCompiler.autocomplete(this.program,module,idx,completionType,function(comps) {
				_gthis.saveCompletion(editorData,comps,onComplete);
			});
		} else if(targetCompletionType == completionType) {
			this.cnxCompiler.autocomplete(this.program,module,idx,completionType,function(comps) {
				_gthis.saveCompletion(editorData,comps,onComplete);
			});
		}
	}
	,autocomplete: function(editorData) {
		this.clearErrors(editorData);
		this.messages.fadeOut(0);
		this.getCompletion(editorData,$bind(this,this.displayCompletions));
	}
	,displayCompletions: function(cm,comps) {
		cm.execCommand("autocomplete");
		if(comps.errors != null) {
			this.messages.html("<div class='alert alert-error'><h4 class='alert-heading'>Completion error</h4><div class='message'></div></div>");
			var _g = 0;
			var _g1 = comps.errors;
			while(_g < _g1.length) {
				var m = _g1[_g];
				++_g;
				this.messages.find(".message").append($("<div>").text(m));
			}
			this.messages.fadeIn();
			this.markErrors(comps.errors);
		}
	}
	,onKey: function(e) {
		if(e.keyCode == 122) {
			var b = $("body");
			if(b.hasClass("fullscreen-runner")) {
				b.removeClass("fullscreen-runner");
			}
		}
		if(e.ctrlKey && e.keyCode == 13 || e.keyCode == 119) {
			e.preventDefault();
			this.compile(e);
		}
	}
	,onChange: function(cm,e,editorData) {
		var txt = e.text[0];
		if(StringTools.endsWith(StringTools.trim(txt),".") || StringTools.endsWith(StringTools.trim(txt),"()")) {
			this.autocomplete(editorData);
		}
	}
	,formatCode: function(e) {
		if(e != null) {
			e.preventDefault();
		}
		var _g = 0;
		var _g1 = this.haxeEditors.length;
		while(_g < _g1) {
			var i = _g++;
			var cursorPos = this.haxeEditors[i].codeMirror.getCursor();
			this.haxeEditors[i].codeMirror.setValue(this.runFormatter(this.haxeEditors[i].codeMirror.getValue()));
			this.haxeEditors[i].codeMirror.setCursor(cursorPos);
		}
	}
	,runFormatter: function(code) {
		try {
			var _g = formatter_Formatter.format(formatter_FormatterInput.Code(code),new formatter_config_Config(),null,tokentree_TokenTreeEntryPoint.TypeLevel);
			switch(_g._hx_index) {
			case 0:
				var formattedCode = _g.formattedCode;
				return formattedCode;
			case 1:
				var _g1 = _g.errorMessage;
				break;
			case 2:
				break;
			}
		} catch( _g ) {
		}
		return code;
	}
	,compile: function(e) {
		if(e != null) {
			e.preventDefault();
		}
		this.messages.fadeOut(0);
		var _g = 0;
		var _g1 = this.haxeEditors;
		while(_g < _g1.length) {
			var data = _g1[_g];
			++_g;
			this.clearErrors(data);
		}
		this.compileBtn.button("loading");
		this.updateProgram();
		this.cnxCompiler.compile(this.program,this.theme,$bind(this,this.onCompile));
	}
	,updateProgram: function() {
		var _g = 0;
		var _g1 = this.haxeEditors.length;
		while(_g < _g1) {
			var i = _g++;
			this.program.modules[i].name = this.haxeEditors[i].nameElement.val();
			this.program.modules[i].source = this.haxeEditors[i].codeMirror.getValue();
		}
		this.program.mainClass = this.mainName.val();
		this.program.dce = $("input[name='dce']:checked").val();
		this.program.analyzer = $("input[name='analyzer']:checked").val();
		var libs = [];
		var e = this.program.target;
		var sel = $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name;
		var inputs = $("#hx-options .hx-libs ." + sel + "-libs input.lib:checked");
		var _g2_i = 0;
		var _g2_j = inputs;
		while(_g2_i < _g2_j.length) {
			var i = _g2_j[_g2_i++];
			libs.push($(i).val());
		}
		this.program.libs = libs;
	}
	,run: function() {
		if(this.output.success) {
			var run = this.output.href;
			run = StringTools.replace(run,"/try-haxe/","/");
			this.runner.attr("src",this.apiRoot + run + "?r=" + Std.string(Math.random()));
			var standalone = $(".link-btn, .fullscreen-btn");
			standalone.removeClass("disabled");
			var url = this.apiRoot + run + "?r=" + Std.string(Math.random());
			if(this.isDarkTheme()) {
				url += "&theme=dark";
			}
			standalone.attr("href",url);
		} else {
			this.runner.attr("src","about:blank");
			$(".link-btn, .fullscreen-btn").addClass("disabled").attr("href","#");
		}
	}
	,onCompile: function(o) {
		this.output = o;
		this.program.uid = this.output.uid;
		window.location.hash = "#" + this.output.uid;
		window.document.title = "Try Haxe #" + this.output.uid;
		this.jsSource.setValue(this.output.source);
		this.embedSource.setValue(this.output.embed);
		this.embedPreview.html(this.output.embed);
		if(this.output.embed != "" && this.output.embed != null) {
			this.embedTab.show();
		} else {
			this.embedTab.hide();
		}
		var jsSourceElem = $(this.jsSource.getWrapperElement());
		var msgType = "";
		if(this.output.success) {
			msgType = "success";
			jsSourceElem.show();
			this.jsSource.refresh();
			this.stage.show();
			this.outputTab.show();
			this.outputTab.tab("show");
			this.errorTab.hide();
			this.errorDiv.html("<pre></pre>");
			var _g = this.program.target;
			if(_g._hx_index == 0) {
				var _g1 = _g.name;
				var _g1 = _g.version;
				this.jsTab.show();
			} else {
				this.jsTab.hide();
			}
		} else {
			msgType = "error";
			this.jsTab.hide();
			jsSourceElem.hide();
			this.markErrors(this.output.errors);
			this.outputTab.hide();
			this.errorTab.tab("show");
			this.errorTab.show();
			this.errorDiv.html("<pre>" + StringTools.htmlEscape(this.output.stderr,true) + "</pre>");
		}
		this.messages.html("<div class='alert alert-" + msgType + "'><h4 class='alert-heading'>" + StringTools.htmlEscape(this.output.message,true) + "</h4></div>");
		if(this.output.haxeout != null && StringTools.trim(this.output.haxeout).length > 0) {
			this.compilerOutTab.show();
			this.compilerOut.html("<pre>" + StringTools.htmlEscape(this.output.haxeout,true) + "</pre>");
		} else {
			this.compilerOutTab.hide();
			this.compilerOut.html("<pre></pre>");
		}
		if(this.output.times != null && StringTools.trim(this.output.times).length > 0) {
			this.compilerTimesTab.show();
			this.compilerTimes.html("<pre>" + StringTools.htmlEscape(this.output.times,true) + "</pre>");
		} else {
			this.compilerTimesTab.hide();
			this.compilerTimes.html("<pre></pre>");
		}
		this.messages.fadeIn();
		this.compileBtn.button("reset");
		this.run();
	}
	,clearErrors: function(editorData) {
		editorData.lint.data = [];
		editorData.lint.updateLinting(editorData.codeMirror);
	}
	,markErrors: function(errors) {
		var errLine = new EReg("([^:]*):([0-9]+): characters ([0-9]+)-([0-9]+) :(.*)","g");
		var errorMap_h = Object.create(null);
		var _g = 0;
		while(_g < errors.length) {
			var e = errors[_g];
			++_g;
			if(errLine.match(e)) {
				var err_file = errLine.matched(1);
				var err_line = Std.parseInt(errLine.matched(2)) - 1;
				var err_from = Std.parseInt(errLine.matched(3));
				var err_to = Std.parseInt(errLine.matched(4));
				var err_msg = errLine.matched(5);
				var file = StringTools.trim(err_file);
				file = file.substring(0,file.lastIndexOf("."));
				var data;
				if(Object.prototype.hasOwnProperty.call(errorMap_h,file)) {
					data = errorMap_h[file];
				} else {
					var a = [];
					errorMap_h[file] = a;
					data = a;
				}
				data.push({ from : { line : err_line, ch : err_from}, to : { line : err_line, ch : err_to}, message : err_msg, severity : "error"});
			}
		}
		var h = errorMap_h;
		var key_h = h;
		var key_keys = Object.keys(h);
		var key_length = key_keys.length;
		var key_current = 0;
		while(key_current < key_length) {
			var key = [key_keys[key_current++]];
			var editorData = Lambda.find(this.haxeEditors,(function(key) {
				return function(data) {
					return data.nameElement.val() == key[0];
				};
			})(key));
			if(editorData != null) {
				editorData.lint.data = errorMap_h[key[0]];
				editorData.lint.updateLinting(editorData.codeMirror);
			}
		}
	}
	,__class__: Editor
};
var Filter = function() { };
$hxClasses["Filter"] = Filter;
Filter.__name__ = "Filter";
Filter.filter = function(completions,word) {
	var list = [];
	if(word != null) {
		var filtered_results = [];
		var sorted_results = [];
		word = word.toLowerCase();
		var _g = 0;
		while(_g < completions.length) {
			var completion = completions[_g];
			++_g;
			var n = completion.text.toLowerCase();
			var b = true;
			var _g1 = 0;
			var _g2 = word.length;
			while(_g1 < _g2) {
				var j = _g1++;
				if(n.indexOf(word.charAt(j)) == -1) {
					b = false;
					break;
				}
			}
			if(b) {
				filtered_results.push(completion);
			}
		}
		var results = [];
		var filtered_results2 = [];
		var exactResults = [];
		var _g = 0;
		var _g1 = filtered_results.length;
		while(_g < _g1) {
			var i = _g++;
			var str = filtered_results[i].text.toLowerCase();
			var index = str.indexOf(word);
			if(word == str) {
				exactResults.push(filtered_results[i]);
			} else if(index == 0) {
				sorted_results.push(filtered_results[i]);
			} else if(index != -1) {
				filtered_results2.push(filtered_results[i]);
			} else {
				results.push(filtered_results[i]);
			}
		}
		var _g = 0;
		while(_g < exactResults.length) {
			var completion = exactResults[_g];
			++_g;
			list.push(completion);
		}
		var _g = 0;
		while(_g < sorted_results.length) {
			var completion = sorted_results[_g];
			++_g;
			list.push(completion);
		}
		var _g = 0;
		while(_g < filtered_results2.length) {
			var completion = filtered_results2[_g];
			++_g;
			list.push(completion);
		}
		var _g = 0;
		while(_g < results.length) {
			var completion = results[_g];
			++_g;
			list.push(completion);
		}
	} else {
		list = completions;
	}
	return list;
};
var FunctionParametersHelper = function() {
	this.widgets = [];
};
$hxClasses["FunctionParametersHelper"] = FunctionParametersHelper;
FunctionParametersHelper.__name__ = "FunctionParametersHelper";
FunctionParametersHelper.prototype = {
	addWidget: function(cm,type,name,parameters,retType,description,currentParameter,pos) {
		var lineWidget = new LineWidget(cm,type,name,parameters,retType,description,currentParameter,pos);
		this.widgets.push(lineWidget);
	}
	,alreadyShown: function() {
		return this.widgets.length > 0;
	}
	,updateScroll: function(cm) {
		var info = cm.getScrollInfo();
		var after = cm.charCoords({ line : cm.getCursor().line + 1, ch : 0},"local").top;
		if(info.top + info.clientHeight < after) {
			cm.scrollTo(null,after - info.clientHeight + 3);
		}
	}
	,clear: function(cm) {
		var _g = 0;
		var _g1 = this.widgets;
		while(_g < _g1.length) {
			var widget = _g1[_g];
			++_g;
			cm.removeLineWidget(widget.getWidget());
		}
		this.widgets = [];
	}
	,update: function(editorInstance,editorData) {
		var cm = editorData.codeMirror;
		var doc = cm.getDoc();
		if(doc != null) {
			var modeName = doc.getMode().name;
			if(modeName == "haxe" && !cm.state.completionActive) {
				var cursor = cm.getCursor();
				var data = cm.getLine(cursor.line);
				if(cursor != null && data.charAt(cursor.ch - 1) != ".") {
					this.scanForBracket(editorInstance,editorData,cursor);
				}
			}
		}
	}
	,scanForBracket: function(editorInstance,editorData,cursor) {
		var cm = editorData.codeMirror;
		var bracketsData = cm.scanForBracket(cursor,-1,null,{ bracketRegex : /[([\]]/});
		var pos = null;
		if(bracketsData != null && bracketsData.ch == "(") {
			pos = { line : bracketsData.pos.line, ch : bracketsData.pos.ch};
			var matchedBracket = cm.findMatchingBracket(pos,false,null).to;
			if(matchedBracket == null || cursor.line <= matchedBracket.line && cursor.ch <= matchedBracket.ch) {
				var range = cm.getRange(bracketsData.pos,cursor);
				var currentParameter = range.split(",").length - 1;
				if(this.lastPos == null || this.lastPos.ch != pos.ch || this.lastPos.line != pos.line) {
					this.getFunctionParams(editorInstance,editorData,pos,currentParameter);
				} else if(this.alreadyShown()) {
					var _g = 0;
					var _g1 = this.widgets;
					while(_g < _g1.length) {
						var widget = _g1[_g];
						++_g;
						widget.updateParameters(currentParameter);
					}
				}
				this.lastPos = pos;
			} else {
				this.lastPos = null;
				this.clear(cm);
			}
		} else {
			this.lastPos = null;
			this.clear(cm);
		}
	}
	,getFunctionParams: function(editorInstance,editorData,pos,currentParameter) {
		var _gthis = this;
		var cm = editorData.codeMirror;
		var completionInstance = editorData.completionManager;
		var posBeforeBracket = { line : pos.line, ch : pos.ch - 1};
		var word = completionInstance.getCurrentWord(cm,{ },posBeforeBracket).word;
		editorInstance.getCompletion(editorData,function(cm,comps) {
			var found = false;
			_gthis.clear(cm);
			var _g = 0;
			var _g1 = completionInstance.completions;
			while(_g < _g1.length) {
				var completion = _g1[_g];
				++_g;
				if(word == completion.n) {
					var functionData = _gthis.parseFunctionParams(completion.n,completion.t,completion.d);
					if(functionData.parameters != null) {
						var description = _gthis.parseDescription(completion.d);
						_gthis.addWidget(cm,"function",completion.n,functionData.parameters,functionData.retType,description,currentParameter,cm.getCursor());
						found = true;
					}
				}
			}
			_gthis.updateScroll(cm);
		},posBeforeBracket,0);
	}
	,parseDescription: function(description) {
		if(description != null) {
			if(description.indexOf(".") != -1) {
				description = description.split(".")[0];
			}
		}
		return description;
	}
	,parseFunctionParams: function(name,type,description) {
		var parameters = null;
		var retType = null;
		if(type != null && type.indexOf("->") != -1) {
			var openBracketsCount = 0;
			var positions = [];
			var i = 0;
			var lastPos = 0;
			while(i < type.length) {
				switch(type.charAt(i)) {
				case "(":
					++openBracketsCount;
					break;
				case ")":
					--openBracketsCount;
					break;
				case "-":
					if(openBracketsCount == 0 && type.charAt(i + 1) == ">") {
						positions.push({ start : lastPos, end : i - 1});
						++i;
						++i;
						lastPos = i;
					}
					break;
				default:
				}
				++i;
			}
			positions.push({ start : lastPos, end : type.length});
			parameters = [];
			var _g = 0;
			var _g1 = positions.length;
			while(_g < _g1) {
				var j = _g++;
				var param = StringTools.trim(type.substring(positions[j].start,positions[j].end));
				if(j < positions.length - 1) {
					parameters.push(param);
				} else {
					retType = param;
				}
			}
			if(parameters.length == 1 && parameters[0] == "Void") {
				parameters = [];
			}
		}
		return { parameters : parameters, retType : retType};
	}
	,__class__: FunctionParametersHelper
};
var HaxeLint = function() {
	this.data = [];
};
$hxClasses["HaxeLint"] = HaxeLint;
HaxeLint.__name__ = "HaxeLint";
HaxeLint.prototype = {
	getLintData: function(cm,update,options) {
		update(this.data);
	}
	,updateLinting: function(cm) {
		cm.performLint();
	}
	,__class__: HaxeLint
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var json2object_reader_BaseParser = function(errors,putils,errorType) {
	this.errors = errors;
	this.putils = putils;
	this.errorType = errorType;
};
$hxClasses["json2object.reader.BaseParser"] = json2object_reader_BaseParser;
json2object_reader_BaseParser.__name__ = "json2object.reader.BaseParser";
json2object_reader_BaseParser.prototype = {
	fromJson: function(jsonString,filename) {
		if(filename == null) {
			filename = "";
		}
		this.putils = new json2object_PositionUtils(jsonString);
		this.errors = [];
		try {
			var json = new hxjsonast_Parser(jsonString,filename).parseRec();
			this.loadJson(json);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxjsonast_Error)) {
				var e = _g1;
				this.errors.push(json2object_Error.ParserError(e.message,this.putils.convertPosition(e.pos)));
			} else {
				throw _g;
			}
		}
		return this.value;
	}
	,loadJson: function(json,variable) {
		if(variable == null) {
			variable = "";
		}
		var pos = this.putils.convertPosition(json.pos);
		var _g = json.value;
		switch(_g._hx_index) {
		case 0:
			var s = _g.s;
			this.loadJsonString(s,pos,variable);
			break;
		case 1:
			var n = _g.s;
			this.loadJsonNumber(n,pos,variable);
			break;
		case 2:
			var o = _g.fields;
			this.loadJsonObject(o,pos,variable);
			break;
		case 3:
			var a = _g.values;
			this.loadJsonArray(a,pos,variable);
			break;
		case 4:
			var b = _g.b;
			this.loadJsonBool(b,pos,variable);
			break;
		case 5:
			this.loadJsonNull(pos,variable);
			break;
		}
		return this.value;
	}
	,loadJsonNull: function(pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonString: function(s,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadString: function(s,pos,variable,validValues,defaultValue) {
		if(validValues.indexOf(s) != -1) {
			return s;
		}
		this.onIncorrectType(pos,variable);
		return defaultValue;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonUInt: function(f,pos,variable,value) {
		var uint = 0;
		f = StringTools.trim(f);
		var neg = f.charAt(0) == "-";
		if(neg) {
			f = HxOverrides.substr(f,1,null);
		}
		var hex = StringTools.startsWith(f,"0x");
		if(hex) {
			f = HxOverrides.substr(f,2,null);
		}
		var base = hex ? 16 : 10;
		var pow = 1;
		var i = f.length - 1;
		while(i >= 0) {
			var cur = hex ? Std.parseInt("0x" + f.charAt(i)) : Std.parseInt(f.charAt(i));
			if(cur == null) {
				this.onIncorrectType(pos,variable);
				return value;
			}
			uint = uint + pow * cur;
			pow *= base;
			--i;
		}
		return uint;
	}
	,loadJsonInt: function(f,pos,variable,value) {
		if(Std.parseInt(f) != null && Std.parseInt(f) == parseFloat(f)) {
			return Std.parseInt(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	,loadJsonFloat: function(f,pos,variable,value) {
		if(Std.parseInt(f) != null) {
			return parseFloat(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArray: function(a,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArrayValue: function(a,loadJsonFn,variable) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < a.length) {
			var j = a[_g1];
			++_g1;
			var tmp;
			try {
				tmp = loadJsonFn(j,variable);
			} catch( _g2 ) {
				haxe_NativeStackTrace.lastError = _g2;
				var _g3 = haxe_Exception.caught(_g2).unwrap();
				if(js_Boot.__instanceof(_g3,json2object_InternalError)) {
					var e = _g3;
					if(e != json2object_InternalError.ParsingThrow) {
						throw haxe_Exception.thrown(e);
					}
					continue;
				} else {
					throw _g2;
				}
			}
			_g.push(tmp);
		}
		return _g;
	}
	,loadJsonObject: function(o,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadObjectField: function(loadJsonFn,field,name,assigned,defaultValue,pos) {
		try {
			var ret = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
			return ret;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,json2object_InternalError)) {
				var e = _g1;
				if(e != json2object_InternalError.ParsingThrow) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				var e = _g1;
				this.errors.push(json2object_Error.CustomFunctionException(e,pos));
			}
		}
		return defaultValue;
	}
	,loadObjectFieldReflect: function(loadJsonFn,field,name,assigned,pos) {
		try {
			this.value[name] = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,json2object_InternalError)) {
				var e = _g1;
				if(e != json2object_InternalError.ParsingThrow) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				var e = _g1;
				this.errors.push(json2object_Error.CustomFunctionException(e,pos));
			}
		}
	}
	,objectSetupAssign: function(assigned,keys,values) {
		var _g = 0;
		var _g1 = keys.length;
		while(_g < _g1) {
			var i = _g++;
			this.mapSet(assigned,keys[i],values[i]);
		}
	}
	,objectErrors: function(assigned,pos) {
		var lastPos = this.putils.convertPosition(new hxjsonast_Position(pos.file,pos.max - 1,pos.max - 1));
		var h = assigned.h;
		var s_h = h;
		var s_keys = Object.keys(h);
		var s_length = s_keys.length;
		var s_current = 0;
		while(s_current < s_length) {
			var s = s_keys[s_current++];
			if(!assigned.h[s]) {
				this.errors.push(json2object_Error.UninitializedVariable(s,lastPos));
			}
		}
	}
	,onIncorrectType: function(pos,variable) {
		this.parsingThrow();
	}
	,parsingThrow: function() {
		if(this.errorType != 0) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
	}
	,objectThrow: function(pos,variable) {
		if(this.errorType == 2) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
		if(this.errorType == 1) {
			this.errors.push(json2object_Error.UninitializedVariable(variable,pos));
		}
	}
	,mapSet: function(map,key,value) {
		map.h[key] = value;
	}
	,__class__: json2object_reader_BaseParser
};
var JsonParser_$1 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_1"] = JsonParser_$1;
JsonParser_$1.__name__ = "JsonParser_1";
JsonParser_$1.__super__ = json2object_reader_BaseParser;
JsonParser_$1.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?wrapping : Null<formatter.config.WrapConfig>, ?whitespace : Null<formatter.config.WhitespaceConfig>, ?sameLine : Null<formatter.config.SameLineConfig>, ?lineEnds : Null<formatter.config.LineEndConfig>, ?indentation : Null<formatter.config.IndentationConfig>, ?excludes : Null<Array<String>>, ?emptyLines : Null<formatter.config.EmptyLinesConfig>, ?disableFormatting : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["disableFormatting","emptyLines","excludes","indentation","lineEnds","sameLine","whitespace","wrapping"],[true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "disableFormatting":
				this.value.disableFormatting = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"disableFormatting",assigned,this.value.disableFormatting,pos);
				break;
			case "emptyLines":
				this.value.emptyLines = this.loadObjectField(($_=new JsonParser_$4(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyLines",assigned,this.value.emptyLines,pos);
				break;
			case "excludes":
				this.value.excludes = this.loadObjectField(($_=new JsonParser_$66(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"excludes",assigned,this.value.excludes,pos);
				break;
			case "indentation":
				this.value.indentation = this.loadObjectField(($_=new JsonParser_$33(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentation",assigned,this.value.indentation,pos);
				break;
			case "lineEnds":
				this.value.lineEnds = this.loadObjectField(($_=new JsonParser_$36(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEnds",assigned,this.value.lineEnds,pos);
				break;
			case "sameLine":
				this.value.sameLine = this.loadObjectField(($_=new JsonParser_$39(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sameLine",assigned,this.value.sameLine,pos);
				break;
			case "whitespace":
				this.value.whitespace = this.loadObjectField(($_=new JsonParser_$42(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whitespace",assigned,this.value.whitespace,pos);
				break;
			case "wrapping":
				this.value.wrapping = this.loadObjectField(($_=new JsonParser_$60(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"wrapping",assigned,this.value.wrapping,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { disableFormatting : false, emptyLines : new JsonParser_$4([],this.putils,0).getAuto(), excludes : ["\\.haxelib","\\.git","node_modules"], indentation : new JsonParser_$33([],this.putils,0).getAuto(), lineEnds : new JsonParser_$36([],this.putils,0).getAuto(), sameLine : new JsonParser_$39([],this.putils,0).getAuto(), whitespace : new JsonParser_$42([],this.putils,0).getAuto(), wrapping : new JsonParser_$60([],this.putils,0).getAuto()};
	}
	,__class__: JsonParser_$1
});
var JsonParser_$112 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_112"] = JsonParser_$112;
JsonParser_$112.__name__ = "JsonParser_112";
JsonParser_$112.__super__ = json2object_reader_BaseParser;
JsonParser_$112.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "beforeLast";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingLocation",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["beforeLast","afterLast"],"beforeLast");
	}
	,getAuto: function() {
		return new JsonParser_$112([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$112
});
var JsonParser_$114 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_114"] = JsonParser_$114;
JsonParser_$114.__name__ = "JsonParser_114";
JsonParser_$114.__super__ = json2object_reader_BaseParser;
JsonParser_$114.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,getAuto: function() {
		return new JsonParser_$114([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$114
});
var JsonParser_$116 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_116"] = JsonParser_$116;
JsonParser_$116.__name__ = "JsonParser_116";
JsonParser_$116.__super__ = json2object_reader_BaseParser;
JsonParser_$116.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapRule>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$118(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$116([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$116
});
var JsonParser_$118 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_118"] = JsonParser_$118;
JsonParser_$118.__name__ = "JsonParser_118";
JsonParser_$118.__super__ = json2object_reader_BaseParser;
JsonParser_$118.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ type : formatter.config.WrappingType, ?location : Null<formatter.config.WrappingLocation>, conditions : Array<formatter.config.WrapCondition>, ?additionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["additionalIndent","conditions","location","type"],[true,false,true,false]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "additionalIndent":
				this.value.additionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"additionalIndent",assigned,this.value.additionalIndent,pos);
				break;
			case "conditions":
				this.value.conditions = this.loadObjectField(($_=new JsonParser_$119(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditions",assigned,this.value.conditions,pos);
				break;
			case "location":
				this.value.location = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"location",assigned,this.value.location,pos);
				break;
			case "type":
				this.value.type = this.loadObjectField(($_=new JsonParser_$120(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"type",assigned,this.value.type,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { additionalIndent : 0, conditions : new JsonParser_$119([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), location : "afterLast", type : new JsonParser_$120([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)))};
	}
	,__class__: JsonParser_$118
});
var JsonParser_$119 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_119"] = JsonParser_$119;
JsonParser_$119.__name__ = "JsonParser_119";
JsonParser_$119.__super__ = json2object_reader_BaseParser;
JsonParser_$119.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapCondition>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$122(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$119([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$119
});
var JsonParser_$12 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_12"] = JsonParser_$12;
JsonParser_$12.__name__ = "JsonParser_12";
JsonParser_$12.__super__ = json2object_reader_BaseParser;
JsonParser_$12.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?beforeError : Null<Int>, ?beforeEnd : Null<Int>, ?beforeElse : Null<Int>, ?afterIf : Null<Int>, ?afterError : Null<Int>, ?afterElse : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterElse","afterError","afterIf","beforeElse","beforeEnd","beforeError"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterElse":
				this.value.afterElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterElse",assigned,this.value.afterElse,pos);
				break;
			case "afterError":
				this.value.afterError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterError",assigned,this.value.afterError,pos);
				break;
			case "afterIf":
				this.value.afterIf = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterIf",assigned,this.value.afterIf,pos);
				break;
			case "beforeElse":
				this.value.beforeElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeElse",assigned,this.value.beforeElse,pos);
				break;
			case "beforeEnd":
				this.value.beforeEnd = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeEnd",assigned,this.value.beforeEnd,pos);
				break;
			case "beforeError":
				this.value.beforeError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeError",assigned,this.value.beforeError,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterElse : 0, afterError : 0, afterIf : 0, beforeElse : 0, beforeEnd : 0, beforeError : 0};
	}
	,__class__: JsonParser_$12
});
var JsonParser_$120 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_120"] = JsonParser_$120;
JsonParser_$120.__name__ = "JsonParser_120";
JsonParser_$120.__super__ = json2object_reader_BaseParser;
JsonParser_$120.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,getAuto: function() {
		return new JsonParser_$120([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$120
});
var JsonParser_$122 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_122"] = JsonParser_$122;
JsonParser_$122.__name__ = "JsonParser_122";
JsonParser_$122.__super__ = json2object_reader_BaseParser;
JsonParser_$122.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?value : Null<Int>, cond : formatter.config.WrapConditionType }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["cond","value"],[false,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "cond":
				this.value.cond = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"cond",assigned,this.value.cond,pos);
				break;
			case "value":
				this.value.value = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"value",assigned,this.value.value,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { cond : new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), value : 1};
	}
	,__class__: JsonParser_$122
});
var JsonParser_$123 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_123"] = JsonParser_$123;
JsonParser_$123.__name__ = "JsonParser_123";
JsonParser_$123.__super__ = json2object_reader_BaseParser;
JsonParser_$123.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "itemCount >= n";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrapConditionType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["itemCount >= n","itemCount <= n","anyItemLength >= n","anyItemLength <= n","totalItemLength >= n","totalItemLength <= n","lineLength >= n","lineLength <= n","hasMultilineItems","exceedsMaxLineLength"],"itemCount >= n");
	}
	,getAuto: function() {
		return new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$123
});
var JsonParser_$125 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_125"] = JsonParser_$125;
JsonParser_$125.__name__ = "JsonParser_125";
JsonParser_$125.__super__ = json2object_reader_BaseParser;
JsonParser_$125.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WhitespacePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","noneBefore","onlyBefore","after","onlyAfter","noneAfter","around"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$125([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$125
});
var JsonParser_$15 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_15"] = JsonParser_$15;
JsonParser_$15.__name__ = "JsonParser_15";
JsonParser_$15.__super__ = json2object_reader_BaseParser;
JsonParser_$15.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 1, beginType : 0, betweenFunctions : 1, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$15
});
var JsonParser_$165 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_165"] = JsonParser_$165;
JsonParser_$165.__name__ = "JsonParser_165";
JsonParser_$165.__super__ = json2object_reader_BaseParser;
JsonParser_$165.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "same";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SameLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["same","next","keep"],"same");
	}
	,getAuto: function() {
		return new JsonParser_$165([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$165
});
var JsonParser_$168 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_168"] = JsonParser_$168;
JsonParser_$168.__name__ = "JsonParser_168";
JsonParser_$168.__super__ = json2object_reader_BaseParser;
JsonParser_$168.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["emptyCurly","leftCurly","rightCurly"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { emptyCurly : "noBreak", leftCurly : "after", rightCurly : "both"};
	}
	,__class__: JsonParser_$168
});
var JsonParser_$174 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_174"] = JsonParser_$174;
JsonParser_$174.__name__ = "JsonParser_174";
JsonParser_$174.__super__ = json2object_reader_BaseParser;
JsonParser_$174.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CaseColonLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$174([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$174
});
var JsonParser_$176 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_176"] = JsonParser_$176;
JsonParser_$176.__name__ = "JsonParser_176";
JsonParser_$176.__super__ = json2object_reader_BaseParser;
JsonParser_$176.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noBreak";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.EmptyCurlyPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noBreak","break"],"noBreak");
	}
	,getAuto: function() {
		return new JsonParser_$176([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$176
});
var JsonParser_$178 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_178"] = JsonParser_$178;
JsonParser_$178.__name__ = "JsonParser_178";
JsonParser_$178.__super__ = json2object_reader_BaseParser;
JsonParser_$178.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LeftCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","before","both"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$178([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$178
});
var JsonParser_$18 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_18"] = JsonParser_$18;
JsonParser_$18.__name__ = "JsonParser_18";
JsonParser_$18.__super__ = json2object_reader_BaseParser;
JsonParser_$18.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenFields : Null<Int>, ?beginType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beginType","betweenFields","endType","existingBetweenFields"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFields":
				this.value.betweenFields = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFields",assigned,this.value.betweenFields,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beginType : 0, betweenFields : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$18
});
var JsonParser_$180 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_180"] = JsonParser_$180;
JsonParser_$180.__name__ = "JsonParser_180";
JsonParser_$180.__super__ = json2object_reader_BaseParser;
JsonParser_$180.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "auto";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineEndCharacter",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["auto","CR","LF","CRLF"],"auto");
	}
	,getAuto: function() {
		return new JsonParser_$180([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$180
});
var JsonParser_$182 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_182"] = JsonParser_$182;
JsonParser_$182.__name__ = "JsonParser_182";
JsonParser_$182.__super__ = json2object_reader_BaseParser;
JsonParser_$182.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.AtLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","afterLast","forceAfterLast"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$182([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$182
});
var JsonParser_$186 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_186"] = JsonParser_$186;
JsonParser_$186.__name__ = "JsonParser_186";
JsonParser_$186.__super__ = json2object_reader_BaseParser;
JsonParser_$186.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.RightCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","after","both"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$186([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$186
});
var JsonParser_$188 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_188"] = JsonParser_$188;
JsonParser_$188.__name__ = "JsonParser_188";
JsonParser_$188.__super__ = json2object_reader_BaseParser;
JsonParser_$188.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SharpLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$188([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$188
});
var JsonParser_$192 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_192"] = JsonParser_$192;
JsonParser_$192.__name__ = "JsonParser_192";
JsonParser_$192.__super__ = json2object_reader_BaseParser;
JsonParser_$192.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,getAuto: function() {
		return new JsonParser_$192([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$192
});
var JsonParser_$194 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_194"] = JsonParser_$194;
JsonParser_$194.__name__ = "JsonParser_194";
JsonParser_$194.__super__ = json2object_reader_BaseParser;
JsonParser_$194.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "fixedZero";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ConditionalIndentationPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["fixedZero","fixedZeroIncrease","fixedZeroIncreaseBlocks","aligned","alignedNestedIncrease","alignedIncrease","alignedDecrease"],"fixedZero");
	}
	,getAuto: function() {
		return new JsonParser_$194([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$194
});
var JsonParser_$196 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_196"] = JsonParser_$196;
JsonParser_$196.__name__ = "JsonParser_196";
JsonParser_$196.__super__ = json2object_reader_BaseParser;
JsonParser_$196.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "all";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.BetweenImportsEmptyLinesLevel",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["all","firstLevelPackage","secondLevelPackage","thirdLevelPackage","fourthLevelPackage","fifthLevelPackage","fullPackage"],"all");
	}
	,getAuto: function() {
		return new JsonParser_$196([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$196
});
var JsonParser_$198 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_198"] = JsonParser_$198;
JsonParser_$198.__name__ = "JsonParser_198";
JsonParser_$198.__super__ = json2object_reader_BaseParser;
JsonParser_$198.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.KeepEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","remove"],"keep");
	}
	,getAuto: function() {
		return new JsonParser_$198([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$198
});
var JsonParser_$202 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_202"] = JsonParser_$202;
JsonParser_$202.__name__ = "JsonParser_202";
JsonParser_$202.__super__ = json2object_reader_BaseParser;
JsonParser_$202.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "ignore";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CommentEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["ignore","none","one"],"ignore");
	}
	,getAuto: function() {
		return new JsonParser_$202([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$202
});
var JsonParser_$21 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_21"] = JsonParser_$21;
JsonParser_$21.__name__ = "JsonParser_21";
JsonParser_$21.__super__ = json2object_reader_BaseParser;
JsonParser_$21.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 0, beginType : 0, betweenFunctions : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$21
});
var JsonParser_$218 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_218"] = JsonParser_$218;
JsonParser_$218.__name__ = "JsonParser_218";
JsonParser_$218.__super__ = json2object_reader_BaseParser;
JsonParser_$218.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineCommentEmptyLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","one","none"],"keep");
	}
	,getAuto: function() {
		return new JsonParser_$218([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$218
});
var JsonParser_$24 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_24"] = JsonParser_$24;
JsonParser_$24.__name__ = "JsonParser_24";
JsonParser_$24.__super__ = json2object_reader_BaseParser;
JsonParser_$24.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?betweenImportsLevel : Null<formatter.config.BetweenImportsEmptyLinesLevel>, ?betweenImports : Null<Int>, ?beforeUsing : Null<Int>, ?beforeType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beforeType","beforeUsing","betweenImports","betweenImportsLevel"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beforeType":
				this.value.beforeType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeType",assigned,this.value.beforeType,pos);
				break;
			case "beforeUsing":
				this.value.beforeUsing = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeUsing",assigned,this.value.beforeUsing,pos);
				break;
			case "betweenImports":
				this.value.betweenImports = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImports",assigned,this.value.betweenImports,pos);
				break;
			case "betweenImportsLevel":
				this.value.betweenImportsLevel = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImportsLevel",assigned,this.value.betweenImportsLevel,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beforeType : 1, beforeUsing : 1, betweenImports : 0, betweenImportsLevel : "all"};
	}
	,__class__: JsonParser_$24
});
var JsonParser_$33 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_33"] = JsonParser_$33;
JsonParser_$33.__name__ = "JsonParser_33";
JsonParser_$33.__super__ = json2object_reader_BaseParser;
JsonParser_$33.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?trailingWhitespace : Null<Bool>, ?tabWidth : Null<Int>, ?indentObjectLiteral : Null<Bool>, ?indentComplexValueExpressions : Null<Bool>, ?indentCaseLabels : Null<Bool>, ?conditionalPolicy : Null<formatter.config.ConditionalIndentationPolicy>, ?character : Null<String> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["character","conditionalPolicy","indentCaseLabels","indentComplexValueExpressions","indentObjectLiteral","tabWidth","trailingWhitespace"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "character":
				this.value.character = this.loadObjectField(($_=new JsonParser_$192(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"character",assigned,this.value.character,pos);
				break;
			case "conditionalPolicy":
				this.value.conditionalPolicy = this.loadObjectField(($_=new JsonParser_$194(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalPolicy",assigned,this.value.conditionalPolicy,pos);
				break;
			case "indentCaseLabels":
				this.value.indentCaseLabels = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentCaseLabels",assigned,this.value.indentCaseLabels,pos);
				break;
			case "indentComplexValueExpressions":
				this.value.indentComplexValueExpressions = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentComplexValueExpressions",assigned,this.value.indentComplexValueExpressions,pos);
				break;
			case "indentObjectLiteral":
				this.value.indentObjectLiteral = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentObjectLiteral",assigned,this.value.indentObjectLiteral,pos);
				break;
			case "tabWidth":
				this.value.tabWidth = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tabWidth",assigned,this.value.tabWidth,pos);
				break;
			case "trailingWhitespace":
				this.value.trailingWhitespace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"trailingWhitespace",assigned,this.value.trailingWhitespace,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { character : "tab", conditionalPolicy : "aligned", indentCaseLabels : true, indentComplexValueExpressions : false, indentObjectLiteral : true, tabWidth : 4, trailingWhitespace : false};
	}
	,__class__: JsonParser_$33
});
var JsonParser_$36 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_36"] = JsonParser_$36;
JsonParser_$36.__name__ = "JsonParser_36";
JsonParser_$36.__super__ = json2object_reader_BaseParser;
JsonParser_$36.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefCurly : Null<formatter.config.CurlyLineEndPolicy>, ?sharp : Null<formatter.config.SharpLineEndPolicy>, ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?objectLiteralCurly : Null<formatter.config.CurlyLineEndPolicy>, ?metadataVar : Null<formatter.config.AtLineEndPolicy>, ?metadataType : Null<formatter.config.AtLineEndPolicy>, ?metadataOther : Null<formatter.config.AtLineEndPolicy>, ?metadataFunction : Null<formatter.config.AtLineEndPolicy>, ?lineEndCharacter : Null<formatter.config.LineEndCharacter>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy>, ?caseColon : Null<formatter.config.CaseColonLineEndPolicy>, ?blockCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonTypeCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonFunctionCurly : Null<formatter.config.CurlyLineEndPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionCurly","anonTypeCurly","blockCurly","caseColon","emptyCurly","leftCurly","lineEndCharacter","metadataFunction","metadataOther","metadataType","metadataVar","objectLiteralCurly","rightCurly","sharp","typedefCurly"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionCurly":
				this.value.anonFunctionCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionCurly",assigned,this.value.anonFunctionCurly,pos);
				break;
			case "anonTypeCurly":
				this.value.anonTypeCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeCurly",assigned,this.value.anonTypeCurly,pos);
				break;
			case "blockCurly":
				this.value.blockCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockCurly",assigned,this.value.blockCurly,pos);
				break;
			case "caseColon":
				this.value.caseColon = this.loadObjectField(($_=new JsonParser_$174(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColon",assigned,this.value.caseColon,pos);
				break;
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "lineEndCharacter":
				this.value.lineEndCharacter = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEndCharacter",assigned,this.value.lineEndCharacter,pos);
				break;
			case "metadataFunction":
				this.value.metadataFunction = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataFunction",assigned,this.value.metadataFunction,pos);
				break;
			case "metadataOther":
				this.value.metadataOther = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataOther",assigned,this.value.metadataOther,pos);
				break;
			case "metadataType":
				this.value.metadataType = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataType",assigned,this.value.metadataType,pos);
				break;
			case "metadataVar":
				this.value.metadataVar = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataVar",assigned,this.value.metadataVar,pos);
				break;
			case "objectLiteralCurly":
				this.value.objectLiteralCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralCurly",assigned,this.value.objectLiteralCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			case "sharp":
				this.value.sharp = this.loadObjectField(($_=new JsonParser_$188(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharp",assigned,this.value.sharp,pos);
				break;
			case "typedefCurly":
				this.value.typedefCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefCurly",assigned,this.value.typedefCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionCurly : null, anonTypeCurly : null, blockCurly : null, caseColon : "after", emptyCurly : "noBreak", leftCurly : "after", lineEndCharacter : "auto", metadataFunction : "none", metadataOther : "none", metadataType : "none", metadataVar : "none", objectLiteralCurly : null, rightCurly : "both", sharp : "after", typedefCurly : null};
	}
	,__class__: JsonParser_$36
});
var JsonParser_$39 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_39"] = JsonParser_$39;
JsonParser_$39.__name__ = "JsonParser_39";
JsonParser_$39.__super__ = json2object_reader_BaseParser;
JsonParser_$39.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileBody : Null<formatter.config.SameLinePolicy>, ?untypedBody : Null<formatter.config.SameLinePolicy>, ?tryCatch : Null<formatter.config.SameLinePolicy>, ?tryBody : Null<formatter.config.SameLinePolicy>, ?returnBodySingleLine : Null<formatter.config.SameLinePolicy>, ?returnBody : Null<formatter.config.SameLinePolicy>, ?ifElse : Null<formatter.config.SameLinePolicy>, ?ifBody : Null<formatter.config.SameLinePolicy>, ?functionBody : Null<formatter.config.SameLinePolicy>, ?forBody : Null<formatter.config.SameLinePolicy>, ?expressionTry : Null<formatter.config.SameLinePolicy>, ?expressionIfWithBlocks : Null<Bool>, ?expressionIf : Null<formatter.config.SameLinePolicy>, ?expressionCase : Null<formatter.config.SameLinePolicy>, ?elseIf : Null<formatter.config.SameLinePolicy>, ?elseBody : Null<formatter.config.SameLinePolicy>, ?doWhileBody : Null<formatter.config.SameLinePolicy>, ?doWhile : Null<formatter.config.SameLinePolicy>, ?comprehensionFor : Null<formatter.config.SameLinePolicy>, ?catchBody : Null<formatter.config.SameLinePolicy>, ?caseBody : Null<formatter.config.SameLinePolicy>, ?anonFunctionBody : Null<formatter.config.SameLinePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionBody","caseBody","catchBody","comprehensionFor","doWhile","doWhileBody","elseBody","elseIf","expressionCase","expressionIf","expressionIfWithBlocks","expressionTry","forBody","functionBody","ifBody","ifElse","returnBody","returnBodySingleLine","tryBody","tryCatch","untypedBody","whileBody"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionBody":
				this.value.anonFunctionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionBody",assigned,this.value.anonFunctionBody,pos);
				break;
			case "caseBody":
				this.value.caseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseBody",assigned,this.value.caseBody,pos);
				break;
			case "catchBody":
				this.value.catchBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchBody",assigned,this.value.catchBody,pos);
				break;
			case "comprehensionFor":
				this.value.comprehensionFor = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"comprehensionFor",assigned,this.value.comprehensionFor,pos);
				break;
			case "doWhile":
				this.value.doWhile = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhile",assigned,this.value.doWhile,pos);
				break;
			case "doWhileBody":
				this.value.doWhileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhileBody",assigned,this.value.doWhileBody,pos);
				break;
			case "elseBody":
				this.value.elseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseBody",assigned,this.value.elseBody,pos);
				break;
			case "elseIf":
				this.value.elseIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseIf",assigned,this.value.elseIf,pos);
				break;
			case "expressionCase":
				this.value.expressionCase = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionCase",assigned,this.value.expressionCase,pos);
				break;
			case "expressionIf":
				this.value.expressionIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIf",assigned,this.value.expressionIf,pos);
				break;
			case "expressionIfWithBlocks":
				this.value.expressionIfWithBlocks = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIfWithBlocks",assigned,this.value.expressionIfWithBlocks,pos);
				break;
			case "expressionTry":
				this.value.expressionTry = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionTry",assigned,this.value.expressionTry,pos);
				break;
			case "forBody":
				this.value.forBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forBody",assigned,this.value.forBody,pos);
				break;
			case "functionBody":
				this.value.functionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionBody",assigned,this.value.functionBody,pos);
				break;
			case "ifBody":
				this.value.ifBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifBody",assigned,this.value.ifBody,pos);
				break;
			case "ifElse":
				this.value.ifElse = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifElse",assigned,this.value.ifElse,pos);
				break;
			case "returnBody":
				this.value.returnBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBody",assigned,this.value.returnBody,pos);
				break;
			case "returnBodySingleLine":
				this.value.returnBodySingleLine = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBodySingleLine",assigned,this.value.returnBodySingleLine,pos);
				break;
			case "tryBody":
				this.value.tryBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryBody",assigned,this.value.tryBody,pos);
				break;
			case "tryCatch":
				this.value.tryCatch = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryCatch",assigned,this.value.tryCatch,pos);
				break;
			case "untypedBody":
				this.value.untypedBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"untypedBody",assigned,this.value.untypedBody,pos);
				break;
			case "whileBody":
				this.value.whileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileBody",assigned,this.value.whileBody,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionBody : "same", caseBody : "next", catchBody : "next", comprehensionFor : "same", doWhile : "same", doWhileBody : "next", elseBody : "next", elseIf : "same", expressionCase : "keep", expressionIf : "same", expressionIfWithBlocks : false, expressionTry : "same", forBody : "next", functionBody : "next", ifBody : "next", ifElse : "same", returnBody : "same", returnBodySingleLine : "same", tryBody : "next", tryCatch : "same", untypedBody : "same", whileBody : "next"};
	}
	,__class__: JsonParser_$39
});
var JsonParser_$4 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_4"] = JsonParser_$4;
JsonParser_$4.__name__ = "JsonParser_4";
JsonParser_$4.__super__ = json2object_reader_BaseParser;
JsonParser_$4.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?maxAnywhereInFile : Null<Int>, ?macroClassEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?lineCommentsBetweenTypes : Null<formatter.config.LineCommentEmptyLinePolicy>, ?lineCommentsBetweenFunctions : Null<formatter.config.LineCommentEmptyLinePolicy>, ?interfaceEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?importAndUsing : Null<formatter.config.ImportsEmptyLinesConfig>, ?finalNewline : Null<Bool>, ?externClassEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?enumEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?enumAbstractEmptyLines : Null<formatter.config.EnumAbstractFieldsEmptyLinesConfig>, ?conditionalsEmptyLines : Null<formatter.config.ConditionalEmptyLinesConfig>, ?classEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?betweenTypes : Null<Int>, ?betweenSingleLineTypes : Null<Int>, ?betweenMultilineComments : Null<Int>, ?beforeRightCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?beforePackage : Null<Int>, ?beforeDocCommentEmptyLines : Null<formatter.config.CommentEmptyLinesPolicy>, ?beforeBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterReturn : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterPackage : Null<Int>, ?afterLeftCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterFileHeaderComment : Null<Int>, ?afterFieldsWithDocComments : Null<formatter.config.CommentEmptyLinesPolicy>, ?afterBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?abstractEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["abstractEmptyLines","afterBlocks","afterFieldsWithDocComments","afterFileHeaderComment","afterLeftCurly","afterPackage","afterReturn","beforeBlocks","beforeDocCommentEmptyLines","beforePackage","beforeRightCurly","betweenMultilineComments","betweenSingleLineTypes","betweenTypes","classEmptyLines","conditionalsEmptyLines","enumAbstractEmptyLines","enumEmptyLines","externClassEmptyLines","finalNewline","importAndUsing","interfaceEmptyLines","lineCommentsBetweenFunctions","lineCommentsBetweenTypes","macroClassEmptyLines","maxAnywhereInFile","typedefEmptyLines"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "abstractEmptyLines":
				this.value.abstractEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"abstractEmptyLines",assigned,this.value.abstractEmptyLines,pos);
				break;
			case "afterBlocks":
				this.value.afterBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterBlocks",assigned,this.value.afterBlocks,pos);
				break;
			case "afterFieldsWithDocComments":
				this.value.afterFieldsWithDocComments = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFieldsWithDocComments",assigned,this.value.afterFieldsWithDocComments,pos);
				break;
			case "afterFileHeaderComment":
				this.value.afterFileHeaderComment = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFileHeaderComment",assigned,this.value.afterFileHeaderComment,pos);
				break;
			case "afterLeftCurly":
				this.value.afterLeftCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterLeftCurly",assigned,this.value.afterLeftCurly,pos);
				break;
			case "afterPackage":
				this.value.afterPackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPackage",assigned,this.value.afterPackage,pos);
				break;
			case "afterReturn":
				this.value.afterReturn = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterReturn",assigned,this.value.afterReturn,pos);
				break;
			case "beforeBlocks":
				this.value.beforeBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeBlocks",assigned,this.value.beforeBlocks,pos);
				break;
			case "beforeDocCommentEmptyLines":
				this.value.beforeDocCommentEmptyLines = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeDocCommentEmptyLines",assigned,this.value.beforeDocCommentEmptyLines,pos);
				break;
			case "beforePackage":
				this.value.beforePackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforePackage",assigned,this.value.beforePackage,pos);
				break;
			case "beforeRightCurly":
				this.value.beforeRightCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeRightCurly",assigned,this.value.beforeRightCurly,pos);
				break;
			case "betweenMultilineComments":
				this.value.betweenMultilineComments = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenMultilineComments",assigned,this.value.betweenMultilineComments,pos);
				break;
			case "betweenSingleLineTypes":
				this.value.betweenSingleLineTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenSingleLineTypes",assigned,this.value.betweenSingleLineTypes,pos);
				break;
			case "betweenTypes":
				this.value.betweenTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenTypes",assigned,this.value.betweenTypes,pos);
				break;
			case "classEmptyLines":
				this.value.classEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"classEmptyLines",assigned,this.value.classEmptyLines,pos);
				break;
			case "conditionalsEmptyLines":
				this.value.conditionalsEmptyLines = this.loadObjectField(($_=new JsonParser_$12(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalsEmptyLines",assigned,this.value.conditionalsEmptyLines,pos);
				break;
			case "enumAbstractEmptyLines":
				this.value.enumAbstractEmptyLines = this.loadObjectField(($_=new JsonParser_$15(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumAbstractEmptyLines",assigned,this.value.enumAbstractEmptyLines,pos);
				break;
			case "enumEmptyLines":
				this.value.enumEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumEmptyLines",assigned,this.value.enumEmptyLines,pos);
				break;
			case "externClassEmptyLines":
				this.value.externClassEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"externClassEmptyLines",assigned,this.value.externClassEmptyLines,pos);
				break;
			case "finalNewline":
				this.value.finalNewline = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"finalNewline",assigned,this.value.finalNewline,pos);
				break;
			case "importAndUsing":
				this.value.importAndUsing = this.loadObjectField(($_=new JsonParser_$24(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"importAndUsing",assigned,this.value.importAndUsing,pos);
				break;
			case "interfaceEmptyLines":
				this.value.interfaceEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"interfaceEmptyLines",assigned,this.value.interfaceEmptyLines,pos);
				break;
			case "lineCommentsBetweenFunctions":
				this.value.lineCommentsBetweenFunctions = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenFunctions",assigned,this.value.lineCommentsBetweenFunctions,pos);
				break;
			case "lineCommentsBetweenTypes":
				this.value.lineCommentsBetweenTypes = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenTypes",assigned,this.value.lineCommentsBetweenTypes,pos);
				break;
			case "macroClassEmptyLines":
				this.value.macroClassEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"macroClassEmptyLines",assigned,this.value.macroClassEmptyLines,pos);
				break;
			case "maxAnywhereInFile":
				this.value.maxAnywhereInFile = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxAnywhereInFile",assigned,this.value.maxAnywhereInFile,pos);
				break;
			case "typedefEmptyLines":
				this.value.typedefEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefEmptyLines",assigned,this.value.typedefEmptyLines,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { abstractEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), afterBlocks : "remove", afterFieldsWithDocComments : "one", afterFileHeaderComment : 1, afterLeftCurly : "remove", afterPackage : 1, afterReturn : "remove", beforeBlocks : "remove", beforeDocCommentEmptyLines : "one", beforePackage : 0, beforeRightCurly : "remove", betweenMultilineComments : 0, betweenSingleLineTypes : 0, betweenTypes : 1, classEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), conditionalsEmptyLines : new JsonParser_$12([],this.putils,0).getAuto(), enumAbstractEmptyLines : new JsonParser_$15([],this.putils,0).getAuto(), enumEmptyLines : new JsonParser_$18([],this.putils,0).getAuto(), externClassEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), finalNewline : true, importAndUsing : new JsonParser_$24([],this.putils,0).getAuto(), interfaceEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), lineCommentsBetweenFunctions : "keep", lineCommentsBetweenTypes : "keep", macroClassEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), maxAnywhereInFile : 1, typedefEmptyLines : new JsonParser_$18([],this.putils,0).getAuto()};
	}
	,__class__: JsonParser_$4
});
var JsonParser_$42 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_42"] = JsonParser_$42;
JsonParser_$42.__name__ = "JsonParser_42";
JsonParser_$42.__super__ = json2object_reader_BaseParser;
JsonParser_$42.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whilePolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamOpenPolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamClosePolicy : Null<formatter.config.WhitespacePolicy>, ?typeHintColonPolicy : Null<formatter.config.WhitespacePolicy>, ?typeExtensionPolicy : Null<formatter.config.WhitespacePolicy>, ?typeCheckColonPolicy : Null<formatter.config.WhitespacePolicy>, ?tryPolicy : Null<formatter.config.WhitespacePolicy>, ?ternaryPolicy : Null<formatter.config.WhitespacePolicy>, ?switchPolicy : Null<formatter.config.WhitespacePolicy>, ?semicolonPolicy : Null<formatter.config.WhitespacePolicy>, ?parenConfig : Null<formatter.config.ParenWhitespaceConfig>, ?openingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?objectFieldColonPolicy : Null<formatter.config.WhitespacePolicy>, ?intervalPolicy : Null<formatter.config.WhitespacePolicy>, ?ifPolicy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe4Policy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe3Policy : Null<formatter.config.WhitespacePolicy>, ?formatStringInterpolation : Null<Bool>, ?forPolicy : Null<formatter.config.WhitespacePolicy>, ?dotPolicy : Null<formatter.config.WhitespacePolicy>, ?doPolicy : Null<formatter.config.WhitespacePolicy>, ?compressSuccessiveParenthesis : Null<Bool>, ?commaPolicy : Null<formatter.config.WhitespacePolicy>, ?colonPolicy : Null<formatter.config.WhitespacePolicy>, ?closingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?catchPolicy : Null<formatter.config.WhitespacePolicy>, ?caseColonPolicy : Null<formatter.config.WhitespacePolicy>, ?bracesConfig : Null<formatter.config.BracesWhitespaceConfig>, ?binopPolicy : Null<formatter.config.WhitespacePolicy>, ?arrowFunctionsPolicy : Null<formatter.config.WhitespacePolicy>, ?addLineCommentSpace : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["addLineCommentSpace","arrowFunctionsPolicy","binopPolicy","bracesConfig","caseColonPolicy","catchPolicy","closingBracketPolicy","colonPolicy","commaPolicy","compressSuccessiveParenthesis","doPolicy","dotPolicy","forPolicy","formatStringInterpolation","functionTypeHaxe3Policy","functionTypeHaxe4Policy","ifPolicy","intervalPolicy","objectFieldColonPolicy","openingBracketPolicy","parenConfig","semicolonPolicy","switchPolicy","ternaryPolicy","tryPolicy","typeCheckColonPolicy","typeExtensionPolicy","typeHintColonPolicy","typeParamClosePolicy","typeParamOpenPolicy","whilePolicy"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "addLineCommentSpace":
				this.value.addLineCommentSpace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"addLineCommentSpace",assigned,this.value.addLineCommentSpace,pos);
				break;
			case "arrowFunctionsPolicy":
				this.value.arrowFunctionsPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrowFunctionsPolicy",assigned,this.value.arrowFunctionsPolicy,pos);
				break;
			case "binopPolicy":
				this.value.binopPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"binopPolicy",assigned,this.value.binopPolicy,pos);
				break;
			case "bracesConfig":
				this.value.bracesConfig = this.loadObjectField(($_=new JsonParser_$45(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"bracesConfig",assigned,this.value.bracesConfig,pos);
				break;
			case "caseColonPolicy":
				this.value.caseColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColonPolicy",assigned,this.value.caseColonPolicy,pos);
				break;
			case "catchPolicy":
				this.value.catchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchPolicy",assigned,this.value.catchPolicy,pos);
				break;
			case "closingBracketPolicy":
				this.value.closingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingBracketPolicy",assigned,this.value.closingBracketPolicy,pos);
				break;
			case "colonPolicy":
				this.value.colonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"colonPolicy",assigned,this.value.colonPolicy,pos);
				break;
			case "commaPolicy":
				this.value.commaPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"commaPolicy",assigned,this.value.commaPolicy,pos);
				break;
			case "compressSuccessiveParenthesis":
				this.value.compressSuccessiveParenthesis = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"compressSuccessiveParenthesis",assigned,this.value.compressSuccessiveParenthesis,pos);
				break;
			case "doPolicy":
				this.value.doPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doPolicy",assigned,this.value.doPolicy,pos);
				break;
			case "dotPolicy":
				this.value.dotPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"dotPolicy",assigned,this.value.dotPolicy,pos);
				break;
			case "forPolicy":
				this.value.forPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forPolicy",assigned,this.value.forPolicy,pos);
				break;
			case "formatStringInterpolation":
				this.value.formatStringInterpolation = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"formatStringInterpolation",assigned,this.value.formatStringInterpolation,pos);
				break;
			case "functionTypeHaxe3Policy":
				this.value.functionTypeHaxe3Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe3Policy",assigned,this.value.functionTypeHaxe3Policy,pos);
				break;
			case "functionTypeHaxe4Policy":
				this.value.functionTypeHaxe4Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe4Policy",assigned,this.value.functionTypeHaxe4Policy,pos);
				break;
			case "ifPolicy":
				this.value.ifPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifPolicy",assigned,this.value.ifPolicy,pos);
				break;
			case "intervalPolicy":
				this.value.intervalPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"intervalPolicy",assigned,this.value.intervalPolicy,pos);
				break;
			case "objectFieldColonPolicy":
				this.value.objectFieldColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectFieldColonPolicy",assigned,this.value.objectFieldColonPolicy,pos);
				break;
			case "openingBracketPolicy":
				this.value.openingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingBracketPolicy",assigned,this.value.openingBracketPolicy,pos);
				break;
			case "parenConfig":
				this.value.parenConfig = this.loadObjectField(($_=new JsonParser_$48(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"parenConfig",assigned,this.value.parenConfig,pos);
				break;
			case "semicolonPolicy":
				this.value.semicolonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"semicolonPolicy",assigned,this.value.semicolonPolicy,pos);
				break;
			case "switchPolicy":
				this.value.switchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchPolicy",assigned,this.value.switchPolicy,pos);
				break;
			case "ternaryPolicy":
				this.value.ternaryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ternaryPolicy",assigned,this.value.ternaryPolicy,pos);
				break;
			case "tryPolicy":
				this.value.tryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryPolicy",assigned,this.value.tryPolicy,pos);
				break;
			case "typeCheckColonPolicy":
				this.value.typeCheckColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeCheckColonPolicy",assigned,this.value.typeCheckColonPolicy,pos);
				break;
			case "typeExtensionPolicy":
				this.value.typeExtensionPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeExtensionPolicy",assigned,this.value.typeExtensionPolicy,pos);
				break;
			case "typeHintColonPolicy":
				this.value.typeHintColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeHintColonPolicy",assigned,this.value.typeHintColonPolicy,pos);
				break;
			case "typeParamClosePolicy":
				this.value.typeParamClosePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamClosePolicy",assigned,this.value.typeParamClosePolicy,pos);
				break;
			case "typeParamOpenPolicy":
				this.value.typeParamOpenPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamOpenPolicy",assigned,this.value.typeParamOpenPolicy,pos);
				break;
			case "whilePolicy":
				this.value.whilePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whilePolicy",assigned,this.value.whilePolicy,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { addLineCommentSpace : true, arrowFunctionsPolicy : "around", binopPolicy : "around", bracesConfig : new JsonParser_$45([],this.putils,0).getAuto(), caseColonPolicy : "onlyAfter", catchPolicy : "after", closingBracketPolicy : "none", colonPolicy : "none", commaPolicy : "onlyAfter", compressSuccessiveParenthesis : true, doPolicy : "after", dotPolicy : "none", forPolicy : "after", formatStringInterpolation : true, functionTypeHaxe3Policy : "none", functionTypeHaxe4Policy : "around", ifPolicy : "after", intervalPolicy : "none", objectFieldColonPolicy : "after", openingBracketPolicy : "noneAfter", parenConfig : new JsonParser_$48([],this.putils,0).getAuto(), semicolonPolicy : "onlyAfter", switchPolicy : "after", ternaryPolicy : "around", tryPolicy : "after", typeCheckColonPolicy : "around", typeExtensionPolicy : "after", typeHintColonPolicy : "none", typeParamClosePolicy : "none", typeParamOpenPolicy : "none", whilePolicy : "after"};
	}
	,__class__: JsonParser_$42
});
var JsonParser_$45 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_45"] = JsonParser_$45;
JsonParser_$45.__name__ = "JsonParser_45";
JsonParser_$45.__super__ = json2object_reader_BaseParser;
JsonParser_$45.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?unknownBraces : Null<formatter.config.OpenClosePolicy>, ?typedefBraces : Null<formatter.config.OpenClosePolicy>, ?objectLiteralBraces : Null<formatter.config.OpenClosePolicy>, ?blockBraces : Null<formatter.config.OpenClosePolicy>, ?anonTypeBraces : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeBraces","blockBraces","objectLiteralBraces","typedefBraces","unknownBraces"],[true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeBraces":
				this.value.anonTypeBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeBraces",assigned,this.value.anonTypeBraces,pos);
				break;
			case "blockBraces":
				this.value.blockBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockBraces",assigned,this.value.blockBraces,pos);
				break;
			case "objectLiteralBraces":
				this.value.objectLiteralBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralBraces",assigned,this.value.objectLiteralBraces,pos);
				break;
			case "typedefBraces":
				this.value.typedefBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefBraces",assigned,this.value.typedefBraces,pos);
				break;
			case "unknownBraces":
				this.value.unknownBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"unknownBraces",assigned,this.value.unknownBraces,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonTypeBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, blockBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, objectLiteralBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, typedefBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, unknownBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}};
	}
	,__class__: JsonParser_$45
});
var JsonParser_$48 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_48"] = JsonParser_$48;
JsonParser_$48.__name__ = "JsonParser_48";
JsonParser_$48.__super__ = json2object_reader_BaseParser;
JsonParser_$48.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileConditionParens : Null<formatter.config.OpenClosePolicy>, ?switchConditionParens : Null<formatter.config.OpenClosePolicy>, ?sharpConditionParens : Null<formatter.config.OpenClosePolicy>, ?metadataParens : Null<formatter.config.OpenClosePolicy>, ?ifConditionParens : Null<formatter.config.OpenClosePolicy>, ?funcParamParens : Null<formatter.config.OpenClosePolicy>, ?forLoopParens : Null<formatter.config.OpenClosePolicy>, ?expressionParens : Null<formatter.config.OpenClosePolicy>, ?conditionParens : Null<formatter.config.OpenClosePolicy>, ?catchParens : Null<formatter.config.OpenClosePolicy>, ?callParens : Null<formatter.config.OpenClosePolicy>, ?anonFuncParamParens : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFuncParamParens","callParens","catchParens","conditionParens","expressionParens","forLoopParens","funcParamParens","ifConditionParens","metadataParens","sharpConditionParens","switchConditionParens","whileConditionParens"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFuncParamParens":
				this.value.anonFuncParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFuncParamParens",assigned,this.value.anonFuncParamParens,pos);
				break;
			case "callParens":
				this.value.callParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParens",assigned,this.value.callParens,pos);
				break;
			case "catchParens":
				this.value.catchParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchParens",assigned,this.value.catchParens,pos);
				break;
			case "conditionParens":
				this.value.conditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionParens",assigned,this.value.conditionParens,pos);
				break;
			case "expressionParens":
				this.value.expressionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionParens",assigned,this.value.expressionParens,pos);
				break;
			case "forLoopParens":
				this.value.forLoopParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forLoopParens",assigned,this.value.forLoopParens,pos);
				break;
			case "funcParamParens":
				this.value.funcParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"funcParamParens",assigned,this.value.funcParamParens,pos);
				break;
			case "ifConditionParens":
				this.value.ifConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifConditionParens",assigned,this.value.ifConditionParens,pos);
				break;
			case "metadataParens":
				this.value.metadataParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataParens",assigned,this.value.metadataParens,pos);
				break;
			case "sharpConditionParens":
				this.value.sharpConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharpConditionParens",assigned,this.value.sharpConditionParens,pos);
				break;
			case "switchConditionParens":
				this.value.switchConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchConditionParens",assigned,this.value.switchConditionParens,pos);
				break;
			case "whileConditionParens":
				this.value.whileConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileConditionParens",assigned,this.value.whileConditionParens,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		var tmp = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp1 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp2 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp3 = new JsonParser_$51([],this.putils,0).getAuto();
		return { anonFuncParamParens : tmp, callParens : tmp1, catchParens : null, conditionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, expressionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, forLoopParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, funcParamParens : tmp2, ifConditionParens : null, metadataParens : tmp3, sharpConditionParens : null, switchConditionParens : null, whileConditionParens : null};
	}
	,__class__: JsonParser_$48
});
var JsonParser_$51 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_51"] = JsonParser_$51;
JsonParser_$51.__name__ = "JsonParser_51";
JsonParser_$51.__super__ = json2object_reader_BaseParser;
JsonParser_$51.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?removeInnerWhenEmpty : Null<Bool>, ?openingPolicy : Null<formatter.config.WhitespacePolicy>, ?closingPolicy : Null<formatter.config.WhitespacePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["closingPolicy","openingPolicy","removeInnerWhenEmpty"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "closingPolicy":
				this.value.closingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingPolicy",assigned,this.value.closingPolicy,pos);
				break;
			case "openingPolicy":
				this.value.openingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingPolicy",assigned,this.value.openingPolicy,pos);
				break;
			case "removeInnerWhenEmpty":
				this.value.removeInnerWhenEmpty = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"removeInnerWhenEmpty",assigned,this.value.removeInnerWhenEmpty,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { closingPolicy : "onlyAfter", openingPolicy : "none", removeInnerWhenEmpty : true};
	}
	,__class__: JsonParser_$51
});
var JsonParser_$60 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_60"] = JsonParser_$60;
JsonParser_$60.__name__ = "JsonParser_60";
JsonParser_$60.__super__ = json2object_reader_BaseParser;
JsonParser_$60.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typeParameter : Null<formatter.config.WrapRules>, ?opBoolChain : Null<formatter.config.WrapRules>, ?opAddSubChain : Null<formatter.config.WrapRules>, ?objectLiteral : Null<formatter.config.WrapRules>, ?multiVar : Null<formatter.config.WrapRules>, ?methodChain : Null<formatter.config.WrapRules>, ?metadataCallParameter : Null<formatter.config.WrapRules>, ?maxLineLength : Null<Int>, ?implementsExtends : Null<formatter.config.WrapRules>, ?functionSignature : Null<formatter.config.WrapRules>, ?casePattern : Null<formatter.config.WrapRules>, ?callParameter : Null<formatter.config.WrapRules>, ?arrayWrap : Null<formatter.config.WrapRules>, ?arrayMatrixWrap : Null<formatter.config.ArrayMatrixWrap>, ?anonType : Null<formatter.config.WrapRules>, ?anonFunctionSignature : Null<formatter.config.WrapRules> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionSignature","anonType","arrayMatrixWrap","arrayWrap","callParameter","casePattern","functionSignature","implementsExtends","maxLineLength","metadataCallParameter","methodChain","multiVar","objectLiteral","opAddSubChain","opBoolChain","typeParameter"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionSignature":
				this.value.anonFunctionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionSignature",assigned,this.value.anonFunctionSignature,pos);
				break;
			case "anonType":
				this.value.anonType = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonType",assigned,this.value.anonType,pos);
				break;
			case "arrayMatrixWrap":
				this.value.arrayMatrixWrap = this.loadObjectField(($_=new JsonParser_$84(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayMatrixWrap",assigned,this.value.arrayMatrixWrap,pos);
				break;
			case "arrayWrap":
				this.value.arrayWrap = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayWrap",assigned,this.value.arrayWrap,pos);
				break;
			case "callParameter":
				this.value.callParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParameter",assigned,this.value.callParameter,pos);
				break;
			case "casePattern":
				this.value.casePattern = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"casePattern",assigned,this.value.casePattern,pos);
				break;
			case "functionSignature":
				this.value.functionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionSignature",assigned,this.value.functionSignature,pos);
				break;
			case "implementsExtends":
				this.value.implementsExtends = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"implementsExtends",assigned,this.value.implementsExtends,pos);
				break;
			case "maxLineLength":
				this.value.maxLineLength = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxLineLength",assigned,this.value.maxLineLength,pos);
				break;
			case "metadataCallParameter":
				this.value.metadataCallParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataCallParameter",assigned,this.value.metadataCallParameter,pos);
				break;
			case "methodChain":
				this.value.methodChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"methodChain",assigned,this.value.methodChain,pos);
				break;
			case "multiVar":
				this.value.multiVar = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"multiVar",assigned,this.value.multiVar,pos);
				break;
			case "objectLiteral":
				this.value.objectLiteral = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteral",assigned,this.value.objectLiteral,pos);
				break;
			case "opAddSubChain":
				this.value.opAddSubChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opAddSubChain",assigned,this.value.opAddSubChain,pos);
				break;
			case "opBoolChain":
				this.value.opBoolChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opBoolChain",assigned,this.value.opBoolChain,pos);
				break;
			case "typeParameter":
				this.value.typeParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParameter",assigned,this.value.typeParameter,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionSignature : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "totalItemLength >= n", value : 80}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 1}]}, anonType : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, arrayMatrixWrap : "matrixWrapWithAlign", arrayWrap : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "hasMultilineItems", value : 1}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 10}], type : "fillLineWithLeadingBreak"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, callParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "anyItemLength >= n", value : 80}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, casePattern : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 2}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, functionSignature : { defaultWrap : "fillLine", defaultAdditionalIndent : 1, rules : []}, implementsExtends : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 2}]}, maxLineLength : 160, metadataCallParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, methodChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 80},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30},{ cond : "itemCount >= n", value : 4}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, multiVar : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength <= n", value : 15}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 80}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, objectLiteral : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, opAddSubChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160},{ cond : "anyItemLength >= n", value : 60}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 160}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, opBoolChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140},{ cond : "anyItemLength >= n", value : 40}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 140}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "fillLine"}]}, typeParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength >= n", value : 50}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 70}], type : "fillLine"}]}};
	}
	,__class__: JsonParser_$60
});
var JsonParser_$62 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_62"] = JsonParser_$62;
JsonParser_$62.__name__ = "JsonParser_62";
JsonParser_$62.__super__ = json2object_reader_BaseParser;
JsonParser_$62.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Bool",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.value = b;
	}
	,getAuto: function() {
		return new JsonParser_$62([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$62
});
var JsonParser_$66 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_66"] = JsonParser_$66;
JsonParser_$66.__name__ = "JsonParser_66";
JsonParser_$66.__super__ = json2object_reader_BaseParser;
JsonParser_$66.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<String>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$77(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$66([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$66
});
var JsonParser_$7 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_7"] = JsonParser_$7;
JsonParser_$7.__name__ = "JsonParser_7";
JsonParser_$7.__super__ = json2object_reader_BaseParser;
JsonParser_$7.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenStaticVars : Null<Int>, ?betweenStaticFunctions : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int>, ?afterStaticVars : Null<Int>, ?afterStaticFunctions : Null<Int>, ?afterPrivateVars : Null<Int>, ?afterPrivateFunctions : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterPrivateFunctions","afterPrivateVars","afterStaticFunctions","afterStaticVars","afterVars","beginType","betweenFunctions","betweenStaticFunctions","betweenStaticVars","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterPrivateFunctions":
				this.value.afterPrivateFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateFunctions",assigned,this.value.afterPrivateFunctions,pos);
				break;
			case "afterPrivateVars":
				this.value.afterPrivateVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateVars",assigned,this.value.afterPrivateVars,pos);
				break;
			case "afterStaticFunctions":
				this.value.afterStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticFunctions",assigned,this.value.afterStaticFunctions,pos);
				break;
			case "afterStaticVars":
				this.value.afterStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticVars",assigned,this.value.afterStaticVars,pos);
				break;
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenStaticFunctions":
				this.value.betweenStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticFunctions",assigned,this.value.betweenStaticFunctions,pos);
				break;
			case "betweenStaticVars":
				this.value.betweenStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticVars",assigned,this.value.betweenStaticVars,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterPrivateFunctions : 1, afterPrivateVars : 1, afterStaticFunctions : 1, afterStaticVars : 1, afterVars : 1, beginType : 0, betweenFunctions : 1, betweenStaticFunctions : 1, betweenStaticVars : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$7
});
var JsonParser_$77 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_77"] = JsonParser_$77;
JsonParser_$77.__name__ = "JsonParser_77";
JsonParser_$77.__super__ = json2object_reader_BaseParser;
JsonParser_$77.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,getAuto: function() {
		return new JsonParser_$77([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$77
});
var JsonParser_$80 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_80"] = JsonParser_$80;
JsonParser_$80.__name__ = "JsonParser_80";
JsonParser_$80.__super__ = json2object_reader_BaseParser;
JsonParser_$80.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rules : Null<Array<formatter.config.WrapRule>>, ?defaultWrap : Null<formatter.config.WrappingType>, ?defaultLocation : Null<formatter.config.WrappingLocation>, ?defaultAdditionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["defaultAdditionalIndent","defaultLocation","defaultWrap","rules"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "defaultAdditionalIndent":
				this.value.defaultAdditionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultAdditionalIndent",assigned,this.value.defaultAdditionalIndent,pos);
				break;
			case "defaultLocation":
				this.value.defaultLocation = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultLocation",assigned,this.value.defaultLocation,pos);
				break;
			case "defaultWrap":
				this.value.defaultWrap = this.loadObjectField(($_=new JsonParser_$114(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultWrap",assigned,this.value.defaultWrap,pos);
				break;
			case "rules":
				this.value.rules = this.loadObjectField(($_=new JsonParser_$116(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rules",assigned,this.value.rules,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { defaultAdditionalIndent : 0, defaultLocation : "afterLast", defaultWrap : "noWrap", rules : []};
	}
	,__class__: JsonParser_$80
});
var JsonParser_$84 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_84"] = JsonParser_$84;
JsonParser_$84.__name__ = "JsonParser_84";
JsonParser_$84.__super__ = json2object_reader_BaseParser;
JsonParser_$84.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noMatrixWrap";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ArrayMatrixWrap",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noMatrixWrap","matrixWrapNoAlign","matrixWrapWithAlign"],"noMatrixWrap");
	}
	,getAuto: function() {
		return new JsonParser_$84([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$84
});
var JsonParser_$96 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
$hxClasses["JsonParser_96"] = JsonParser_$96;
JsonParser_$96.__name__ = "JsonParser_96";
JsonParser_$96.__super__ = json2object_reader_BaseParser;
JsonParser_$96.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Int",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.value = this.loadJsonInt(f,pos,variable,this.value);
	}
	,getAuto: function() {
		return new JsonParser_$96([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
	,__class__: JsonParser_$96
});
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.list = function(it) {
	var l = new haxe_ds_List();
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		l.add(i1);
	}
	return l;
};
Lambda.map = function(it,f) {
	var l = new haxe_ds_List();
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		l.add(f(x1));
	}
	return l;
};
Lambda.mapi = function(it,f) {
	var l = new haxe_ds_List();
	var i = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		l.add(f(i++,x1));
	}
	return l;
};
Lambda.flatten = function(it) {
	var l = new haxe_ds_List();
	var e = $getIterator(it);
	while(e.hasNext()) {
		var e1 = e.next();
		var x = $getIterator(e1);
		while(x.hasNext()) {
			var x1 = x.next();
			l.add(x1);
		}
	}
	return l;
};
Lambda.flatMap = function(it,f) {
	return Lambda.flatten(Lambda.map(it,f));
};
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.foreach = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(!f(x1)) {
			return false;
		}
	}
	return true;
};
Lambda.iter = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		f(x1);
	}
};
Lambda.filter = function(it,f) {
	var l = new haxe_ds_List();
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			l.add(x1);
		}
	}
	return l;
};
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Lambda.empty = function(it) {
	return !$getIterator(it).hasNext();
};
Lambda.indexOf = function(it,v) {
	var i = 0;
	var v2 = $getIterator(it);
	while(v2.hasNext()) {
		var v21 = v2.next();
		if(v == v21) {
			return i;
		}
		++i;
	}
	return -1;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Lambda.concat = function(a,b) {
	var l = new haxe_ds_List();
	var x = $getIterator(a);
	while(x.hasNext()) {
		var x1 = x.next();
		l.add(x1);
	}
	var x = $getIterator(b);
	while(x.hasNext()) {
		var x1 = x.next();
		l.add(x1);
	}
	return l;
};
var Libs = function() { };
$hxClasses["Libs"] = Libs;
Libs.__name__ = "Libs";
Libs.getLibsConfig = function(target,targetName) {
	var name = targetName != null ? targetName : $hxEnums[target.__enum__].__constructs__[target._hx_index]._hx_name;
	if(Object.prototype.hasOwnProperty.call(Libs.available.h,name)) {
		return Libs.available.h[name];
	} else {
		return [];
	}
};
Libs.getDefaultLibs = function(target,targetName) {
	var name = targetName != null ? targetName : $hxEnums[target.__enum__].__constructs__[target._hx_index]._hx_name;
	if(Object.prototype.hasOwnProperty.call(Libs.defaultChecked.h,name)) {
		return Libs.defaultChecked.h[name];
	} else {
		return [];
	}
};
var LineWidget = function(cm,type,name,parameters,retType,description,currentParameter,pos) {
	this.element = window.document.createElement("div");
	this.element.className = "lint-error";
	var spanText = window.document.createElement("span");
	spanText.textContent = type + " " + name + "(";
	this.element.appendChild(spanText);
	var parametersSpan = window.document.createElement("span");
	spanText.appendChild(parametersSpan);
	this.parametersSpanElements = [];
	var _g = 0;
	var _g1 = parameters.length;
	while(_g < _g1) {
		var i = _g++;
		var spanText2 = window.document.createElement("span");
		spanText2.textContent = parameters[i];
		if(i == currentParameter) {
			spanText2.className = "selectedParameter";
		}
		parametersSpan.appendChild(spanText2);
		this.parametersSpanElements.push(spanText2);
		if(i != parameters.length - 1) {
			var spanCommaText = window.document.createElement("span");
			spanCommaText.textContent = ", ";
			parametersSpan.appendChild(spanCommaText);
		}
	}
	this.updateParameters(currentParameter);
	var spanText3 = window.document.createElement("span");
	spanText3.textContent = "):" + retType;
	this.element.appendChild(spanText3);
	if(description != null) {
		this.element.appendChild(window.document.createElement("br"));
		var spanDescription = window.document.createElement("span");
		spanDescription.innerHTML = description;
		this.element.appendChild(spanDescription);
	}
	this.widget = cm.addLineWidget(pos.line,this.element,{ coverGutter : false, noHScroll : true});
};
$hxClasses["LineWidget"] = LineWidget;
LineWidget.__name__ = "LineWidget";
LineWidget.prototype = {
	updateParameters: function(currentParameter) {
		var _g = 0;
		var _g1 = this.parametersSpanElements.length;
		while(_g < _g1) {
			var i = _g++;
			if(i == currentParameter) {
				this.parametersSpanElements[i].className = "selectedParameter";
			} else {
				this.parametersSpanElements[i].className = "";
			}
		}
	}
	,getWidget: function() {
		return this.widget;
	}
	,getElement: function() {
		return this.element;
	}
	,__class__: LineWidget
};
Math.__name__ = "Math";
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var SourceTools = function() { };
$hxClasses["SourceTools"] = SourceTools;
SourceTools.__name__ = "SourceTools";
SourceTools.splitLines = function(str) {
	return new EReg("\r\n|\n|\r","g").split(str);
};
SourceTools.indexToPos = function(src,idx) {
	var pos = { line : 0, ch : 0};
	var lines = SourceTools.splitLines(src);
	var _g = 0;
	while(_g < lines.length) {
		var l = lines[_g];
		++_g;
		if(idx >= l.length + 1) {
			idx -= l.length + 1;
			pos.line++;
		} else {
			pos.ch += idx;
			break;
		}
	}
	return pos;
};
SourceTools.posToIndex = function(src,pos) {
	var char = 0;
	var lines = SourceTools.splitLines(src);
	var _g = 0;
	var _g1 = pos.line;
	while(_g < _g1) {
		var i = _g++;
		char += lines[i].length + 1;
	}
	char += pos.ch;
	return char;
};
SourceTools.getAutocompleteIndex = function(src,pos) {
	var charPos = SourceTools.posToIndex(src,pos);
	var charCode = HxOverrides.cca(src,charPos);
	var iniChar = charPos;
	while(40 != charCode && 44 != charCode && 46 != charCode) {
		--charPos;
		charCode = HxOverrides.cca(src,charPos);
		if(charPos < 0) {
			return null;
		}
	}
	++charPos;
	var skipped = src.substring(iniChar,charPos);
	if(new EReg("[^a-zA-Z0-9_\\s]","").match(skipped)) {
		return null;
	}
	return charPos;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var api_Target = $hxEnums["api.Target"] = { __ename__:"api.Target",__constructs__:null
	,JS: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"api.Target",toString:$estr}; },$_._hx_name="JS",$_.__params__ = ["name"],$_)
	,NEKO: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"api.Target",toString:$estr}; },$_._hx_name="NEKO",$_.__params__ = ["name"],$_)
	,EVAL: ($_=function(name) { return {_hx_index:2,name:name,__enum__:"api.Target",toString:$estr}; },$_._hx_name="EVAL",$_.__params__ = ["name"],$_)
	,HL: ($_=function(name) { return {_hx_index:3,name:name,__enum__:"api.Target",toString:$estr}; },$_._hx_name="HL",$_.__params__ = ["name"],$_)
	,SWF: ($_=function(name,version) { return {_hx_index:4,name:name,version:version,__enum__:"api.Target",toString:$estr}; },$_._hx_name="SWF",$_.__params__ = ["name","version"],$_)
};
api_Target.__constructs__ = [api_Target.JS,api_Target.NEKO,api_Target.EVAL,api_Target.HL,api_Target.SWF];
var api_TargetV2 = $hxEnums["api.TargetV2"] = { __ename__:"api.TargetV2",__constructs__:null
	,JS: ($_=function(name,version) { return {_hx_index:0,name:name,version:version,__enum__:"api.TargetV2",toString:$estr}; },$_._hx_name="JS",$_.__params__ = ["name","version"],$_)
	,NEKO: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"api.TargetV2",toString:$estr}; },$_._hx_name="NEKO",$_.__params__ = ["name"],$_)
	,EVAL: ($_=function(name) { return {_hx_index:2,name:name,__enum__:"api.TargetV2",toString:$estr}; },$_._hx_name="EVAL",$_.__params__ = ["name"],$_)
	,HL: ($_=function(name) { return {_hx_index:3,name:name,__enum__:"api.TargetV2",toString:$estr}; },$_._hx_name="HL",$_.__params__ = ["name"],$_)
};
api_TargetV2.__constructs__ = [api_TargetV2.JS,api_TargetV2.NEKO,api_TargetV2.EVAL,api_TargetV2.HL];
var api_ECMAScriptVersion = $hxEnums["api.ECMAScriptVersion"] = { __ename__:"api.ECMAScriptVersion",__constructs__:null
	,ES5: {_hx_name:"ES5",_hx_index:0,__enum__:"api.ECMAScriptVersion",toString:$estr}
	,ES6: {_hx_name:"ES6",_hx_index:1,__enum__:"api.ECMAScriptVersion",toString:$estr}
};
api_ECMAScriptVersion.__constructs__ = [api_ECMAScriptVersion.ES5,api_ECMAScriptVersion.ES6];
var byte_ByteData = {};
byte_ByteData.get_length = function(this1) {
	return this1.length;
};
byte_ByteData.readByte = function(this1,i) {
	return this1.b[i];
};
byte_ByteData._new = function(data) {
	var this1 = data;
	return this1;
};
byte_ByteData.ofString = function(s) {
	var this1 = haxe_io_Bytes.ofString(s);
	return this1;
};
byte_ByteData.ofBytes = function(b) {
	var this1 = b;
	return this1;
};
byte_ByteData.readString = function(this1,pos,len) {
	return this1.getString(pos,len);
};
var formatter_FormatStats = function() { };
$hxClasses["formatter.FormatStats"] = formatter_FormatStats;
formatter_FormatStats.__name__ = "formatter.FormatStats";
formatter_FormatStats.reset = function() {
	formatter_FormatStats.totalFiles = 0;
	formatter_FormatStats.successFiles = 0;
	formatter_FormatStats.failedFiles = 0;
	formatter_FormatStats.disabledFiles = 0;
	formatter_FormatStats.totalLinesOrig = 0;
	formatter_FormatStats.totalLinesFormatted = 0;
};
formatter_FormatStats.incSuccess = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.successFiles++;
};
formatter_FormatStats.incFailed = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.failedFiles++;
};
formatter_FormatStats.incDisabled = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.disabledFiles++;
};
formatter_FormatStats.addOrigLines = function(count) {
	formatter_FormatStats.totalLinesOrig += count;
};
formatter_FormatStats.addFormattedLines = function(count) {
	formatter_FormatStats.totalLinesFormatted += count;
};
var formatter_Result = $hxEnums["formatter.Result"] = { __ename__:"formatter.Result",__constructs__:null
	,Success: ($_=function(formattedCode) { return {_hx_index:0,formattedCode:formattedCode,__enum__:"formatter.Result",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["formattedCode"],$_)
	,Failure: ($_=function(errorMessage) { return {_hx_index:1,errorMessage:errorMessage,__enum__:"formatter.Result",toString:$estr}; },$_._hx_name="Failure",$_.__params__ = ["errorMessage"],$_)
	,Disabled: {_hx_name:"Disabled",_hx_index:2,__enum__:"formatter.Result",toString:$estr}
};
formatter_Result.__constructs__ = [formatter_Result.Success,formatter_Result.Failure,formatter_Result.Disabled];
var formatter_Formatter = function() { };
$hxClasses["formatter.Formatter"] = formatter_Formatter;
formatter_Formatter.__name__ = "formatter.Formatter";
formatter_Formatter.format = function(input,config,lineSeparator,entryPoint,range) {
	if(config == null) {
		config = new formatter_config_Config();
	}
	var inputData;
	switch(input._hx_index) {
	case 0:
		var code = input.code;
		var content = haxe_io_Bytes.ofString(code);
		inputData = { fileName : "code snippet", content : content, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
		return formatter_Formatter.formatInputData(inputData);
	case 1:
		var tokenList = input.tokenList;
		var tokenTree = input.tokenTree;
		var code = input.code;
		inputData = { fileName : "<unknown.hx>", content : code, tokenList : tokenList, tokenTree : tokenTree, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
		return formatter_Formatter.formatInputData(inputData);
	}
};
formatter_Formatter.formatInputData = function(inputData) {
	try {
		var config = inputData.config;
		if(config.disableFormatting) {
			return formatter_Result.Disabled;
		}
		if(config.isExcluded(inputData.fileName)) {
			return formatter_Result.Disabled;
		}
		tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Relaxed;
		var parsedCode = new formatter_codedata_ParsedCode(inputData);
		formatter_FormatStats.totalLinesOrig += parsedCode.lines.length;
		var indenter = new formatter_marker_Indenter(config.indentation);
		indenter.setParsedCode(parsedCode);
		var markTokenText = new formatter_marker_MarkTokenText(config,parsedCode,indenter);
		var markWhitespace = new formatter_marker_MarkWhitespace(config,parsedCode,indenter);
		var markLineEnds = new formatter_marker_MarkLineEnds(config,parsedCode,indenter);
		var markSameLine = new formatter_marker_MarkSameLine(config,parsedCode,indenter);
		var markWrapping = new formatter_marker_wrapping_MarkWrapping(config,parsedCode,indenter);
		var markEmptyLines = new formatter_marker_MarkEmptyLines(config,parsedCode,indenter);
		var markAdditionalIndent = new formatter_marker_MarkAdditionalIndentation(config,parsedCode,indenter);
		markTokenText.run();
		markWhitespace.run();
		markLineEnds.run();
		markSameLine.run();
		markWrapping.run();
		markEmptyLines.run();
		markTokenText.finalRun();
		markAdditionalIndent.run();
		var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(config.lineEnds,parsedCode);
		var lines = new formatter_codedata_CodeLines(parsedCode,indenter,inputData.range);
		lines.applyWrapping(config.wrapping,outputLineEnds);
		markEmptyLines.finalRun(lines);
		var formatted = lines.print(outputLineEnds);
		formatter_FormatStats.totalLinesFormatted += formatted.split(outputLineEnds).length;
		return formatter_Result.Success(formatted);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var e = haxe_Exception.caught(_g).unwrap();
		var callstack = haxe_CallStack.toString(haxe_CallStack.exceptionStack());
		return formatter_Result.Failure((e == null ? "null" : Std.string(e)) + "\n" + callstack + "\n\n");
	}
};
formatter_Formatter.main = function() {
	var result = formatter_Formatter.format(formatter_FormatterInput.Code(" trace ( 'foo' ) ; "),new formatter_config_Config(),null,tokentree_TokenTreeEntryPoint.ExpressionLevel);
	switch(result._hx_index) {
	case 0:
		var formattedCode = result.formattedCode;
		$global.console.log("Success: " + formattedCode);
		break;
	case 1:
		var errorMessage = result.errorMessage;
		$global.console.log("Failed to format: " + errorMessage);
		break;
	case 2:
		$global.console.log("Formatting disabled");
		break;
	}
};
var formatter_FormatterInput = $hxEnums["formatter.FormatterInput"] = { __ename__:"formatter.FormatterInput",__constructs__:null
	,Code: ($_=function(code) { return {_hx_index:0,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_._hx_name="Code",$_.__params__ = ["code"],$_)
	,Tokens: ($_=function(tokenList,tokenTree,code) { return {_hx_index:1,tokenList:tokenList,tokenTree:tokenTree,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_._hx_name="Tokens",$_.__params__ = ["tokenList","tokenTree","code"],$_)
};
formatter_FormatterInput.__constructs__ = [formatter_FormatterInput.Code,formatter_FormatterInput.Tokens];
var formatter_codedata_CodeLine = function(indent) {
	this.indent = indent;
	this.parts = [];
	this.emptyLinesAfter = 0;
	this.verbatim = false;
	this.partialLine = false;
};
$hxClasses["formatter.codedata.CodeLine"] = formatter_codedata_CodeLine;
formatter_codedata_CodeLine.__name__ = "formatter.codedata.CodeLine";
formatter_codedata_CodeLine.prototype = {
	addToken: function(tokenInfo) {
		if(tokenInfo.emptyLinesAfter > this.emptyLinesAfter) {
			this.emptyLinesAfter = tokenInfo.emptyLinesAfter;
		}
		if(this.currentPart == null) {
			this.currentPart = { firstToken : tokenInfo.token, lastToken : tokenInfo.token, text : "", multiLine : false, firstLineLength : -1, lastLineLength : -1};
			this.parts.push(this.currentPart);
		}
		this.currentPart.lastToken = tokenInfo.token;
		if(tokenInfo.spacesBefore > 0) {
			this.currentPart.text += StringTools.lpad(""," ",tokenInfo.spacesBefore);
		}
		if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space && tokenInfo.spacesAfter > 0) {
			this.currentPart.text += tokenInfo.text + StringTools.lpad(""," ",tokenInfo.spacesAfter);
		} else {
			this.currentPart.text += tokenInfo.text;
		}
		if(tokenInfo.wrapAfter) {
			this.currentPart = null;
		}
	}
	,applyWrapping: function(config,parsedCode,indenter,lineSeparator) {
		var lineLength = indenter.calcAbsoluteIndent(this.indent);
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) {
			var part = _g1[_g];
			++_g;
			this.calcLineLengths(part,lineSeparator);
		}
		var _g = 0;
		var _g1 = this.parts.length;
		while(_g < _g1) {
			var index = _g++;
			var part = this.parts[index];
			if(part.multiLine) {
				if(lineLength + part.firstLineLength > config.maxLineLength) {
					return this.wrappedAt(index,config,parsedCode,indenter);
				}
				lineLength = part.lastLineLength;
				continue;
			}
			lineLength += part.text.length;
			if(lineLength > config.maxLineLength) {
				return this.wrappedAt(index,config,parsedCode,indenter);
			}
		}
		return [this];
	}
	,calcLineLengths: function(part,lineSeparator) {
		var lines = part.text.split(lineSeparator);
		part.multiLine = lines.length > 1;
		if(part.multiLine) {
			part.firstLineLength = lines[0].length;
			part.lastLineLength = lines[lines.length - 1].length;
		} else {
			part.firstLineLength = part.text.length;
			part.lastLineLength = -1;
		}
	}
	,wrappedAt: function(index,config,parsedCode,indenter) {
		return this.wrapNormal(config,parsedCode,indenter);
	}
	,wrapNormal: function(config,parsedCode,indenter) {
		if(this.parts.length <= 0) {
			return [this];
		}
		var line = new formatter_codedata_CodeLine(this.indent);
		var part = this.parts.shift();
		line.parts = [part];
		var lineLength = indenter.calcAbsoluteIndent(this.indent) + part.text.length;
		var lines = [line];
		var lastPart = part;
		while(this.parts.length > 0) {
			var p = this.parts.shift();
			var partLength = p.firstLineLength;
			if(!p.multiLine) {
				partLength = StringTools.rtrim(p.text).length;
			}
			if(lineLength + partLength >= config.maxLineLength) {
				parsedCode.tokenList.lineEndAfter(lastPart.lastToken);
				var info = parsedCode.tokenList.getTokenAt(p.firstToken.index);
				var additionalIndent = 0;
				if(info != null) {
					additionalIndent = info.additionalIndent;
				}
				var newIndent = indenter.calcIndent(p.firstToken) + additionalIndent;
				line = new formatter_codedata_CodeLine(newIndent);
				lineLength = indenter.calcAbsoluteIndent(newIndent);
				lines.push(line);
			}
			line.parts.push(p);
			if(p.lastLineLength <= 0) {
				lineLength += p.firstLineLength;
			} else {
				lineLength += p.lastLineLength;
			}
			lastPart = p;
		}
		line.emptyLinesAfter = this.emptyLinesAfter;
		return lines;
	}
	,print: function(indenter,lineSeparator) {
		var line = "";
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) {
			var part = _g1[_g];
			++_g;
			line += part.text;
		}
		if(this.partialLine) {
			line = indenter.makeIndentString(this.indent) + line;
		} else {
			line = indenter.makeIndentString(this.indent) + StringTools.rtrim(line);
		}
		var _g = 0;
		var _g1 = this.emptyLinesAfter;
		while(_g < _g1) {
			var index = _g++;
			if(indenter.shouldAddTrailingWhitespace()) {
				line += indenter.makeIndentString(this.indent);
			}
			line += lineSeparator;
		}
		return line;
	}
	,__class__: formatter_codedata_CodeLine
};
var formatter_codedata_CodeLines = function(parsedCode,indenter,range) {
	this.lines = [];
	this.indenter = indenter;
	this.parsedCode = parsedCode;
	this.range = null;
	this.posRange = range;
	this.trailingWhitespaceAfterRange = "";
	this.rangeStartOffset = 0;
	this.rangeEndOffset = 0;
	if(range != null) {
		var start = parsedCode.tokenList.getTokenAtOffset(range.startPos);
		var end = parsedCode.tokenList.getTokenAtOffset(range.endPos);
		if(end != null && range.endPos - 1 < end.token.pos.min) {
			end = parsedCode.tokenList.getPreviousToken(end.token);
		}
		if(start != null && end != null) {
			var _g = start.token.tok;
			if(_g._hx_index == 7) {
				var s = _g.s;
				this.rangeStartOffset = this.calcStartCommentOffset(start);
			} else {
				var startLine = parsedCode.getLinePos(start.token.pos.min);
				var rangeStartLine = parsedCode.getLinePos(range.startPos);
				var endLine = parsedCode.getLinePos(start.token.pos.max);
				if(startLine.line != rangeStartLine.line) {
					this.rangeStartOffset = range.startPos - rangeStartLine.ofs - start.token.pos.min;
				}
			}
			var _g = end.token.tok;
			if(_g._hx_index == 7) {
				var s = _g.s;
				this.rangeEndOffset = this.calcEndCommentOffset(end);
			} else if(this.posRange.endPos >= end.token.pos.min && this.posRange.endPos < end.token.pos.max) {
				this.rangeEndOffset = end.text.length - (end.token.pos.max - this.posRange.endPos);
			}
			this.range = { startPos : start.token.index, endPos : end.token.index};
		}
	}
	this.buildLines();
};
$hxClasses["formatter.codedata.CodeLines"] = formatter_codedata_CodeLines;
formatter_codedata_CodeLines.__name__ = "formatter.codedata.CodeLines";
formatter_codedata_CodeLines.prototype = {
	calcStartCommentOffset: function(info) {
		var comment = this.parsedCode.getString(info.token.pos.min,info.token.pos.max);
		var commentLines = comment.split(this.parsedCode.lineSeparator);
		var index = 0;
		var offset = 0;
		var sepLength = this.parsedCode.lineSeparator.length;
		var pos = this.posRange.startPos - info.token.pos.min;
		var _g = 0;
		while(_g < commentLines.length) {
			var line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) {
			var j = _g++;
			offset += commentLines[j].length + sepLength;
		}
		return offset;
	}
	,calcEndCommentOffset: function(info) {
		var comment = this.parsedCode.getString(info.token.pos.min,info.token.pos.max);
		var commentLines = comment.split(this.parsedCode.lineSeparator);
		var index = 0;
		var offset = 0;
		var trailCount = 0;
		var pos = this.posRange.endPos - info.token.pos.min;
		var sepLength = this.parsedCode.lineSeparator.length;
		var _g = 0;
		while(_g < commentLines.length) {
			var line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				trailCount = line.length - (pos - offset);
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) {
			var j = _g++;
			offset += commentLines[j].length + sepLength;
		}
		var lastLine = commentLines[index];
		return offset + lastLine.length - trailCount;
	}
	,buildLines: function() {
		var line = null;
		var index = 0;
		while(index < this.parsedCode.tokenList.tokens.length) {
			if(this.range != null) {
				if(index > this.range.endPos) {
					break;
				}
			}
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(index);
			if(tokenInfo == null) {
				++index;
				continue;
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:off") {
					line = null;
					index = this.skipFormatterOff(index);
					continue;
				}
			}
			if(this.range != null) {
				if(index < this.range.startPos) {
					++index;
					continue;
				}
			}
			if(line == null) {
				line = new formatter_codedata_CodeLine(this.indenter.calcIndent(tokenInfo.token) + tokenInfo.additionalIndent);
				this.lines.push(line);
			}
			if(this.range != null) {
				if(index == this.range.startPos && this.rangeStartOffset > 0) {
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,this.rangeStartOffset,null);
					line.indent = 0;
				}
			}
			if(this.range != null && index == this.range.endPos) {
				if(this.posRange.endPos >= tokenInfo.token.pos.min && this.posRange.endPos < tokenInfo.token.pos.max) {
					var index1 = 0;
					if(this.range.endPos == this.range.startPos) {
						index1 = this.rangeStartOffset;
					}
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,0,this.rangeEndOffset - index1);
					tokenInfo.spacesAfter = 0;
					tokenInfo.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					tokenInfo.emptyLinesAfter = 0;
					line.partialLine = true;
				}
				if(this.posRange.endPos > tokenInfo.token.pos.max) {
					this.trailingWhitespaceAfterRange = this.parsedCode.getString(tokenInfo.token.pos.max,this.posRange.endPos);
					line.partialLine = true;
				}
			}
			line.addToken(tokenInfo);
			if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				line = null;
			}
			++index;
		}
	}
	,skipFormatterOff: function(index) {
		var startIndex = index++;
		var startInfo = this.parsedCode.tokenList.getTokenAt(startIndex);
		var startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
		while(index < this.parsedCode.tokenList.tokens.length) {
			var endIndex = index++;
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
			if(tokenInfo == null) {
				continue;
			}
			if(this.range != null) {
				if(endIndex < this.range.startPos) {
					continue;
				}
				if(endIndex == this.range.startPos) {
					startInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
					startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
				}
				if(endIndex >= this.range.endPos) {
					this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
					return index;
				}
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:on") {
					if(this.range != null) {
						if(startIndex < this.range.startPos) {
							this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
							return index;
						}
					}
					var endLine = this.parsedCode.getLinePos(tokenInfo.token.pos.max).line;
					this.copyVerbatimLines(startLine,endLine);
					return index;
				}
			}
		}
		var endLine = this.parsedCode.lines.length - 1;
		this.copyVerbatimLines(startLine,endLine);
		return index;
	}
	,copyVerbatimLines: function(startLine,endLine) {
		var startOffs = this.parsedCode.linesIdx[startLine].l;
		var endOffs = this.parsedCode.linesIdx[endLine].r;
		var content = this.parsedCode.getString(startOffs,endOffs);
		if(endLine < this.parsedCode.lines.length - 1) {
			content = StringTools.rtrim(content);
		}
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	,copyVerbatimChars: function(startPos,endPos) {
		var content = this.parsedCode.getString(startPos,endPos);
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	,applyWrapping: function(config,lineSeparator) {
		var wrappedLines = [];
		var _g = 0;
		var _g1 = this.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			var wrappedCode = line.applyWrapping(config,this.parsedCode,this.indenter,lineSeparator);
			wrappedLines = wrappedLines.concat(wrappedCode);
		}
		this.lines = wrappedLines;
	}
	,print: function(lineSeparator) {
		var _gthis = this;
		var prefix = "";
		if(this.parsedCode.tokenList.leadingEmptyLInes > 0) {
			prefix = StringTools.lpad("",lineSeparator,lineSeparator.length * this.parsedCode.tokenList.leadingEmptyLInes);
		}
		if(this.range != null) {
			if(this.range.startPos > 0) {
				prefix = "";
			}
			if(this.lines.length > 0) {
				var line = this.lines[this.lines.length - 1];
				line.emptyLinesAfter = 0;
			}
		}
		var _this = this.lines;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].print(_gthis.indenter,lineSeparator);
		}
		return prefix + result.join(lineSeparator) + this.trailingWhitespaceAfterRange;
	}
	,__class__: formatter_codedata_CodeLines
};
var formatter_codedata_ParsedCode = function(inputData) {
	this.file = { name : inputData.fileName, content : inputData.content};
	try {
		this.removeBOM();
		if(inputData.lineSeparator == null) {
			this.detectLineSeparator();
		} else {
			this.lineSeparator = inputData.lineSeparator;
		}
		this.makeLines();
		this.makePosIndices();
		if(inputData.tokenList == null) {
			this.makeTokens();
			this.getTokenTree(inputData.entryPoint);
		} else {
			this.tokens = inputData.tokenList;
			this.root = inputData.tokenTree;
			this.makeTokenList();
		}
		this.checkTokens();
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var e = haxe_Exception.caught(_g).unwrap();
		throw haxe_Exception.thrown("failed to create parser context: " + (e == null ? "null" : Std.string(e)));
	}
};
$hxClasses["formatter.codedata.ParsedCode"] = formatter_codedata_ParsedCode;
formatter_codedata_ParsedCode.__name__ = "formatter.codedata.ParsedCode";
formatter_codedata_ParsedCode.prototype = {
	checkTokens: function() {
		if(this.tokens.length != this.tokenList.tokens.length) {
			throw haxe_Exception.thrown("token count mismatch");
		}
		var skipCount = 0;
		var _g = 0;
		var _g1 = this.tokens.length;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokenList.tokens[index];
			if(info == null) {
				if(skipCount <= 0) {
					throw haxe_Exception.thrown("missing token \"" + Std.string(this.tokens[index]) + "\" [" + index + "] detected!");
				}
				--skipCount;
				continue;
			}
			var token = info.token;
			var _g2 = token.tok;
			switch(_g2._hx_index) {
			case 2:
				var _g3 = _g2.c;
				switch(_g3._hx_index) {
				case 0:
					var v = _g3.v;
					if(StringTools.startsWith(v,"-")) {
						skipCount = 1;
					}
					break;
				case 1:
					var v1 = _g3.f;
					if(StringTools.startsWith(v1,"-")) {
						skipCount = 1;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			case 6:
				var _g4 = _g2.op;
				switch(_g4._hx_index) {
				case 8:
					skipCount = 1;
					break;
				case 17:
					skipCount = 1;
					break;
				case 18:
					skipCount = 2;
					break;
				case 20:
					switch(_g4.op._hx_index) {
					case 17:
						skipCount = 2;
						break;
					case 18:
						skipCount = 3;
						break;
					default:
						skipCount = 0;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			default:
				skipCount = 0;
			}
		}
	}
	,getTokenTree: function(entryPoint) {
		if(this.tokens == null) {
			return null;
		}
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		if(this.root == null) {
			var this1 = this.file.content;
			this.root = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this1,entryPoint);
			this.makeTokenList();
		}
		return this.root;
	}
	,removeBOM: function() {
		if(this.file.content == null || this.file.content.length <= 2) {
			return;
		}
		if(this.file.content.b[0] == 239 && this.file.content.b[1] == 187 && this.file.content.b[2] == 191) {
			var withBOM = this.file.content;
			this.file.content = withBOM.sub(3,this.file.content.length - 3);
		}
	}
	,makeTokenList: function() {
		this.tokenList = new formatter_codedata_TokenList();
		this.tokenList.buildList(this.root);
	}
	,makePosIndices: function() {
		var code = this.file.content;
		this.linesIdx = [];
		var last = 0;
		var left = false;
		var skip0A = false;
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var charCode = code.b[i];
			if(skip0A && charCode == 10) {
				skip0A = false;
				continue;
			}
			if(charCode == 10 || charCode == 13) {
				if(charCode == 13 && i + 1 < code.length && code.b[i + 1] == 10) {
					skip0A = true;
					this.linesIdx.push({ l : last, r : i + 1});
					last = i + 2;
				} else {
					this.linesIdx.push({ l : last, r : i});
					last = i + 1;
				}
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	,getLinePos: function(off) {
		var lowerBound = 0;
		var upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw haxe_Exception.thrown("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw haxe_Exception.thrown("Bad offset");
			}
			var center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			var matchLeft = this.linesIdx[center].l <= off;
			var matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	,getString: function(off,off2) {
		var code = this.file.content;
		var len = off2 - off;
		if(off >= code.length || off + len > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	,isOriginalNewlineBefore: function(token) {
		if(token == null) {
			return false;
		}
		var prev = this.tokenList.getPreviousToken(token);
		if(prev == null) {
			return false;
		}
		return !this.isOriginalSameLine(prev.token,token);
	}
	,isOriginalSameLine: function(first,second) {
		var startLine = this.getLinePos(first.pos.max).line;
		var endLine = this.getLinePos(second.pos.min).line;
		return startLine == endLine;
	}
	,linesBetweenOriginal: function(first,second) {
		var startLine = this.getLinePos(first.pos.min).line;
		var endLine = this.getLinePos(second.pos.min).line;
		return endLine - startLine;
	}
	,detectLineSeparator: function() {
		var codeBytes = this.file.content;
		var code = codeBytes.toString();
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	,makeLines: function() {
		var code = this.file.content;
		var textCode = code.toString();
		this.lines = textCode.split(this.lineSeparator);
		this.emptyLines = [];
		var _g = 0;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var index = _g++;
			var line = this.lines[index];
			if(StringTools.startsWith(line,"<<<<<<<")) {
				throw haxe_Exception.thrown("not formatting \"" + this.file.name + "\" - file contains a merge conflict");
			}
			if(new EReg("^\\s*$","").match(line)) {
				this.emptyLines.push(index);
			}
		}
	}
	,makeTokens: function() {
		try {
			this.tokens = [];
			this.root = null;
			var this1 = this.file.content;
			var lexer = new haxeparser_HaxeLexer(this1,this.file.name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxparse_ParserError)) {
				var e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - ParserError: " + Std.string(e) + " (" + Std.string(e.pos) + ")");
			} else if(((_g1) instanceof haxeparser_LexerError)) {
				var e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - LexerError: " + Std.string(e.msg) + " (" + Std.string(e.pos) + ")");
			} else {
				var e = _g1;
				throw haxe_Exception.thrown("failed to make tokens " + (e == null ? "null" : Std.string(e)));
			}
		}
	}
	,__class__: formatter_codedata_ParsedCode
};
var formatter_codedata_TokenList = function() {
	this.tokens = [];
	this.leadingEmptyLInes = 0;
	this.closeTokenCache = new haxe_ds_IntMap();
};
$hxClasses["formatter.codedata.TokenList"] = formatter_codedata_TokenList;
formatter_codedata_TokenList.__name__ = "formatter.codedata.TokenList";
formatter_codedata_TokenList.prototype = {
	buildList: function(token) {
		if(token.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var index = child.index;
			if(index < 0 || child.inserted) {
				continue;
			}
			if(child.index >= this.tokens.length) {
				this.fill(child.index - this.tokens.length);
			}
			this.tokens[index] = { token : child, whitespaceAfter : formatter_codedata_WhitespaceAfterType.None, spacesBefore : 0, spacesAfter : 0, emptyLinesAfter : 0, wrapAfter : false, text : null, additionalIndent : 0};
			this.buildList(child);
		}
	}
	,fill: function(count) {
		while(count-- > 0) this.tokens.push(null);
	}
	,getCloseToken: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return null;
		}
		if(token.index < 0 || token.index >= this.tokens.length) {
			return null;
		}
		if(this.closeTokenCache.h.hasOwnProperty(token.index)) {
			return this.closeTokenCache.h[token.index];
		}
		var result;
		switch(token.tok._hx_index) {
		case 15:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BkClose);
			break;
		case 17:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrClose);
			break;
		case 19:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.PClose);
			break;
		default:
			return null;
		}
		if(result == null) {
			return null;
		}
		this.closeTokenCache.h[token.index] = result;
		return result;
	}
	,getTokenAtOffset: function(off) {
		if(this.tokens.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.tokens[this.tokens.length - 1].token.pos.max) {
			throw haxe_Exception.thrown("Bad offset");
		}
		var _g = 0;
		var _g1 = this.tokens;
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			if(token == null) {
				continue;
			}
			if(token.token.pos.max >= off) {
				return token;
			}
		}
		throw haxe_Exception.thrown("Bad offset");
	}
	,getTokenAt: function(index) {
		if(index < 0 || index >= this.tokens.length) {
			return null;
		}
		return this.tokens[index];
	}
	,getPreviousToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var prevToken = null;
		var prevIndex = token.index - 1;
		if(prevIndex >= this.tokens.length) {
			return null;
		}
		while(prevToken == null) {
			prevToken = this.tokens[prevIndex--];
			if(prevIndex < 0) {
				return null;
			}
		}
		return prevToken;
	}
	,getNextToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var nextToken = null;
		var nextIndex = token.index + 1;
		if(nextIndex >= this.tokens.length) {
			return null;
		}
		while(nextToken == null) {
			nextToken = this.tokens[nextIndex++];
			if(nextIndex < 0) {
				return null;
			}
		}
		return nextToken;
	}
	,whitespace: function(token,where) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		var prev = null;
		var prevIndex = token.index - 1;
		while(prev == null) {
			if(prevIndex < 0) {
				break;
			}
			prev = this.tokens[prevIndex--];
		}
		if(prev != null && this.needsLineBreak(prev.token)) {
			prev = null;
		}
		switch(where) {
		case "after":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "around":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "before":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "none":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneAfter":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "onlyAfter":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "onlyBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		}
	}
	,applyWhitespace: function(info,policy) {
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = policy;
			switch(policy._hx_index) {
			case 0:
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		case 1:
			switch(policy._hx_index) {
			case 0:
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				info.whitespaceAfter = policy;
				break;
			}
			break;
		case 2:
			switch(policy._hx_index) {
			case 0:
				if(info.spacesAfter > 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					info.spacesAfter = 0;
				}
				break;
			case 1:
				info.whitespaceAfter = policy;
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		}
	}
	,shouldHaveOneSpaceAfter: function(info) {
		if(info == null) {
			return;
		}
		if(info.spacesAfter <= 0) {
			info.spacesAfter = 1;
		}
	}
	,spacesAfter: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesAfter = count;
		if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.None && count > 0) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
		}
	}
	,spacesBefore: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesBefore = count;
	}
	,lineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,lineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,needsLineBreak: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(_g._hx_index == 8) {
			var _g1 = _g.s;
			return true;
		}
		return false;
	}
	,noLineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,noLineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,emptyLinesAfter: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesBefore: function(token,count) {
		if(token.index <= 0) {
			this.leadingEmptyLInes = count;
			return;
		}
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesAfterSubTree: function(token,count) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return;
		}
		var info = this.tokens[lastToken.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,tokenText: function(token,text) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.text = text;
	}
	,wrapAfter: function(token,wrap) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.wrapAfter = wrap;
	}
	,wrapBefore: function(token,wrap) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		prev.wrapAfter = wrap;
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,config,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		if(tokenStart == null || tokenEnd == null) {
			return;
		}
		var index = tokenStart.index;
		while(index < tokenEnd.index) {
			var first = index == tokenStart.index;
			var info = this.tokens[index++];
			var next = this.tokens[index];
			if(info == null) {
				continue;
			}
			var _g = info.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 40:
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
					if(lastChild != null) {
						if(lastChild.index > index) {
							index = lastChild.index;
						}
						continue;
					}
					break;
				default:
				}
				break;
			case 7:
				var _g1 = _g.s;
				continue;
			case 8:
				var _g2 = _g.s;
				continue;
			case 13:
				var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
				if(lastChild1 != null) {
					if(lastChild1.index > index) {
						index = lastChild1.index;
					}
					continue;
				}
				break;
			case 14:
				if(allowCommas) {
					continue;
				}
				break;
			case 15:
				if(!first) {
					var close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 17:
				if(!first) {
					var close1 = this.getCloseToken(info.token);
					if(close1 != null) {
						index = close1.index;
						continue;
					}
				}
				break;
			case 19:
				if(!first) {
					var close2 = this.getCloseToken(info.token);
					if(close2 != null) {
						index = close2.index;
						continue;
					}
				}
				break;
			default:
			}
			info.wrapAfter = false;
			if(next != null) {
				if(next.token.tok._hx_index == 17) {
					switch(config.lineEnds.leftCurly) {
					case "after":case "none":
						break;
					case "before":case "both":
						continue;
					}
				}
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				if(info.spacesAfter <= 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
					this.shouldHaveOneSpaceAfter(info);
				}
				break;
			}
		}
	}
	,additionalIndent: function(token,indent) {
		if(indent == null || token == null || token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.additionalIndent = indent;
	}
	,increaseIndentBetween: function(start,end,depth) {
		if(depth == 0 || start == null || start.index < 0 || end == null || end.index < 0) {
			return;
		}
		var startIndex = start.index;
		if(depth > 0) {
			++startIndex;
		}
		var endIndex = end.index;
		var _g = startIndex;
		var _g1 = endIndex;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokens[index];
			if(info == null) {
				continue;
			}
			info.additionalIndent += depth;
		}
	}
	,findTokenAtOffset: function(offset) {
		var lastInfo = null;
		var _g = 0;
		var _g1 = this.tokens;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			if(info == null) {
				continue;
			}
			if(info.token.pos.min >= offset) {
				return lastInfo;
			}
			lastInfo = info;
		}
		return lastInfo;
	}
	,isSameLine: function(first,second) {
		var startIndex = first.index;
		var endIndex = second.index;
		if(startIndex == endIndex) {
			return true;
		}
		if(startIndex < 0 || endIndex < 0) {
			return false;
		}
		if(startIndex > endIndex) {
			startIndex = second.index;
			endIndex = first.index;
		}
		while(startIndex < endIndex) {
			var currTok = this.tokens[startIndex++];
			if(currTok == null) {
				continue;
			}
			if(currTok.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
		}
		return true;
	}
	,findLowestIndex: function(start) {
		var lowest = start;
		if(!start.hasChildren()) {
			return lowest;
		}
		var _g = 0;
		var _g1 = start.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var token = this.findLowestIndex(child);
			if(token.index < lowest.index) {
				lowest = token;
			}
		}
		return lowest;
	}
	,calcLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return 0;
		}
		var spaceAdd = 0;
		if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
			spaceAdd = 1;
		}
		if(current.text == null) {
			current.text = "" + Std.string(current.token);
		}
		var length = current.text.length + spaceAdd;
		if(token.children == null || token.children.length <= 0) {
			return length;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			length += this.calcLength(child);
		}
		return length;
	}
	,isMultilineToken: function(token) {
		if(token == null || token.index < 0) {
			return false;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return false;
		}
		if(current.text.indexOf("\r") >= 0 || current.text.indexOf("\n") >= 0) {
			return true;
		}
		return false;
	}
	,calcLengthUntilNewline: function(token,stop) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var endIndex = this.tokens.length - 1;
		if(stop != null) {
			endIndex = stop.index;
		}
		var index = token.index;
		var length = 0;
		while(index <= endIndex) {
			var current = this.tokens[index++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			if(current.text.indexOf("\r") >= 0) {
				length += current.text.indexOf("\r");
				break;
			}
			if(current.text.indexOf("\n") >= 0) {
				length += current.text.indexOf("\n");
				break;
			}
			length += current.spacesBefore;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				length += current.spacesAfter;
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				break;
			}
		}
		return length;
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		if(tokenStart == null || tokenEnd == null) {
			return 0;
		}
		if(tokenStart.index < 0 || tokenEnd.index < 0) {
			return 0;
		}
		var length = 0;
		var _g = tokenStart.index;
		var _g1 = tokenEnd.index;
		while(_g < _g1) {
			var index = _g++;
			var current = this.tokens[index];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				++length;
			}
		}
		return length;
	}
	,calcLineLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				start += 2;
				break;
			}
		}
		var length = 0;
		_hx_loop2: while(start < this.tokens.length) {
			var info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			length += info.text.length;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop2;
			}
		}
		return length;
	}
	,calcLineLengthBefore: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		var length = 0;
		_hx_loop1: while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
			length += info.text.length;
		}
		return length;
	}
	,calcLineLengthAfter: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index + 1;
		var length = 0;
		_hx_loop1: while(start < this.tokens.length) {
			var info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			var tokenLength = info.text.length;
			var linefeed = info.text.lastIndexOf("\r");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			linefeed = info.text.lastIndexOf("\n");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			length += tokenLength;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
		}
		return length;
	}
	,calcTokenLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return 0;
		}
		var length = info.text.length;
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:
			length += info.spacesAfter;
			break;
		case 2:
			break;
		}
		return length;
	}
	,isNewLineBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isNewLineAfter: function(token) {
		var info = this.getTokenAt(token.index);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		if(tokenStart == null || tokenEnd == null) {
			return true;
		}
		var start = tokenStart.index;
		var end = tokenEnd.index;
		if(exclude) {
			++start;
		}
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokens[index];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
			if(info.text == null) {
				continue;
			}
			if(info.text.indexOf("\r") >= 0 || info.text.indexOf("\n") >= 0) {
				return false;
			}
		}
		return true;
	}
	,findLineStartToken: function(token) {
		if(token == null || token.index < 0) {
			return null;
		}
		var start = token.index - 1;
		while(true) {
			if(start < 0) {
				return this.tokens[0].token;
			}
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				return token;
			}
			token = info.token;
		}
	}
	,__class__: formatter_codedata_TokenList
};
var formatter_codedata_VerbatimCodeLine = function(content) {
	formatter_codedata_CodeLine.call(this,0);
	this.content = content;
	this.verbatim = true;
};
$hxClasses["formatter.codedata.VerbatimCodeLine"] = formatter_codedata_VerbatimCodeLine;
formatter_codedata_VerbatimCodeLine.__name__ = "formatter.codedata.VerbatimCodeLine";
formatter_codedata_VerbatimCodeLine.__super__ = formatter_codedata_CodeLine;
formatter_codedata_VerbatimCodeLine.prototype = $extend(formatter_codedata_CodeLine.prototype,{
	applyWrapping: function(config,parsedCode,indenter,lineSeparator) {
		return [this];
	}
	,print: function(indenter,lineSeparator) {
		return this.content;
	}
	,__class__: formatter_codedata_VerbatimCodeLine
});
var formatter_codedata_WhitespaceAfterType = $hxEnums["formatter.codedata.WhitespaceAfterType"] = { __ename__:"formatter.codedata.WhitespaceAfterType",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Space: {_hx_name:"Space",_hx_index:1,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Newline: {_hx_name:"Newline",_hx_index:2,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
};
formatter_codedata_WhitespaceAfterType.__constructs__ = [formatter_codedata_WhitespaceAfterType.None,formatter_codedata_WhitespaceAfterType.Space,formatter_codedata_WhitespaceAfterType.Newline];
var formatter_config_Config = function() {
	this.excludes = [];
	this.readConfigFromString("{}","hxformat.json");
};
$hxClasses["formatter.config.Config"] = formatter_config_Config;
formatter_config_Config.__name__ = "formatter.config.Config";
formatter_config_Config.prototype = {
	readConfigFromString: function(jsonContent,fileName) {
		var parser = new JsonParser_$1();
		var data = parser.fromJson(jsonContent,fileName);
		this.emptyLines = data.emptyLines;
		this.indentation = data.indentation;
		this.lineEnds = data.lineEnds;
		this.sameLine = data.sameLine;
		this.whitespace = data.whitespace;
		this.wrapping = data.wrapping;
		this.disableFormatting = data.disableFormatting;
		this.excludes = [];
		this.configFileName = fileName;
		var _g = 0;
		var _g1 = data.excludes;
		while(_g < _g1.length) {
			var exclude = _g1[_g];
			++_g;
			this.excludes.push(new EReg(exclude,""));
		}
	}
	,isExcluded: function(fileName) {
		var _g = 0;
		var _g1 = this.excludes;
		while(_g < _g1.length) {
			var exclude = _g1[_g];
			++_g;
			if(exclude.match(fileName)) {
				return true;
			}
		}
		return false;
	}
	,__class__: formatter_config_Config
};
var formatter_config_WhitespacePolicy = {};
formatter_config_WhitespacePolicy.remove = function(policy,removePolicy) {
	switch(removePolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		removePolicy = "after";
		break;
	case "noneBefore":
		removePolicy = "before";
		break;
	case "onlyAfter":
		removePolicy = "after";
		break;
	case "onlyBefore":
		removePolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "around":
		if(removePolicy == "before") {
			return "after";
		}
		if(removePolicy == "after") {
			return "before";
		}
		break;
	case "before":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	case "none":
		return "none";
	case "noneAfter":
		return "noneAfter";
	case "noneBefore":
		return "noneBefore";
	case "onlyAfter":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "onlyBefore":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	}
	return policy;
};
formatter_config_WhitespacePolicy.add = function(policy,addPolicy) {
	switch(addPolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		addPolicy = "after";
		break;
	case "noneBefore":
		addPolicy = "before";
		break;
	case "onlyAfter":
		addPolicy = "after";
		break;
	case "onlyBefore":
		addPolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "around":
		break;
	case "before":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	case "none":
		return addPolicy;
	case "noneAfter":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "noneBefore":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "onlyAfter":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "onlyBefore":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	}
	return policy;
};
var formatter_marker_Indenter = function(config) {
	this.config = config;
	if(config.character.toLowerCase() == "tab") {
		config.character = "\t";
	}
};
$hxClasses["formatter.marker.Indenter"] = formatter_marker_Indenter;
formatter_marker_Indenter.__name__ = "formatter.marker.Indenter";
formatter_marker_Indenter.prototype = {
	setParsedCode: function(parsedCode) {
		this.parsedCode = parsedCode;
	}
	,makeIndent: function(token) {
		return this.makeIndentString(this.calcIndent(token));
	}
	,makeIndentString: function(count) {
		return StringTools.lpad("",this.config.character,this.config.character.length * count);
	}
	,calcAbsoluteIndent: function(indent) {
		if(this.config.character == "\t") {
			return indent * this.config.tabWidth;
		}
		return indent * this.config.character.length;
	}
	,calcIndent: function(token) {
		if(token == null) {
			return 0;
		}
		var _g = token.tok;
		if(_g._hx_index == 3) {
			var _g1 = _g.s;
			if(this.config.conditionalPolicy == "fixedZero") {
				return 0;
			}
			if(this.config.conditionalPolicy == "fixedZeroIncrease") {
				return this.calcConditionalLevel(token);
			}
			if(this.config.conditionalPolicy == "fixedZeroIncreaseBlocks") {
				if(this.hasBlockParent(token)) {
					return this.calcConditionalLevel(token);
				}
				return 0;
			}
		}
		var effectiveToken = this.findEffectiveParent(token);
		return this.calcFromCandidates(effectiveToken);
	}
	,calcConditionalLevel: function(token) {
		var count = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			}
			token = token.parent;
		}
		if(count <= 0) {
			return 0;
		}
		return count;
	}
	,calcConsecutiveConditionalLevel: function(token) {
		var count = -1;
		var maxCount = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			} else {
				if(count > maxCount) {
					maxCount = count;
				}
				count = -1;
			}
			token = token.parent;
		}
		if(count > maxCount) {
			maxCount = count;
		}
		if(maxCount <= 0) {
			return 0;
		}
		return maxCount;
	}
	,shouldAddTrailingWhitespace: function() {
		return this.config.trailingWhitespace;
	}
	,findEffectiveParent: function(token) {
		if(token.tok == tokentree_TokenTreeDef.Root) {
			return token.getFirstChild();
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				if(parent.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isNewLineBefore(token)) {
						return token;
					}
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 3:
				var prev = this.parsedCode.tokenList.getPreviousToken(token);
				if(prev == null) {
					return token;
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return token;
				}
				var metadata = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.At);
				if(metadata != null) {
					if(!this.parsedCode.tokenList.isSameLineBetween(metadata,token,false)) {
						return token;
					}
					prev = this.parsedCode.tokenList.getPreviousToken(metadata);
					if(prev == null) {
						return token;
					}
					if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
						return token;
					}
				}
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				var _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index != 4) {
						return token;
					}
					break;
				case 6:
					var _g2 = _g1.op;
					return token;
				default:
				}
				return this.findEffectiveParent(token.parent);
			case 5:
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				var tmp;
				if(parent != null) {
					var _g1 = parent.tok;
					tmp = _g1._hx_index == 1 && _g1.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 4:case 21:
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 3:
			switch(_g.s) {
			case "else":case "elseif":case "end":
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 7:
			var _g1 = _g.s;
			var next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			var _g1 = next.token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 8:
			var _g1 = _g.s;
			var next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 13:
			return this.findEffectiveParent(token.parent);
		case 16:case 18:
			return this.findEffectiveParent(token.parent);
		case 17:
			var parent = token.parent;
			if(parent.tok == tokentree_TokenTreeDef.Root) {
				return token;
			}
			var firstToken = this.findEffectiveParentLineStart(token);
			if(firstToken != null) {
				return firstToken;
			}
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				return token.parent;
			case 2:
				return token;
			case 3:
				return token;
			case 4:
				break;
			}
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
						return parent;
					}
					return this.findEffectiveParent(parent);
				case 3:case 4:
					return this.findEffectiveParent(parent);
				case 5:case 6:case 7:
					return this.findEffectiveParent(parent);
				case 14:
					return this.findEffectiveParent(parent);
				case 20:case 21:
					return this.findEffectiveParent(parent);
				case 22:
					var _g1 = parent.parent.tok;
					if(_g1._hx_index == 1 && _g1.k._hx_index == 0) {
						return this.findEffectiveParent(parent.parent);
					}
					break;
				case 28:
					return this.findEffectiveParent(parent);
				default:
				}
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var _g2 = _g1.s;
					var _g1 = parent.parent.tok;
					if(_g1._hx_index == 1 && _g1.k._hx_index == 0) {
						return this.findEffectiveParent(parent.parent);
					}
				}
				break;
			case 6:
				var _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					var access = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				case 20:
					var _g = _g1.op;
					var access = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 19:
			var firstToken = this.findEffectiveParentLineStart(token);
			if(firstToken != null) {
				return firstToken;
			}
			break;
		case 20:
			return this.findEffectiveParent(token.parent);
		default:
		}
		return token;
	}
	,findEffectiveParentLineStart: function(token) {
		var firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		switch(firstToken.tok._hx_index) {
		case 16:case 18:
			var next = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					var _g1 = _g.op;
					return this.findEffectiveParent(firstToken);
				case 11:case 14:case 16:case 18:case 20:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		case 20:
			var next = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					var _g1 = _g.op;
					return this.findEffectiveParent(firstToken);
				case 11:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		default:
		}
		return null;
	}
	,countLineBreaks: function(indentingTokensCandidates,indentComplexValueExpressions) {
		var count = 0;
		var prevToken = null;
		var currentToken = null;
		var mustIndent;
		var lastIndentingToken = null;
		var skipToToken = null;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			prevToken = currentToken;
			if(prevToken == null) {
				prevToken = token;
			}
			currentToken = token;
			if(skipToToken != null) {
				if(currentToken.index >= skipToToken.index) {
					continue;
				}
				prevToken = skipToToken;
				skipToToken = null;
			}
			if(prevToken.index == currentToken.index) {
				continue;
			}
			switch(currentToken.tok._hx_index) {
			case 15:case 17:
				var close = this.parsedCode.tokenList.getCloseToken(currentToken);
				if(close != null && close.index >= 0 && close.index < prevToken.index) {
					currentToken = prevToken;
					continue;
				}
				break;
			default:
			}
			mustIndent = false;
			var _g1 = prevToken.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					if(currentToken.tok._hx_index == 19) {
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							var brOpen = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(brOpen != null) {
								if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,brOpen,false)) {
									continue;
								}
							}
							return count + this.calcIndent(firstToken.token);
						}
					}
					break;
				case 3:
					var _g2 = currentToken.tok;
					if(_g2._hx_index == 6) {
						if(_g2.op._hx_index == 4) {
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							var elseTok = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
							if(elseTok != null) {
								if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok,false)) {
									continue;
								}
								if(indentComplexValueExpressions) {
									mustIndent = true;
								}
							}
							var brOpen1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(brOpen1 != null) {
								var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen1);
								if(type._hx_index == 0) {
									continue;
								}
							}
						}
					} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
						var elseTok1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
						if(elseTok1 != null) {
							if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok1,false)) {
								continue;
							}
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						}
						var brOpen2 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(brOpen2 != null) {
							var type1 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen2);
							if(type1._hx_index == 0) {
								continue;
							}
						}
					}
					break;
				case 4:
					continue;
				case 14:
					var _g3 = currentToken.tok;
					switch(_g3._hx_index) {
					case 6:
						var _g4 = _g3.op;
						if(indentComplexValueExpressions) {
							mustIndent = true;
						}
						break;
					case 19:
						var type2 = tokentree_utils_TokenTreeCheckUtils.getPOpenType(currentToken);
						switch(type2._hx_index) {
						case 0:
							break;
						case 1:
							mustIndent = true;
							break;
						case 2:
							break;
						case 3:
							mustIndent = true;
							break;
						case 4:
							mustIndent = true;
							break;
						case 5:
							mustIndent = true;
							break;
						case 6:
							mustIndent = true;
							break;
						case 7:
							mustIndent = true;
							break;
						case 8:
							break;
						case 9:
							break;
						}
						break;
					default:
					}
					break;
				case 15:case 16:
					if(!this.config.indentCaseLabels) {
						continue;
					}
					break;
				case 21:
					var _g5 = currentToken.tok;
					if(_g5._hx_index == 1 && _g5.k._hx_index == 20) {
						continue;
					}
					break;
				default:
				}
				break;
			case 2:
				var _g6 = _g1.c;
				if(_g6._hx_index == 3) {
					switch(_g6.s) {
					case "from":case "to":
						if(this.isAbstractFromTo(token) && this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							mustIndent = true;
						}
						break;
					default:
					}
				}
				break;
			case 11:
				var _g7 = currentToken.tok;
				switch(_g7._hx_index) {
				case 1:
					switch(_g7.k._hx_index) {
					case 10:case 22:case 28:
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							continue;
						}
						break;
					case 15:case 16:
						continue;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 6:
					var _g8 = _g7.op;
					switch(_g8._hx_index) {
					case 4:
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken1 = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken1 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken1.token)) firstToken1 = this.parsedCode.tokenList.getPreviousToken(firstToken1.token);
							return count + this.calcIndent(firstToken1.token);
						}
						break;
					case 20:
						var _g9 = _g8.op;
						if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken2 = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken2 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken2.token)) firstToken2 = this.parsedCode.tokenList.getPreviousToken(firstToken2.token);
							return count + this.calcIndent(firstToken2.token);
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 11:
					if(!(prevToken.pos.min == currentToken.pos.min && this.parsedCode.tokenList.isNewLineBefore(currentToken))) {
						continue;
					}
					break;
				case 15:case 17:case 19:
					if(this.parsedCode.tokenList.isSameLine(currentToken,prevToken)) {
						continue;
					}
					mustIndent = true;
					break;
				default:
					if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						++count;
						continue;
					}
				}
				break;
			case 12:
				var _g10 = currentToken.tok;
				if(_g10._hx_index == 1) {
					switch(_g10.k._hx_index) {
					case 15:case 16:
						if(lastIndentingToken != null && lastIndentingToken.pos.min == prevToken.pos.min) {
							continue;
						}
						mustIndent = true;
						break;
					default:
					}
				}
				break;
			case 13:case 15:
				if(currentToken.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
						continue;
					}
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						var firstToken3 = this.parsedCode.tokenList.getPreviousToken(prevToken);
						while(firstToken3 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken3.token)) firstToken3 = this.parsedCode.tokenList.getPreviousToken(firstToken3.token);
						var brOpen3 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(brOpen3 != null) {
							if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,brOpen3,false)) {
								continue;
							}
						}
						return count + this.calcIndent(firstToken3.token);
					}
				}
				break;
			case 17:
				var _g11 = currentToken.tok;
				switch(_g11._hx_index) {
				case 1:
					switch(_g11.k._hx_index) {
					case 0:case 3:case 4:case 5:case 6:case 7:case 10:case 14:case 20:case 21:case 28:case 39:
						var type3 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						if(type3._hx_index == 2) {
							var brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
						} else {
							continue;
						}
						break;
					default:
					}
					break;
				case 6:
					var _g12 = _g11.op;
					switch(_g12._hx_index) {
					case 4:
						var type4 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type4._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose1 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose1 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose1) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					case 20:
						var _g13 = _g12.op;
						var type5 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type5._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose2 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose2 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose2) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					default:
					}
					break;
				case 12:
					var type6 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
					switch(type6._hx_index) {
					case 1:
						continue;
					case 2:
						var brClose3 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose3 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose3) && !this.config.indentObjectLiteral) {
							continue;
						}
						break;
					default:
					}
					break;
				case 13:
					var type7 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
					if(type7._hx_index == 2) {
						var brClose4 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose4 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose4) && !this.config.indentObjectLiteral) {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 15:case 19:
					var tmp = !this.parsedCode.tokenList.isNewLineBefore(prevToken);
					break;
				default:
				}
				break;
			default:
			}
			if(!mustIndent && this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
				continue;
			}
			skipToToken = this.findSkippingToken(currentToken);
			if(!this.isIndentingToken(currentToken,prevToken)) {
				continue;
			}
			lastIndentingToken = currentToken;
			++count;
		}
		return count;
	}
	,findSkippingToken: function(token) {
		var firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		var skipToToken = null;
		switch(firstToken.tok._hx_index) {
		case 16:case 18:case 20:
			skipToToken = this.findSkippingToken(firstToken.parent);
			if(skipToToken == null) {
				skipToToken = firstToken.parent;
			}
			return skipToToken;
		default:
			return null;
		}
	}
	,isFieldLevelVar: function(indentingTokensCandidates) {
		var tokens = indentingTokensCandidates.slice();
		tokens.reverse();
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					return false;
				case 2:
					return true;
				case 41:
					break;
				default:
				}
				break;
			case 6:
				if(_g1.op._hx_index == 4) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,calcFromCandidates: function(token) {
		var indentingTokensCandidates = this.findIndentingCandidates(token);
		if(indentingTokensCandidates.length <= 0) {
			return 0;
		}
		var indentComplexValueExpressions = this.config.indentComplexValueExpressions;
		if(this.isFieldLevelVar(indentingTokensCandidates)) {
			indentComplexValueExpressions = true;
		}
		if(indentComplexValueExpressions) {
			indentingTokensCandidates = this.compressElseIfCandidates(indentingTokensCandidates);
		}
		var count = this.countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions);
		if(this.hasConditional(indentingTokensCandidates)) {
			switch(this.config.conditionalPolicy) {
			case "aligned":
				break;
			case "alignedDecrease":
				--count;
				break;
			case "alignedIncrease":
				break;
			case "alignedNestedIncrease":
				count += this.calcConsecutiveConditionalLevel(token);
				break;
			case "fixedZero":
				break;
			case "fixedZeroIncrease":
				--count;
				var conditionalLevel = this.calcConditionalLevel(token);
				if(conditionalLevel == count) {
					++count;
				}
				break;
			case "fixedZeroIncreaseBlocks":
				if(this.hasBlock(indentingTokensCandidates)) {
					--count;
					var conditionalLevel = this.calcConditionalLevel(token);
					if(conditionalLevel == count) {
						++count;
					}
				}
				break;
			}
		}
		return count;
	}
	,hasConditional: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					return true;
				}
			}
		}
		return false;
	}
	,hasBlock: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(token.tok._hx_index == 17) {
				return true;
			}
		}
		return false;
	}
	,hasBlockParent: function(token) {
		var parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) if(parent.tok._hx_index == 17) {
			return true;
		} else {
			parent = parent.parent;
		}
		return false;
	}
	,findIndentingCandidates: function(token) {
		var indentingTokensCandidates = [];
		var lastIndentingToken = null;
		if(token.tok._hx_index == 11) {
			lastIndentingToken = token;
		}
		indentingTokensCandidates.push(token);
		var parent = token;
		while(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			if(parent.pos.min > token.pos.min) {
				continue;
			}
			if(this.isIndentingToken(parent,parent)) {
				if(lastIndentingToken != null) {
					if(lastIndentingToken.tok._hx_index == 11 && parent.tok._hx_index == 11) {
						continue;
					}
				}
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			} else if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			}
		}
		return indentingTokensCandidates;
	}
	,compressElseIfCandidates: function(indentingTokensCandidates) {
		var compressedCandidates = [];
		var state = formatter_marker_IndentationCompressElseIf.Copy;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 3:
					switch(state._hx_index) {
					case 0:
						if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)) != null) {
							state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						}
						break;
					case 1:
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						break;
					case 2:
						continue;
					}
					break;
				case 4:
					if(state == formatter_marker_IndentationCompressElseIf.SeenElse || state == formatter_marker_IndentationCompressElseIf.SkipElseIf) {
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						continue;
					}
					state = formatter_marker_IndentationCompressElseIf.SeenElse;
					break;
				default:
					state = formatter_marker_IndentationCompressElseIf.Copy;
				}
			} else {
				state = formatter_marker_IndentationCompressElseIf.Copy;
			}
			compressedCandidates.push(token);
		}
		return compressedCandidates;
	}
	,isIndentingToken: function(token,prevToken) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 2:
				return true;
			case 3:case 4:
				return true;
			case 5:
				var parent = token.parent;
				var tmp;
				if(parent != null) {
					var _g1 = parent.tok;
					tmp = _g1._hx_index == 1 && _g1.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				}
				return true;
			case 6:case 7:
				return true;
			case 10:case 28:
				return true;
			case 14:case 15:case 16:
				return true;
			case 20:case 21:case 24:
				return true;
			case 22:
				var _g1 = token.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 0) {
						return false;
					} else {
						return true;
					}
				} else {
					return true;
				}
				break;
			case 39:
				return true;
			default:
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					return this.isAbstractFromTo(token);
				default:
					if(prevToken.tok._hx_index == 11) {
						return true;
					}
				}
			}
			break;
		case 3:
			if(_g.s == "if") {
				switch(this.config.conditionalPolicy) {
				case "aligned":
					return false;
				case "alignedDecrease":case "alignedIncrease":
					return true;
				case "alignedNestedIncrease":
					return false;
				case "fixedZero":
					return false;
				case "fixedZeroIncrease":
					return true;
				case "fixedZeroIncreaseBlocks":
					return this.hasBlockParent(token);
				}
			}
			break;
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 4:
				return true;
			case 9:
				return tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token);
			case 20:
				var _g = _g1.op;
				return true;
			default:
			}
			break;
		case 11:case 15:case 17:case 19:
			return true;
		case 12:
			var tmp;
			var _g = token.parent.tok;
			if(!(_g._hx_index == 1 && _g.k._hx_index == 15)) {
				var _g = token.parent.tok;
				tmp = _g._hx_index == 1 && _g.k._hx_index == 16;
			} else {
				tmp = true;
			}
			if(tmp) {
				return true;
			}
			var info = this.parsedCode.tokenList.getTokenAt(token.index);
			if(info == null) {
				return false;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:case 1:
				return false;
			case 2:
				return true;
			}
			break;
		case 13:
			return true;
		default:
		}
		return false;
	}
	,isAbstractFromTo: function(token) {
		var parent = token.parent;
		if(parent == null) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g = _g1.s;
			} else {
				return false;
			}
		} else {
			return false;
		}
		parent = parent.parent;
		if(parent == null) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 39) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,__class__: formatter_marker_Indenter
};
var formatter_marker_IndentationCompressElseIf = $hxEnums["formatter.marker.IndentationCompressElseIf"] = { __ename__:"formatter.marker.IndentationCompressElseIf",__constructs__:null
	,Copy: {_hx_name:"Copy",_hx_index:0,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SeenElse: {_hx_name:"SeenElse",_hx_index:1,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SkipElseIf: {_hx_name:"SkipElseIf",_hx_index:2,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
};
formatter_marker_IndentationCompressElseIf.__constructs__ = [formatter_marker_IndentationCompressElseIf.Copy,formatter_marker_IndentationCompressElseIf.SeenElse,formatter_marker_IndentationCompressElseIf.SkipElseIf];
var formatter_marker_MarkerBase = function(config,parsedCode,indenter) {
	this.config = config;
	this.parsedCode = parsedCode;
	this.indenter = indenter;
};
$hxClasses["formatter.marker.MarkerBase"] = formatter_marker_MarkerBase;
formatter_marker_MarkerBase.__name__ = "formatter.marker.MarkerBase";
formatter_marker_MarkerBase.prototype = {
	getCloseToken: function(token) {
		return this.parsedCode.tokenList.getCloseToken(token);
	}
	,getNextToken: function(token) {
		return this.parsedCode.tokenList.getNextToken(token);
	}
	,getPreviousToken: function(token) {
		return this.parsedCode.tokenList.getPreviousToken(token);
	}
	,getTokenInfo: function(token) {
		return this.parsedCode.tokenList.getTokenAt(token.index);
	}
	,getTokenAt: function(index) {
		return this.parsedCode.tokenList.getTokenAt(index);
	}
	,whitespace: function(token,where) {
		this.parsedCode.tokenList.whitespace(token,where);
	}
	,spacesAfter: function(token,count) {
		this.parsedCode.tokenList.spacesAfter(token,count);
	}
	,spacesBefore: function(token,count) {
		this.parsedCode.tokenList.spacesBefore(token,count);
	}
	,lineEndAfter: function(token) {
		this.parsedCode.tokenList.lineEndAfter(token);
	}
	,lineEndBefore: function(token) {
		this.parsedCode.tokenList.lineEndBefore(token);
	}
	,noLineEndAfter: function(token) {
		this.parsedCode.tokenList.noLineEndAfter(token);
	}
	,noLineEndBefore: function(token) {
		this.parsedCode.tokenList.noLineEndBefore(token);
	}
	,emptyLinesAfter: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfter(token,count);
	}
	,emptyLinesBefore: function(token,count) {
		this.parsedCode.tokenList.emptyLinesBefore(token,count);
	}
	,emptyLinesAfterSubTree: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfterSubTree(token,count);
	}
	,tokenText: function(token,text) {
		this.parsedCode.tokenList.tokenText(token,text);
	}
	,wrapAfter: function(token,wrap) {
		this.parsedCode.tokenList.wrapAfter(token,wrap);
	}
	,wrapBefore: function(token,wrap) {
		this.parsedCode.tokenList.wrapBefore(token,wrap);
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		this.parsedCode.tokenList.noWrappingBetween(tokenStart,tokenEnd,this.config,allowCommas);
	}
	,additionalIndent: function(token,indent) {
		this.parsedCode.tokenList.additionalIndent(token,indent);
	}
	,increaseIndentBetween: function(start,end,depth) {
		this.parsedCode.tokenList.increaseIndentBetween(start,end,depth);
	}
	,findTokenAtOffset: function(offset) {
		return this.parsedCode.tokenList.findTokenAtOffset(offset);
	}
	,isSameLine: function(first,second) {
		return this.parsedCode.tokenList.isSameLine(first,second);
	}
	,calcLength: function(token) {
		return this.parsedCode.tokenList.calcLength(token);
	}
	,isMultilineToken: function(token) {
		return this.parsedCode.tokenList.isMultilineToken(token);
	}
	,calcLengthUntilNewline: function(token,stop) {
		return this.parsedCode.tokenList.calcLengthUntilNewline(token,stop);
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		return this.parsedCode.tokenList.calcLengthBetween(tokenStart,tokenEnd);
	}
	,calcLineLength: function(token) {
		return this.parsedCode.tokenList.calcLineLength(token);
	}
	,calcLineLengthBefore: function(token) {
		return this.parsedCode.tokenList.calcLineLengthBefore(token);
	}
	,calcLineLengthAfter: function(token) {
		return this.parsedCode.tokenList.calcLineLengthAfter(token);
	}
	,calcTokenLength: function(token) {
		return this.parsedCode.tokenList.calcTokenLength(token);
	}
	,isNewLineBefore: function(token) {
		return this.parsedCode.tokenList.isNewLineBefore(token);
	}
	,isNewLineAfter: function(token) {
		return this.parsedCode.tokenList.isNewLineAfter(token);
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		return this.parsedCode.tokenList.isSameLineBetween(tokenStart,tokenEnd,exclude);
	}
	,findLineStartToken: function(token) {
		return this.parsedCode.tokenList.findLineStartToken(token);
	}
	,__class__: formatter_marker_MarkerBase
};
var formatter_marker_MarkAdditionalIndentation = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkAdditionalIndentation"] = formatter_marker_MarkAdditionalIndentation;
formatter_marker_MarkAdditionalIndentation.__name__ = "formatter.marker.MarkAdditionalIndentation";
formatter_marker_MarkAdditionalIndentation.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkAdditionalIndentation.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceLeftCurly(token));
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceRightCurly(token));
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markBlockBreakingConditional: function(token,depthDifference) {
		if(token.children == null) {
			return;
		}
		var start = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Sharp("end"));
		if(start == null) {
			return;
		}
		if(depthDifference == 0) {
			return;
		}
		if(depthDifference < 0) {
			start = token;
		}
		var parent = token.parent;
		var topLevelToken = null;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			topLevelToken = parent;
			parent = parent.parent;
		}
		if(topLevelToken == null) {
			return;
		}
		var sibling = topLevelToken.nextSibling;
		while(sibling != null) if(sibling.tok._hx_index == 18) {
			this.increaseIndentBetween(start,sibling,depthDifference);
			return;
		} else {
			sibling = sibling.nextSibling;
		}
		this.increaseIndentBetween(start,tokentree_utils_TokenTreeCheckUtils.getLastToken(topLevelToken),depthDifference);
	}
	,calcDepthDifferenceLeftCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthIncrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var brOpens = child.filterCallback(function(token,index) {
				var _g = token.tok;
				switch(_g._hx_index) {
				case 3:
					var _g1 = _g.s;
					return tokentree_FilterResult.SkipSubtree;
				case 17:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brOpens.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g2 = 0;
			while(_g2 < brOpens.length) {
				var brOpen = brOpens[_g2];
				++_g2;
				if(tokentree_TokenTreeAccessHelper.firstOf(brOpen,tokentree_TokenTreeDef.BrClose) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthIncrease) {
				depthIncrease = depth;
			}
		}
		return depthIncrease;
	}
	,calcDepthDifferenceRightCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthDecrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var brClose = child.filterCallback(function(token,index) {
				if(token.tok._hx_index == 18) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brClose.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g2 = 0;
			while(_g2 < brClose.length) {
				var brClose1 = brClose[_g2];
				++_g2;
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(brClose1),tokentree_TokenTreeDef.BrOpen) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthDecrease) {
				depthDecrease = depth;
			}
		}
		return -depthDecrease;
	}
	,__class__: formatter_marker_MarkAdditionalIndentation
});
var formatter_marker_MarkEmptyLines = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkEmptyLines"] = formatter_marker_MarkEmptyLines;
formatter_marker_MarkEmptyLines.__name__ = "formatter.marker.MarkEmptyLines";
formatter_marker_MarkEmptyLines.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkEmptyLines.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		this.keepExistingEmptyLines();
		var packs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 33) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		packs.reverse();
		var _g = 0;
		while(_g < packs.length) {
			var pack = packs[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isMetadata(pack)) {
				continue;
			}
			this.emptyLinesBefore(pack,this.config.emptyLines.beforePackage);
			this.emptyLinesAfter(pack,this.config.emptyLines.afterPackage);
		}
		this.betweenTypes();
		this.markImports();
		this.markClassesAndAbstracts();
		this.markMacroClasses();
		this.markInterfaces();
		this.markEnums();
		this.markTypedefs();
		this.markSharp();
		if(this.config.emptyLines.beforeDocCommentEmptyLines != "ignore" || this.config.emptyLines.afterFieldsWithDocComments != "ignore") {
			this.markDocComments();
		}
		this.markMultilineComments();
		this.markFileHeader();
		if(this.config.emptyLines.beforeRightCurly == "remove") {
			this.markRightCurly();
		}
		if(this.config.emptyLines.afterLeftCurly == "remove") {
			this.markLeftCurly();
		}
		if(this.config.emptyLines.afterReturn == "remove") {
			this.markReturn();
		}
		if(this.config.emptyLines.beforeBlocks == "remove" || this.config.emptyLines.afterBlocks == "remove") {
			this.markAroundBlocks();
		}
	}
	,finalRun: function(codeLines) {
		if(codeLines.lines.length <= 0) {
			return;
		}
		var _g = 0;
		var _g1 = codeLines.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			if(line.verbatim) {
				continue;
			}
			if(line.emptyLinesAfter > this.config.emptyLines.maxAnywhereInFile) {
				line.emptyLinesAfter = this.config.emptyLines.maxAnywhereInFile;
			}
		}
		var lastLine = codeLines.lines[codeLines.lines.length - 1];
		if(lastLine.verbatim) {
			return;
		}
		lastLine.emptyLinesAfter = this.config.emptyLines.finalNewline ? 1 : 0;
	}
	,markImports: function() {
		var imports = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 35:
					if(tokentree_utils_TokenTreeCheckUtils.isMetadata(token)) {
						return tokentree_FilterResult.SkipSubtree;
					} else {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		var lastImport = imports[imports.length - 1];
		var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(lastImport);
		var afterImport = this.getNextToken(lastChild);
		if(afterImport != null) {
			var _g = afterImport.token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":
					break;
				case "end":
					this.emptyLinesAfterSubTree(afterImport.token,this.config.emptyLines.importAndUsing.beforeType);
					break;
				default:
					this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
				}
			} else {
				this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
			}
		}
		lastImport = null;
		var prevInfo = null;
		var _g = 0;
		while(_g < imports.length) {
			var token = imports[_g];
			++_g;
			var newInfo = this.getImportInfo(token);
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			var next = this.getNextToken(lastToken);
			if(next != null) {
				var _g1 = next.token.tok;
				if(_g1._hx_index == 3) {
					if(_g1.s == "end") {
						newInfo.token = next.token;
					}
				}
			}
			if(prevInfo == null) {
				prevInfo = newInfo;
				continue;
			}
			if(prevInfo.isImport == newInfo.isImport) {
				switch(this.config.emptyLines.importAndUsing.betweenImportsLevel) {
				case "all":
					this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					break;
				case "fifthLevelPackage":
					if(prevInfo.fifthLevelPackage != newInfo.fifthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "firstLevelPackage":
					if(prevInfo.firstLevelPackage != newInfo.firstLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fourthLevelPackage":
					if(prevInfo.fourthLevelPackage != newInfo.fourthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fullPackage":
					if(prevInfo.fullPackage != newInfo.fullPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "secondLevelPackage":
					if(prevInfo.secondLevelPackage != newInfo.secondLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "thirdLevelPackage":
					if(prevInfo.thirdLevelPackage != newInfo.thirdLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				}
			} else {
				this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.beforeUsing);
			}
			prevInfo = newInfo;
		}
	}
	,getImportInfo: function(token) {
		var info = { token : token, isImport : false, firstLevelPackage : "", secondLevelPackage : "", thirdLevelPackage : "", fourthLevelPackage : "", fifthLevelPackage : "", fullPackage : "", moduleName : ""};
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 13:
				info.isImport = true;
				break;
			case 35:
				info.isImport = false;
				break;
			default:
			}
		}
		var parts = [];
		token = token.getFirstChild();
		while(true) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.k;
				parts.push("" + Std.string(token));
				break;
			case 2:
				var _g2 = _g.c;
				if(_g2._hx_index == 3) {
					var text = _g2.s;
					parts.push(text);
				}
				break;
			default:
			}
			token = token.getFirstChild();
			if(token == null || token.tok._hx_index != 11) {
				break;
			}
			token = token.getFirstChild();
			if(token == null) {
				break;
			}
		}
		info.moduleName = parts.pop();
		info.fullPackage = parts.join(".");
		if(parts.length > 0) {
			info.firstLevelPackage = parts[0];
		}
		if(parts.length > 1) {
			info.secondLevelPackage = parts.slice(0,2).join(".");
		} else {
			info.secondLevelPackage = info.firstLevelPackage;
		}
		if(parts.length > 2) {
			info.thirdLevelPackage = parts.slice(0,3).join(".");
		} else {
			info.thirdLevelPackage = info.secondLevelPackage;
		}
		if(parts.length > 3) {
			info.fourthLevelPackage = parts.slice(0,4).join(".");
		} else {
			info.fourthLevelPackage = info.thirdLevelPackage;
		}
		if(parts.length > 4) {
			info.fifthLevelPackage = parts.slice(0,5).join(".");
		} else {
			info.fifthLevelPackage = info.fourthLevelPackage;
		}
		return info;
	}
	,markClassesAndAbstracts: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classes.length) {
			var c = classes[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(c)) {
				this.markEnumAbstracts(c);
				continue;
			}
			var typeConfig = null;
			var _g1 = c.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 1:
					typeConfig = this.config.emptyLines.classEmptyLines;
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtern)) != null) {
						this.markExternClass(c,this.config.emptyLines.externClassEmptyLines);
						continue;
					}
					break;
				case 39:
					typeConfig = this.config.emptyLines.abstractEmptyLines;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
			var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			var fields = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currToken = null;
			var currTokenType = null;
			var _g2 = 0;
			while(_g2 < fields.length) {
				var field = fields[_g2];
				++_g2;
				currToken = field;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	,markMacroClasses: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
						return tokentree_FilterResult.GoDeeper;
					}
					var _g = token.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 40) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classes.length) {
			var c = classes[_g];
			++_g;
			var typeConfig = this.config.emptyLines.macroClassEmptyLines;
			var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			var functions = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currToken = null;
			var currTokenType = null;
			var _g1 = 0;
			while(_g1 < functions.length) {
				var func = functions[_g1];
				++_g1;
				currToken = func;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	,findClassAndAbstractFields: function(c) {
		return c.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 22:
				return tokentree_FilterResult.SkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,markBeginAndEndType: function(brOpen,beginType,endType) {
		if(brOpen == null) {
			return;
		}
		this.emptyLinesAfter(brOpen,beginType);
		var brClose = this.getCloseToken(brOpen);
		if(brClose == null) {
			return;
		}
		this.emptyLinesBefore(brClose,endType);
	}
	,markClassFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		var prevStatic = false;
		var currStatic = false;
		var prevPrivate = false;
		var currPrivate = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var isInline = prevTokenType.isInline;
			var isOverride = prevTokenType.isOverride;
			var isFinal = prevTokenType.isFinal;
			var isExtern = prevTokenType.isExtern;
			prevVar = false;
			prevStatic = isStatic;
			prevPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var isInline = prevTokenType.isInline;
			var isFinal = prevTokenType.isFinal;
			var isExtern = prevTokenType.isExtern;
			prevVar = true;
			prevStatic = isStatic;
			prevPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var getter = prevTokenType.getter;
			var setter = prevTokenType.setter;
			prevVar = true;
			prevStatic = isStatic;
			prevPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var isInline = currTokenType.isInline;
			var isOverride = currTokenType.isOverride;
			var isFinal = currTokenType.isFinal;
			var isExtern = currTokenType.isExtern;
			currVar = false;
			currStatic = isStatic;
			currPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var isInline = currTokenType.isInline;
			var isFinal = currTokenType.isFinal;
			var isExtern = currTokenType.isExtern;
			currVar = true;
			currStatic = isStatic;
			currPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var getter = currTokenType.getter;
			var setter = currTokenType.setter;
			currVar = true;
			currStatic = isStatic;
			currPrivate = visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		if(!currVar) {
			this.markLineCommentsBefore(currToken,this.config.emptyLines.lineCommentsBetweenFunctions);
			this.markLineCommentsAfter(currToken,1);
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticVars);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticVars);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateVars);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticFunctions);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticFunctions);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateFunctions);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,hasEmptyLinesBetweenFields: function(prevToken,currToken) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prevToken);
		if(lastToken == null) {
			return false;
		}
		var prevLine = this.parsedCode.getLinePos(lastToken.pos.max).line;
		var currLine = this.parsedCode.getLinePos(currToken.pos.min).line;
		var _g = 0;
		var _g1 = this.parsedCode.emptyLines;
		while(_g < _g1.length) {
			var emptyLine = _g1[_g];
			++_g;
			if(prevLine >= emptyLine) {
				continue;
			}
			if(currLine > emptyLine) {
				return true;
			}
			return false;
		}
		return false;
	}
	,markLineCommentsBefore: function(token,policy) {
		if(policy == "none") {
			return;
		}
		if(token.previousSibling == null) {
			return;
		}
		var prev = token.previousSibling;
		while(prev != null) {
			var _g = prev.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				break;
			case 8:
				var _g2 = _g.s;
				var prevInfo = this.getPreviousToken(prev);
				if(prevInfo == null || prevInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					switch(policy) {
					case "keep":
						if(this.parsedCode.linesBetweenOriginal(prev,token) > 1) {
							this.emptyLinesAfter(prev,1);
						}
						break;
					case "none":
						break;
					case "one":
						this.emptyLinesAfter(prev,1);
						break;
					}
				}
				return;
			default:
				return;
			}
			prev = prev.previousSibling;
		}
	}
	,markLineCommentsAfter: function(token,count) {
		if(count <= 0) {
			return;
		}
		if(token.nextSibling == null) {
			return;
		}
		var next = token.nextSibling;
		var _g = next.tok;
		if(_g._hx_index == 8) {
			var _g1 = _g.s;
			if(this.isNewLineBefore(next)) {
				this.emptyLinesBefore(next,count);
			}
		}
	}
	,markExternClass: function(c,conf) {
		var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
		if(block == null) {
			return;
		}
		this.markBeginAndEndType(block,conf.beginType,conf.endType);
		var fields = this.findClassAndAbstractFields(block);
		var prevToken = null;
		var prevTokenType = null;
		var currToken = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			currToken = field;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Public);
			this.markInterfaceEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	,markInterfaces: function() {
		var interfaces = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 27) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < interfaces.length) {
			var i = interfaces[_g];
			++_g;
			this.markExternClass(i,this.config.emptyLines.interfaceEmptyLines);
		}
	}
	,markInterfaceEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var _g = prevTokenType.visibility;
			var _g = prevTokenType.isStatic;
			var _g = prevTokenType.isInline;
			var _g = prevTokenType.isOverride;
			var _g = prevTokenType.isFinal;
			var _g = prevTokenType.isExtern;
			var name = prevTokenType.name;
			prevVar = false;
			break;
		case 1:
			var _g = prevTokenType.visibility;
			var _g = prevTokenType.isStatic;
			var _g = prevTokenType.isInline;
			var _g = prevTokenType.isFinal;
			var _g = prevTokenType.isExtern;
			var name = prevTokenType.name;
			prevVar = true;
			break;
		case 2:
			var _g = prevTokenType.visibility;
			var _g = prevTokenType.isStatic;
			var _g = prevTokenType.getter;
			var _g = prevTokenType.setter;
			var name = prevTokenType.name;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var _g = currTokenType.visibility;
			var _g = currTokenType.isStatic;
			var _g = currTokenType.isInline;
			var _g = currTokenType.isOverride;
			var _g = currTokenType.isFinal;
			var _g = currTokenType.isExtern;
			var name = currTokenType.name;
			currVar = false;
			break;
		case 1:
			var _g = currTokenType.visibility;
			var _g = currTokenType.isStatic;
			var _g = currTokenType.isInline;
			var _g = currTokenType.isFinal;
			var _g = currTokenType.isExtern;
			var name = currTokenType.name;
			currVar = true;
			break;
		case 2:
			var _g = currTokenType.visibility;
			var _g = currTokenType.isStatic;
			var _g = currTokenType.getter;
			var _g = currTokenType.setter;
			var name = currTokenType.name;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,markEnumAbstracts: function(token) {
		var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen);
		this.markBeginAndEndType(block,this.config.emptyLines.enumAbstractEmptyLines.beginType,this.config.emptyLines.enumAbstractEmptyLines.endType);
		var functions = this.findClassAndAbstractFields(token);
		var prevToken = null;
		var prevTokenType = null;
		var currToken = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < functions.length) {
			var func = functions[_g];
			++_g;
			currToken = func;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Public);
			this.markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	,markEnumAbstractFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var isInline = prevTokenType.isInline;
			var isOverride = prevTokenType.isOverride;
			var isFinal = prevTokenType.isFinal;
			var isExtern = prevTokenType.isExtern;
			prevVar = false;
			break;
		case 1:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var isInline = prevTokenType.isInline;
			var isFinal = prevTokenType.isFinal;
			var isExtern = prevTokenType.isExtern;
			prevVar = true;
			break;
		case 2:
			var name = prevTokenType.name;
			var visibility = prevTokenType.visibility;
			var isStatic = prevTokenType.isStatic;
			var getter = prevTokenType.getter;
			var setter = prevTokenType.setter;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var isInline = currTokenType.isInline;
			var isOverride = currTokenType.isOverride;
			var isFinal = currTokenType.isFinal;
			var isExtern = currTokenType.isExtern;
			currVar = false;
			break;
		case 1:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var isInline = currTokenType.isInline;
			var isFinal = currTokenType.isFinal;
			var isExtern = currTokenType.isExtern;
			currVar = true;
			break;
		case 2:
			var name = currTokenType.name;
			var visibility = currTokenType.visibility;
			var isStatic = currTokenType.isStatic;
			var getter = currTokenType.getter;
			var setter = currTokenType.setter;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenFunctions);
			return;
		}
	}
	,markEnums: function() {
		var enums = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 26) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < enums.length) {
			var e = enums[_g];
			++_g;
			if(e.parent.tok != tokentree_TokenTreeDef.Root) {
				var _g1 = e.parent.tok;
				switch(_g1._hx_index) {
				case 2:
					var _g2 = _g1.c;
					continue;
				case 12:case 22:
					continue;
				default:
				}
			}
			var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(e),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.enumEmptyLines);
		}
	}
	,markEnumFields: function(block,config) {
		this.markBeginAndEndType(block,config.beginType,config.endType);
		if(block.children == null || block.children.length <= 0) {
			return;
		}
		var prevToken = null;
		var _g = 0;
		var _g1 = block.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 7:
				var _g3 = _g2.s;
				continue;
			case 8:
				var _g4 = _g2.s;
				continue;
			case 18:
				return;
			default:
			}
			if(prevToken == null) {
				prevToken = child;
				continue;
			}
			if(config.existingBetweenFields == "keep") {
				if(this.hasEmptyLinesBetweenFields(prevToken,child)) {
					this.emptyLinesAfterSubTree(prevToken,1);
					return;
				}
			}
			this.emptyLinesAfterSubTree(prevToken,config.betweenFields);
			prevToken = child;
		}
	}
	,markTypedefs: function() {
		var typedefs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 31) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < typedefs.length) {
			var t = typedefs[_g];
			++_g;
			var block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(t),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.typedefEmptyLines);
		}
	}
	,skipSharpFields: function(prevToken) {
		var next = prevToken.nextSibling;
		if(next == null) {
			next = prevToken.parent;
			var _g = next.tok;
			if(_g._hx_index == 3) {
				var _g1 = _g.s;
				next = next.nextSibling;
			} else {
				return prevToken;
			}
		}
		var _g = next.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "end":
				return next;
			case "if":
				return prevToken;
			default:
				return null;
			}
		}
		return prevToken;
	}
	,betweenTypes: function() {
		if(this.config.emptyLines.betweenTypes <= 0 && this.config.emptyLines.betweenSingleLineTypes <= 0) {
			return;
		}
		var types = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(types.length <= 1) {
			return;
		}
		var prevTypeInfo = null;
		var _g = 0;
		while(_g < types.length) {
			var type = types[_g];
			++_g;
			var newTypeInfo = this.getTypeInfo(type);
			this.markLineCommentsBefore(type,this.config.emptyLines.lineCommentsBetweenTypes);
			this.markLineCommentsAfter(type,1);
			if(prevTypeInfo == null) {
				prevTypeInfo = newTypeInfo;
				continue;
			}
			var next = this.getNextToken(prevTypeInfo.lastToken);
			if(next != null) {
				var _g1 = next.token.tok;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "else":case "elseif":
						prevTypeInfo = newTypeInfo;
						continue;
					default:
					}
				}
			}
			var emptyLines = this.config.emptyLines.betweenTypes;
			if(prevTypeInfo.oneLine && newTypeInfo.oneLine) {
				emptyLines = this.config.emptyLines.betweenSingleLineTypes;
			}
			this.emptyLinesAfterSubTree(prevTypeInfo.lastToken,emptyLines);
			this.markLineCommentsAfter(prevTypeInfo.typeToken,1);
			prevTypeInfo = newTypeInfo;
		}
	}
	,getTypeInfo: function(token) {
		var info = { lastToken : tokentree_utils_TokenTreeCheckUtils.getLastToken(token), typeToken : token, oneLine : false};
		var start = this.parsedCode.tokenList.findLowestIndex(token);
		if(this.isSameLine(start,info.lastToken)) {
			info.oneLine = true;
		}
		while(true) {
			var next = this.getNextToken(info.lastToken);
			if(next == null) {
				break;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "end") {
					info.lastToken = next.token;
				} else {
					break;
				}
			} else {
				break;
			}
		}
		return info;
	}
	,markLeftCurly: function() {
		var brOpens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < brOpens.length) {
			var br = brOpens[_g];
			++_g;
			this.emptyLinesAfter(br,0);
		}
	}
	,markRightCurly: function() {
		var brCloses = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 18) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < brCloses.length) {
			var br = brCloses[_g];
			++_g;
			this.emptyLinesBefore(br,0);
		}
	}
	,markReturn: function() {
		var returns = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 10) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < returns.length) {
			var ret = returns[_g];
			++_g;
			if(this.isReturnBody(ret)) {
				continue;
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(ret);
			if(lastChild == null) {
				continue;
			}
			var next = this.getNextToken(lastChild);
			if(next == null) {
				continue;
			}
			if(next.token.tok._hx_index == 18) {
				this.emptyLinesAfterSubTree(ret,0);
			}
		}
	}
	,isReturnBody: function(ret) {
		var parent = ret.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 0) {
					return true;
				} else {
					parent = parent.parent;
				}
				break;
			case 17:
				return false;
			default:
				parent = parent.parent;
			}
		}
		return true;
	}
	,markSharp: function() {
		var sharps = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < sharps.length) {
			var sharp = sharps[_g];
			++_g;
			var prev = this.getPreviousToken(sharp);
			if(prev != null && prev.whitespaceAfter != formatter_codedata_WhitespaceAfterType.Newline) {
				continue;
			}
			var _g1 = sharp.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfter(sharp,this.config.emptyLines.conditionalsEmptyLines.afterElse);
					break;
				case "elseif":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				case "end":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeEnd);
					break;
				case "error":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeError);
					this.emptyLinesAfterSubTree(sharp,this.config.emptyLines.conditionalsEmptyLines.afterError);
					break;
				case "if":
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				default:
				}
			}
		}
	}
	,markDocComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 7) {
				var text = _g.s;
				if(StringTools.startsWith(text,"*")) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < comments.length) {
			var comment = comments[_g];
			++_g;
			var effectiveToken = null;
			effectiveToken = comment;
			if(comment.previousSibling != null) {
				if(comment.parent != null) {
					var _g1 = comment.parent.tok;
					if(_g1._hx_index == 3) {
						var _g2 = _g1.s;
						if(comment.parent.getFirstChild() == comment.previousSibling) {
							effectiveToken = comment.parent;
						}
					}
				}
			} else if(comment.parent == null || comment.parent.tok == tokentree_TokenTreeDef.Root) {
				continue;
			}
			if(comment.nextSibling == null) {
				continue;
			}
			var next = comment.nextSibling;
			var found = true;
			while(next != null) {
				var _g3 = next.tok;
				switch(_g3._hx_index) {
				case 1:
					switch(_g3.k._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 26:
						break;
					case 27:
						break;
					case 31:
						break;
					case 39:
						break;
					case 41:
						break;
					default:
						found = false;
					}
					break;
				case 2:
					var _g4 = _g3.c;
					if(_g4._hx_index == 3) {
						var _g5 = _g4.s;
					} else {
						found = false;
					}
					break;
				case 3:
					var _g6 = _g3.s;
					next = null;
					break;
				case 8:
					var _g7 = _g3.s;
					next = next.nextSibling;
					continue;
				default:
					found = false;
				}
				break;
			}
			if(!found) {
				continue;
			}
			switch(this.config.emptyLines.beforeDocCommentEmptyLines) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesBefore(effectiveToken,0);
				break;
			case "one":
				this.emptyLinesBefore(effectiveToken,1);
				break;
			}
			if(next == null) {
				continue;
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(next);
			var nextInfo = this.getNextToken(lastToken);
			if(nextInfo == null) {
				continue;
			}
			var _g8 = nextInfo.token.tok;
			if(_g8._hx_index == 3) {
				switch(_g8.s) {
				case "end":
					lastToken = nextInfo.token;
					break;
				case "error":
					break;
				case "if":
					break;
				default:
					continue;
				}
			}
			switch(this.config.emptyLines.afterFieldsWithDocComments) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesAfter(lastToken,0);
				break;
			case "one":
				this.emptyLinesAfter(lastToken,1);
				break;
			}
		}
	}
	,markMultilineComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 7) {
				var text = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < comments.length) {
			var comment = comments[_g];
			++_g;
			var sibling = comment.nextSibling;
			if(sibling == null) {
				continue;
			}
			if(!this.isNewLineAfter(comment)) {
				continue;
			}
			var _g1 = sibling.tok;
			if(_g1._hx_index == 7) {
				var s = _g1.s;
				this.emptyLinesAfter(comment,this.config.emptyLines.betweenMultilineComments);
			} else {
				continue;
			}
		}
	}
	,markAroundBlocks: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					break;
				case 3:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					var block = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)));
					if(block != null) {
						_gthis.removeEmptyLinesAroundBlock(block,"keep",_gthis.config.emptyLines.afterBlocks);
					}
					break;
				case 4:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 5:
					var tmp;
					if(token.parent != null) {
						var _g = token.parent.tok;
						tmp = !(_g._hx_index == 1 && _g.k._hx_index == 6);
					} else {
						tmp = true;
					}
					if(tmp) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 6:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					var block = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 7:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 15:case 16:
					var block = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot));
					_gthis.removeEmptyLinesAroundBlock(block,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 20:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					var block = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 21:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,removeEmptyLinesAroundBlock: function(block,before,after) {
		if(block == null) {
			return;
		}
		if(before == "remove") {
			var prev = this.getPreviousToken(block);
			if(prev != null) {
				this.emptyLinesAfter(prev.token,0);
			}
		}
		if(after == "remove") {
			this.emptyLinesAfterSubTree(block,0);
		}
	}
	,keepExistingEmptyLines: function() {
		var funcs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < funcs.length) {
			var func = funcs[_g];
			++_g;
			var block = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			if(block == null) {
				block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			}
			if(block == null) {
				continue;
			}
			var fullPos = block.getPos();
			var startLine = this.parsedCode.getLinePos(fullPos.min).line;
			var endLine = this.parsedCode.getLinePos(fullPos.max).line;
			var _g1 = 0;
			var _g2 = this.parsedCode.emptyLines;
			while(_g1 < _g2.length) {
				var emptyLine = _g2[_g1];
				++_g1;
				if(startLine >= emptyLine || endLine <= emptyLine) {
					continue;
				}
				var idx = this.parsedCode.linesIdx[emptyLine];
				var tokenInf = this.findTokenAtOffset(idx.l);
				if(tokenInf == null) {
					continue;
				}
				if(tokentree_utils_TokenTreeCheckUtils.isMetadata(tokenInf.token)) {
					continue;
				}
				tokenInf.emptyLinesAfter++;
			}
		}
	}
	,markFileHeader: function() {
		var info = this.getTokenAt(0);
		var info2 = this.getTokenAt(1);
		var packagesAndImports = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 33:case 35:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(info == null) {
			return;
		}
		var _g = info.token.tok;
		if(_g._hx_index == 7) {
			var s = _g.s;
			if(packagesAndImports.length == 0) {
				var _g = info2.token.tok;
				if(_g._hx_index == 7) {
					var s = _g.s;
				} else {
					return;
				}
			}
			info.emptyLinesAfter = this.config.emptyLines.afterFileHeaderComment;
		}
	}
	,__class__: formatter_marker_MarkEmptyLines
});
var formatter_marker_MarkLineEnds = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkLineEnds"] = formatter_marker_MarkLineEnds;
formatter_marker_MarkLineEnds.__name__ = "formatter.marker.MarkLineEnds";
formatter_marker_MarkLineEnds.outputLineSeparator = function(config,parsedCode) {
	var _g = config.lineEndCharacter;
	if(_g == null) {
		return parsedCode.lineSeparator;
	} else {
		switch(_g) {
		case "CR":
			return "\r";
		case "CRLF":
			return "\r\n";
		case "LF":
			return "\n";
		default:
			return parsedCode.lineSeparator;
		}
	}
};
formatter_marker_MarkLineEnds.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkLineEnds.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var semicolonTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 10) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < semicolonTokens.length) {
			var token = semicolonTokens[_g];
			++_g;
			this.lineEndAfter(token);
		}
		this.markBrOpenClose();
		this.markAt();
		this.markDblDot();
		this.markSharp();
		this.markComments();
		this.markStructureExtension();
	}
	,markComments: function() {
		var commentTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < commentTokens.length) {
			var token = commentTokens[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 7:
				var _g2 = _g1.s;
				var prev = this.getPreviousToken(token);
				var noneBefore = false;
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev.token)) {
						if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
							this.lineEndAfter(token);
						}
						this.noLineEndBefore(token);
						noneBefore = !this.isMultilineToken(token);
					}
				}
				var commentLine = this.parsedCode.getLinePos(token.pos.min);
				var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[commentLine.line].l,token.pos.min);
				commentLine = this.parsedCode.getLinePos(token.pos.max);
				var postfix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[commentLine.line].r);
				if(new EReg("^\\s*$","").match(prefix) && new EReg("^\\s*$","").match(postfix)) {
					this.lineEndAfter(token);
					continue;
				}
				var next = this.getNextToken(token);
				if(next == null) {
					continue;
				}
				if(this.parsedCode.isOriginalSameLine(token,next.token)) {
					this.noLineEndAfter(token);
				}
				var _g3 = next.token.tok;
				switch(_g3._hx_index) {
				case 1:
					var _g4 = _g3.k;
					if(!noneBefore) {
						this.lineEndAfter(token);
					}
					continue;
				case 2:
					var _g5 = _g3.c;
					if(_g5._hx_index == 3) {
						if(_g5.s == "final") {
							if(!noneBefore) {
								this.lineEndAfter(token);
							}
							continue;
						}
					}
					break;
				default:
				}
				break;
			case 8:
				var _g6 = _g1.s;
				var prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev1.token)) {
						this.noLineEndBefore(token);
					}
				}
				this.lineEndAfter(token);
				break;
			default:
			}
		}
	}
	,markBrOpenClose: function() {
		var brTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < brTokens.length) {
			var brOpen = brTokens[_g];
			++_g;
			var curlyPolicy = this.detectCurlyPolicy(brOpen);
			this.fixMissingSemicolonsInBlock(brOpen);
			var brClose = this.getCloseToken(brOpen);
			if(brClose == null) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
				continue;
			}
			var prev = this.getPreviousToken(brOpen);
			if(prev != null) {
				var _g1 = prev.token.tok;
				if(_g1._hx_index == 4) {
					switch(_g1.s) {
					case "":case "a":case "b":case "e":case "i":case "p":case "v":
						if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
							this.noLineEndAfter(brOpen);
							this.noLineEndBefore(brClose);
							this.whitespace(brOpen,"none");
							this.whitespace(brClose,"noneBefore");
							var next = this.getNextToken(brClose);
							if(next != null) {
								if(next.token.tok._hx_index == 12) {
									this.whitespace(brClose,"after");
								}
							}
							continue;
						}
						this.whitespace(brOpen,"noneBefore");
						break;
					default:
					}
				}
			}
			var next1 = this.getNextToken(brOpen);
			var isEmpty = false;
			var keepComment = false;
			if(next1 != null) {
				if(next1.token.tok._hx_index == 18) {
					if(curlyPolicy.emptyCurly == "noBreak") {
						isEmpty = true;
					}
				}
			}
			if(!isEmpty) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					if(!keepComment) {
						this.lineEndAfter(brOpen);
					}
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					if(!keepComment) {
						this.lineEndAfter(brOpen);
					}
					break;
				case "none":
					break;
				}
			}
			var preventBefore = isEmpty;
			var preventAfter = false;
			next1 = this.getNextToken(brClose);
			if(next1 != null) {
				if(next1.token.tok._hx_index == 12) {
					preventAfter = true;
				}
			}
			switch(curlyPolicy.rightCurly) {
			case "after":
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "before":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				break;
			case "both":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "none":
				break;
			}
		}
	}
	,fixMissingSemicolonsInBlock: function(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:case 2:case 3:case 4:
			return;
		}
		if(!token.hasChildren()) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 3:
				var _g3 = _g2.s;
				continue;
			case 18:
				return;
			default:
				var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastChild == null) {
					continue;
				}
				if(lastChild.tok._hx_index == 10) {
					continue;
				} else if(this.isMissingSemicolon(lastChild)) {
					this.lineEndAfter(lastChild);
				}
			}
		}
	}
	,isMissingSemicolon: function(token) {
		while(true) {
			var next = this.getNextToken(token);
			if(next == null) {
				return true;
			}
			token = next.token;
			switch(token.tok._hx_index) {
			case 10:
				return false;
			case 16:case 20:
				continue;
			default:
				return true;
			}
		}
	}
	,detectCurlyPolicy: function(brOpen) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
		var curlyPolicy = { leftCurly : this.config.lineEnds.leftCurly, rightCurly : this.config.lineEnds.rightCurly, emptyCurly : this.config.lineEnds.emptyCurly};
		switch(type._hx_index) {
		case 0:
			if(brOpen.parent != null && this.config.lineEnds.anonFunctionCurly != null) {
				var _g = brOpen.parent.tok;
				switch(_g._hx_index) {
				case 1:
					if(_g.k._hx_index == 0) {
						return this.config.lineEnds.anonFunctionCurly;
					}
					break;
				case 13:
					return this.config.lineEnds.anonFunctionCurly;
				default:
				}
			}
			if(this.config.lineEnds.blockCurly != null) {
				return this.config.lineEnds.blockCurly;
			}
			break;
		case 1:
			if(this.config.lineEnds.typedefCurly != null) {
				return this.config.lineEnds.typedefCurly;
			}
			break;
		case 2:
			if(this.config.lineEnds.objectLiteralCurly != null) {
				return this.config.lineEnds.objectLiteralCurly;
			}
			break;
		case 3:
			if(this.config.lineEnds.anonTypeCurly != null) {
				return this.config.lineEnds.anonTypeCurly;
			} else {
				var brClose = this.getCloseToken(brOpen);
				if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
					var _g = curlyPolicy.leftCurly;
					if(_g != null) {
						switch(_g) {
						case "before":
							curlyPolicy.leftCurly = "none";
							break;
						case "both":
							curlyPolicy.leftCurly = "after";
							break;
						default:
						}
					}
				}
			}
			break;
		case 4:
			break;
		}
		return curlyPolicy;
	}
	,beforeLeftCurly: function(token) {
		this.lineEndBefore(token);
	}
	,beforeRightCurly: function(token) {
		this.lineEndBefore(token);
	}
	,afterRightCurly: function(token) {
		var next = token.index + 1;
		if(this.parsedCode.tokenList.tokens.length <= next) {
			this.lineEndAfter(token);
			return;
		}
		var nextToken = this.getTokenAt(next);
		if(nextToken == null) {
			this.lineEndAfter(token);
			return;
		}
		var _g = nextToken.token.tok;
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s != "is") {
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				break;
			case 7:
				break;
			default:
				this.lineEndAfter(token);
			}
			break;
		case 10:
			break;
		case 11:
			break;
		case 13:
			break;
		case 14:
			break;
		case 17:
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(nextToken.token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				this.lineEndAfter(token);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			break;
		case 20:
			break;
		default:
			this.lineEndAfter(token);
		}
	}
	,markAt: function() {
		var _gthis = this;
		var atTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 22) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var addLineEndBefore = function(atToken) {
			var prev = _gthis.getPreviousToken(atToken);
			if(prev == null) {
				_gthis.lineEndBefore(atToken);
				return;
			}
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:case 41:
					_gthis.noLineEndBefore(atToken);
					break;
				case 4:
					_gthis.lineEndBefore(atToken);
					break;
				default:
				}
				break;
			case 17:
				_gthis.lineEndBefore(atToken);
				break;
			default:
			}
		};
		var _g = 0;
		while(_g < atTokens.length) {
			var token = atTokens[_g];
			++_g;
			var metadataPolicy = this.determineMetadataPolicy(token);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			var isNotFirst = token.previousSibling != null && token.previousSibling.tok._hx_index == 22;
			if(!isNotFirst) {
				addLineEndBefore(token);
			}
			if(metadataPolicy == "after") {
				this.lineEndAfter(lastChild);
				continue;
			}
			if(isNotFirst) {
				continue;
			}
			var next = token.nextSibling;
			var metadata = [token];
			while(next != null && next.tok._hx_index == 22) {
				metadata.push(next);
				next = next.nextSibling;
			}
			var _g1 = 0;
			while(_g1 < metadata.length) {
				var meta = metadata[_g1];
				++_g1;
				lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(meta);
				if(lastChild == null) {
					continue;
				}
				switch(metadataPolicy) {
				case "after":
					this.lineEndAfter(lastChild);
					break;
				case "afterLast":
					var next1 = this.getNextToken(lastChild);
					if(next1 != null && !this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				case "forceAfterLast":
					this.whitespace(lastChild,"after");
					break;
				case "none":
					var next2 = this.getNextToken(lastChild);
					if(next2 != null && !this.parsedCode.isOriginalSameLine(lastChild,next2.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				}
			}
			if(metadataPolicy == "afterLast" || metadataPolicy == "forceAfterLast") {
				this.lineEndAfter(lastChild);
			}
		}
	}
	,determineMetadataPolicy: function(token) {
		if(token == null) {
			return this.config.lineEnds.metadataOther;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return this.config.lineEnds.metadataType;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return this.config.lineEnds.metadataFunction;
			case 22:
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
				break;
			default:
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 3:
			var _g1 = _g.s;
			return "after";
		case 4:
			var _g1 = _g.s;
			if(parent.parent == null) {
				return this.config.lineEnds.metadataOther;
			}
			var _g = parent.parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					return this.config.lineEnds.metadataFunction;
				case 2:
					return this.config.lineEnds.metadataVar;
				case 1:case 26:case 27:case 31:case 39:
					return this.config.lineEnds.metadataType;
				default:
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		default:
			return this.config.lineEnds.metadataOther;
		}
	}
	,markDblDot: function() {
		var dblDotTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 12) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < dblDotTokens.length) {
			var token = dblDotTokens[_g];
			++_g;
			var tmp;
			var _g1 = token.parent.tok;
			if(!(_g1._hx_index == 1 && _g1.k._hx_index == 15)) {
				var _g2 = token.parent.tok;
				tmp = !(_g2._hx_index == 1 && _g2.k._hx_index == 16);
			} else {
				tmp = false;
			}
			if(tmp) {
				continue;
			}
			if(this.config.lineEnds.caseColon != "none") {
				this.lineEndAfter(token);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			this.lineEndAfter(lastChild);
		}
	}
	,markSharp: function() {
		var sharpTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":case "end":case "error":case "if":
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < sharpTokens.length) {
			var token = sharpTokens[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(token);
					break;
				case "end":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
					} else {
						this.lineEndBefore(token);
					}
					var next = this.getNextToken(token);
					if(next != null) {
						switch(next.token.tok._hx_index) {
						case 10:case 14:
							continue;
						default:
						}
					}
					if(!this.isOnlyWhitespaceAfterToken(token,true)) {
						continue;
					}
					this.lineEndAfter(token);
					break;
				case "error":
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild == null) {
						lastChild = token;
					}
					this.lineEndAfter(lastChild);
					break;
				case "elseif":case "if":
					var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild1 == null) {
						continue;
					}
					if(this.config.lineEnds.sharp == "none") {
						this.whitespace(lastChild1,"after");
						continue;
					}
					if(this.isInlineSharp(token)) {
						var _g2 = token.tok;
						if(_g2._hx_index == 3 && _g2.s == "if" && this.isOnlyWhitespaceBeforeToken(token)) {
							continue;
						}
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(lastChild1);
					break;
				default:
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
		}
	}
	,isInlineSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				return this.isInlineSharp(token.parent);
			case "elseif":
				return this.isInlineSharp(token.parent);
			case "end":
				return this.isInlineSharp(token.parent);
			case "if":
				var sharpEnd = token.getLastChild();
				if(sharpEnd == null) {
					return false;
				}
				var _g = sharpEnd.tok;
				switch(_g._hx_index) {
				case 3:
					if(_g.s == "end") {
						if(this.parsedCode.linesBetweenOriginal(token,sharpEnd) > 5) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 10:case 14:
					sharpEnd = sharpEnd.previousSibling;
					if(sharpEnd == null) {
						return false;
					}
					var _g = sharpEnd.tok;
					if(!(_g._hx_index == 3 && _g.s == "end")) {
						return false;
					}
					break;
				default:
					return false;
				}
				if(!this.isOnlyWhitespaceAfterToken(sharpEnd,true)) {
					return true;
				}
				if(!this.isOnlyWhitespaceBeforeToken(token)) {
					return true;
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return !this.isOnlyWhitespaceBeforeToken(token);
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return false;
				}
				var _g = prev.token.tok;
				switch(_g._hx_index) {
				case 7:
					var _g1 = _g.s;
					return false;
				case 8:
					var _g1 = _g.s;
					return false;
				case 10:
					return false;
				case 18:
					return false;
				case 20:
					if(this.parsedCode.isOriginalSameLine(prev.token,token)) {
						return true;
					}
					return false;
				default:
					return true;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,isOnlyWhitespaceBeforeToken: function(token) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.min);
		var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[tokenLine.line].l,token.pos.min);
		return new EReg("^\\s*$","").match(prefix);
	}
	,isOnlyWhitespaceAfterToken: function(token,allowLineComments) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.max);
		var prefix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[tokenLine.line].r);
		if(allowLineComments) {
			return new EReg("^\\s*(|//.*)$","").match(prefix);
		} else {
			return new EReg("^\\s*$","").match(prefix);
		}
	}
	,findTypedefBrOpen: function(token) {
		var assign = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		if(assign == null) {
			return null;
		}
		return tokentree_TokenTreeAccessHelper.firstOf(assign,tokentree_TokenTreeDef.BrOpen);
	}
	,markStructureExtension: function() {
		var typedefTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 31) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < typedefTokens.length) {
			var token = typedefTokens[_g];
			++_g;
			this.markAfterTypedef(token);
			var brOpen = this.findTypedefBrOpen(token);
			if(brOpen == null) {
				continue;
			}
			if(brOpen.children == null || brOpen.children.length <= 0) {
				continue;
			}
			var assignParent = brOpen.parent;
			if(assignParent.children.length > 1) {
				var _g1 = 0;
				var _g2 = assignParent.children;
				while(_g1 < _g2.length) {
					var child = _g2[_g1];
					++_g1;
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild == null) {
						continue;
					}
					var next = this.getNextToken(lastChild);
					if(next == null) {
						continue;
					}
					if(lastChild.tok._hx_index == 18) {
						var _g3 = next.token.tok;
						switch(_g3._hx_index) {
						case 6:
							if(_g3.op._hx_index == 11) {
								this.noLineEndAfter(lastChild);
								continue;
							}
							break;
						case 10:
							this.whitespace(lastChild,"noneAfter");
							continue;
						case 13:
							this.whitespace(lastChild,"none");
							continue;
						default:
						}
					}
					switch(next.token.tok._hx_index) {
					case 10:case 17:
						continue;
					default:
					}
					this.lineEndAfter(lastChild);
				}
			}
			var _g4 = 0;
			var _g5 = brOpen.children;
			while(_g4 < _g5.length) {
				var child1 = _g5[_g4];
				++_g4;
				var _g6 = child1.tok;
				switch(_g6._hx_index) {
				case 2:
					var _g7 = _g6.c;
					if(_g7._hx_index == 3) {
						var _g8 = _g7.s;
						var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
						if(lastChild1 == null) {
							continue;
						}
						this.lineEndAfter(lastChild1);
					}
					break;
				case 6:
					if(_g6.op._hx_index == 7) {
						var lastChild2 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
						if(lastChild2 == null) {
							continue;
						}
						this.lineEndAfter(lastChild2);
					}
					break;
				case 18:
					var next1 = this.getNextToken(child1);
					if(next1 == null) {
						continue;
					}
					var _g9 = next1.token.tok;
					if(_g9._hx_index == 6 && _g9.op._hx_index == 11) {
						this.noLineEndAfter(child1);
					}
					var _g10 = next1.token.tok;
					if(_g10._hx_index == 6 && _g10.op._hx_index == 7) {
						this.whitespace(child1,"noneAfter");
					}
					break;
				case 21:
					var lastChild3 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
					if(lastChild3 == null) {
						continue;
					}
					this.lineEndAfter(lastChild3);
					break;
				default:
				}
			}
		}
	}
	,markAfterTypedef: function(token) {
		var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastChild == null) {
			return;
		}
		var next = this.getNextToken(lastChild);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 8:
				var _g1 = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(next.token)) {
					return;
				}
				break;
			case 10:
				this.whitespace(lastChild,"noneAfter");
				return;
			default:
			}
		}
		this.lineEndAfter(lastChild);
	}
	,__class__: formatter_marker_MarkLineEnds
});
var formatter_marker_MarkSameLine = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkSameLine"] = formatter_marker_MarkSameLine;
formatter_marker_MarkSameLine.__name__ = "formatter.marker.MarkSameLine";
formatter_marker_MarkSameLine.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkSameLine.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.markDollarSameLine();
		this.parsedCode.root.filterCallback(function(token,index) {
			if(token.parent != null && token.parent.tok._hx_index == 22) {
				return tokentree_FilterResult.GoDeeper;
			}
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					_gthis.markFunction(token);
					break;
				case 3:
					_gthis.markIf(token);
					break;
				case 4:
					_gthis.markElse(token);
					break;
				case 5:
					var tmp;
					if(token.parent != null) {
						var _g = token.parent.tok;
						tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
					} else {
						tmp = false;
					}
					if(tmp) {
						return tokentree_FilterResult.GoDeeper;
					}
					_gthis.markWhile(token);
					break;
				case 6:
					_gthis.markDoWhile(token);
					break;
				case 7:
					_gthis.markFor(token);
					break;
				case 10:
					_gthis.markReturn(token);
					break;
				case 15:
					_gthis.markCase(token);
					break;
				case 16:
					_gthis.markCase(token);
					break;
				case 20:
					_gthis.markTry(token);
					break;
				case 21:
					_gthis.markCatch(token);
					break;
				case 28:
					_gthis.markUntyped(token);
					break;
				case 40:
					_gthis.markMacro(token);
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,isExpression: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 4:
				return this.shouldElseBeSameLine(parent);
			case 5:case 7:
				if(parent.parent.tok._hx_index == 15) {
					return true;
				}
				break;
			case 10:
				return true;
			case 28:
				return this.isExpression(parent);
			default:
			}
			break;
		case 6:
			var _g1 = _g.op;
			return true;
		case 12:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				return false;
			}
			if(lastChild.index != token.index) {
				return false;
			}
			return this.isReturnExpression(parent);
		case 13:
			return true;
		case 19:
			var pos = parent.getPos();
			if(pos.min < token.pos.min && pos.max > token.pos.max) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	,isReturnExpression: function(token) {
		var parent = token;
		while(parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return false;
				case 10:
					return true;
				default:
				}
				break;
			case 6:
				var _g1 = _g.op;
				return true;
			case 12:
				return true;
			case 13:
				return true;
			case 15:
				return false;
			case 17:
				var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
				switch(type._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					return true;
				case 3:
					break;
				case 4:
					break;
				}
				break;
			case 19:
				return true;
			default:
			}
		}
		return false;
	}
	,shouldIfBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 3)) {
			return false;
		}
		var body = this.getBodyAfterCondition(token);
		if(body == null) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldElseBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			return false;
		}
		return this.shouldIfBeSameLine(token.parent);
	}
	,shouldTryBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 20)) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldCatchBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 21)) {
			return false;
		}
		return this.shouldTryBeSameLine(token.parent);
	}
	,markIf: function(token) {
		if(this.shouldIfBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBodyAfterPOpen(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				return;
			case "next":
				break;
			case "same":
				this.markBodyAfterPOpen(token,"same",this.config.sameLine.expressionIfWithBlocks);
				return;
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.ifBody,false);
		var prev = this.getPreviousToken(token);
		var tmp;
		if(prev != null) {
			var _g = prev.token.tok;
			tmp = _g._hx_index == 1 && _g.k._hx_index == 4;
		} else {
			tmp = false;
		}
		if(tmp) {
			this.applySameLinePolicy(token,this.config.sameLine.elseIf);
		}
	}
	,markElse: function(token) {
		if(this.shouldElseBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBody(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				if(this.parsedCode.isOriginalNewlineBefore(token)) {
					this.lineEndBefore(token);
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.tok._hx_index == 18) {
					this.applySameLinePolicyChained(token,"keep","keep");
				}
				return;
			case "next":
				break;
			case "same":
				this.markBody(token,"same",this.config.sameLine.expressionIfWithBlocks);
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.tok._hx_index == 18) {
					this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,this.config.sameLine.ifElse);
				}
				return;
			}
		}
		this.markBody(token,this.config.sameLine.elseBody,false);
		var policy = this.config.sameLine.ifElse;
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			if(prev.token.tok._hx_index == 18) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(prev.token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf)) == null) {
					switch(policy) {
					case "keep":
						break;
					case "next":
						break;
					case "same":
						policy = "next";
						break;
					}
				}
			}
		}
		this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,policy);
	}
	,markTry: function(token) {
		if(this.shouldTryBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBody(token,"same",false);
			return;
		}
		this.markBody(token,this.config.sameLine.tryBody,false);
	}
	,markCatch: function(token) {
		if(this.shouldCatchBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBodyAfterPOpen(token,"same",false);
			this.applySameLinePolicy(token,this.config.sameLine.tryCatch);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.catchBody,false);
		this.applySameLinePolicyChained(token,this.config.sameLine.tryBody,this.config.sameLine.tryCatch);
	}
	,markCase: function(token) {
		if(token == null) {
			return;
		}
		var dblDot = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot);
		if(dblDot == null) {
			return;
		}
		if(this.isReturnExpression(token)) {
			this.markExpressionCase(token,dblDot);
			return;
		}
		if(dblDot.children == null || dblDot.children.length > 1) {
			return;
		}
		switch(this.config.sameLine.caseBody) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		var first = dblDot.getFirstChild();
		var last = tokentree_utils_TokenTreeCheckUtils.getLastToken(first);
		if(this.parsedCode.linesBetweenOriginal(first,last) > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	,markExpressionCase: function(token,dblDot) {
		if(dblDot.children == null) {
			return;
		}
		switch(this.config.sameLine.expressionCase) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		if(dblDot.children.length == 2) {
			var second = dblDot.children[1];
			var _g = second.tok;
			if(_g._hx_index == 8) {
				var _g1 = _g.s;
				var prev = this.getPreviousToken(second);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(dblDot,prev.token)) {
						return;
					}
				}
			} else {
				return;
			}
		}
		if(dblDot.children.length > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	,isArrayComprehension: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		while(parent != null) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 7:
					parent = parent.parent;
					break;
				default:
					return false;
				}
				break;
			case 15:
				return true;
			default:
				return false;
			}
		}
		return false;
	}
	,markFor: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 40) {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
				if(lastToken == null) {
					return;
				}
				if(this.parsedCode.isOriginalSameLine(token,lastToken)) {
					this.markBodyAfterPOpen(token,"same",false);
					return;
				}
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
	}
	,markWhile: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.whileBody,false);
	}
	,markArrayComprehension: function(token,bkOpen) {
		var bkClose = this.getCloseToken(bkOpen);
		switch(this.config.sameLine.comprehensionFor) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
			}
			this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
			if(bkClose != null && this.parsedCode.isOriginalNewlineBefore(bkClose)) {
				this.lineEndBefore(bkClose);
			}
			break;
		case "next":
			break;
		case "same":
			var origSame = false;
			if(bkClose != null) {
				origSame = this.parsedCode.isOriginalSameLine(bkOpen,bkClose);
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(bkOpen);
				if(lastToken != null) {
					origSame = this.parsedCode.isOriginalSameLine(bkOpen,lastToken);
				}
			}
			if(origSame) {
				this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
				if(bkClose != null) {
					this.whitespace(token,"noneBefore");
					this.whitespace(bkClose,"noneBefore");
				}
			} else {
				this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
			}
			break;
		}
	}
	,getBodyAfterCondition: function(token) {
		var pClose = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.POpen),tokentree_TokenTreeDef.PClose);
		if(pClose != null) {
			var next = this.getNextToken(pClose);
			if(next != null) {
				if(next.token.tok._hx_index != 12) {
					return next.token;
				}
			}
		}
		if(token.children == null) {
			return null;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 36:case 37:case 38:
					return child.nextSibling;
				default:
				}
				break;
			case 2:
				var _g3 = _g2.c;
				if(_g3._hx_index == 3) {
					var _g4 = _g3.s;
					return child.nextSibling;
				}
				break;
			case 17:
				return child;
			case 22:
				break;
			default:
			}
		}
		return null;
	}
	,markBodyAfterPOpen: function(token,policy,includeBrOpen) {
		var body = this.getBodyAfterCondition(token);
		_hx_loop1: while(body != null) {
			var _g = body.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "else":case "elseif":case "end":
					return;
				default:
					break _hx_loop1;
				}
				break;
			case 8:
				var _g1 = _g.s;
				var prev = this.getPreviousToken(body);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(body,prev.token)) {
						this.applySameLinePolicy(body,policy);
						return;
					}
				}
				body = body.nextSibling;
				break;
			case 17:
				var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
				switch(type._hx_index) {
				case 0:
					if(includeBrOpen) {
						this.markBlockBody(body,policy);
					}
					return;
				case 1:
					break;
				case 2:
					this.applySameLinePolicy(body,policy);
					break;
				case 3:
					break;
				case 4:
					break;
				}
				body = body.nextSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		if(body == null) {
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	,markBody: function(token,policy,includeBrOpen) {
		var body = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(body == null) {
			return;
		}
		if(body.tok._hx_index == 17) {
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
			switch(type._hx_index) {
			case 0:
				if(includeBrOpen) {
					this.markBlockBody(body,policy);
				}
				return;
			case 1:
				break;
			case 2:
				this.applySameLinePolicy(body,policy);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	,markBlockBody: function(token,policy) {
		if(token == null) {
			return;
		}
		if(token.tok._hx_index != 17) {
			return;
		}
		if(token.children == null) {
			return;
		}
		var lastChild = token.getLastChild();
		if(lastChild.tok._hx_index == 10) {
			if(token.children.length > 3) {
				return;
			}
		} else if(token.children.length > 2) {
			return;
		}
		this.noLineEndAfter(token);
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 18) {
				var next = this.getNextToken(child);
				var _g2 = next.token.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 4:
						this.noLineEndAfter(child);
						break;
					case 21:
						this.noLineEndAfter(child);
						break;
					default:
					}
					break;
				case 10:
					this.whitespace(child,"noneAfter");
					break;
				case 14:
					this.whitespace(child,"noneAfter");
					break;
				default:
				}
				return;
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastToken == null) {
					return;
				}
				this.noLineEndAfter(lastToken);
			}
		}
	}
	,applySameLinePolicyChained: function(token,previousBlockPolicy,policy) {
		if(policy == "same") {
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				policy = "next";
			}
			if(prev.token.tok._hx_index != 18 && previousBlockPolicy != "same") {
				policy = "next";
			}
		}
		this.applySameLinePolicy(token,policy);
	}
	,applySameLinePolicy: function(token,policy) {
		switch(policy) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.applySameLinePolicy(token,"next");
			} else {
				this.applySameLinePolicy(token,"same");
			}
			break;
		case "next":
			var _g = token.tok;
			switch(_g._hx_index) {
			case 8:
				var s = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(token)) {
					return;
				}
				break;
			case 15:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor)) != null) {
					return;
				}
				break;
			default:
			}
			var prev = this.getPreviousToken(token);
			if(prev == null || !tokentree_utils_TokenTreeCheckUtils.isMetadata(prev.token)) {
				this.lineEndBefore(token);
				return;
			}
			if(!this.parsedCode.isOriginalNewlineBefore(token)) {
				return;
			}
			this.lineEndBefore(token);
			break;
		case "same":
			this.wrapBefore(token,true);
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				this.noLineEndBefore(token);
			} else if(token.tok._hx_index == 22) {
				var _g = prev.token.tok;
				switch(_g._hx_index) {
				case 1:
					var _g1 = _g.k;
					break;
				case 3:
					var _g1 = _g.s;
					break;
				case 6:
					var _g1 = _g.op;
					this.lineEndBefore(token);
					break;
				case 10:case 12:case 17:case 18:
					break;
				case 11:case 19:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			} else {
				switch(prev.token.tok._hx_index) {
				case 11:case 19:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastToken == null) {
				return;
			}
			var next = this.getNextToken(lastToken);
			if(next == null) {
				return;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 4) {
					this.noLineEndAfter(lastToken);
				}
			}
			return;
		}
	}
	,markDollarSameLine: function() {
		var tokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 4) {
				switch(_g.s) {
				case "":case "a":case "b":case "e":case "i":case "p":case "v":
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			var brOpen = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen);
			if(brOpen == null) {
				continue;
			}
			var brClose = this.getCloseToken(brOpen);
			if(!this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
				continue;
			}
			this.whitespace(brOpen,"none");
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 10:case 11:case 14:
					this.whitespace(brClose,"none");
					break;
				case 12:case 15:case 16:case 18:case 19:case 20:
					break;
				default:
					this.whitespace(brClose,"onlyAfter");
				}
			} else {
				this.noLineEndAfter(brClose);
			}
			this.wrapBefore(brOpen,false);
			this.wrapAfter(brOpen,false);
			this.wrapBefore(brClose,false);
			this.wrapAfter(brClose,false);
		}
	}
	,markFunction: function(token) {
		var body = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token));
		if(body == null) {
			body = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		var policy = this.config.sameLine.functionBody;
		if(body == null) {
			body = token;
			policy = this.config.sameLine.anonFunctionBody;
		}
		if(body == null || body.children == null) {
			return;
		}
		body = tokentree_TokenTreeAccessHelper.firstOf(body,tokentree_TokenTreeDef.POpen);
		if(body == null) {
			return;
		}
		if(body.nextSibling == null) {
			return;
		}
		body = body.nextSibling;
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		if(body == null) {
			return;
		}
		var _g = body.tok;
		switch(_g._hx_index) {
		case 3:
			if(_g.s == "if") {
				return;
			}
			break;
		case 8:
			var _g1 = _g.s;
			return;
		case 10:
			return;
		case 17:
			return;
		default:
		}
		this.applySameLinePolicy(body,policy);
	}
	,markDoWhile: function(token) {
		this.markBody(token,this.config.sameLine.doWhileBody,false);
		var whileTok = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		if(whileTok == null) {
			return;
		}
		this.applySameLinePolicy(whileTok,this.config.sameLine.doWhile);
	}
	,markMacro: function(token) {
		var brOpen = this.getNextToken(token);
		if(brOpen == null || brOpen.token.tok._hx_index != 17) {
			return;
		}
		var brClose = this.getCloseToken(brOpen.token);
		if(this.parsedCode.isOriginalSameLine(brOpen.token,brClose)) {
			this.noLineEndAfter(brOpen.token);
			this.noLineEndBefore(brClose);
			this.noWrappingBetween(brOpen.token,brClose);
		}
	}
	,markReturn: function(token) {
		if(this.shouldReturnBeSameLine(token)) {
			this.markBody(token,this.config.sameLine.returnBodySingleLine,false);
		} else {
			this.markBody(token,this.config.sameLine.returnBody,false);
		}
	}
	,markUntyped: function(token) {
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen) == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || token.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.tok._hx_index == 17) {
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				return;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		this.applySameLinePolicy(token,this.config.sameLine.untypedBody);
	}
	,shouldReturnBeSameLine: function(token) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return true;
		}
		if(this.isSameLineBetween(token,lastToken,false)) {
			return true;
		}
		return this.shouldReturnChildsBeSameLine(token);
	}
	,shouldReturnChildsBeSameLine: function(token) {
		if(token.children == null) {
			return true;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 3:case 5:case 7:case 14:case 20:
					return false;
				default:
					var result = this.shouldReturnChildsBeSameLine(child);
					if(!result) {
						return false;
					}
				}
			} else {
				var result1 = this.shouldReturnChildsBeSameLine(child);
				if(!result1) {
					return false;
				}
			}
		}
		return true;
	}
	,__class__: formatter_marker_MarkSameLine
});
var formatter_marker_MarkTokenText = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkTokenText"] = formatter_marker_MarkTokenText;
formatter_marker_MarkTokenText.__name__ = "formatter.marker.MarkTokenText";
formatter_marker_MarkTokenText.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkTokenText.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				var _g1 = _g.c;
				switch(_g1._hx_index) {
				case 2:
					var _g2 = _g1.kind;
					var text = _g1.s;
					_gthis.tokenText(token,_gthis.printStringToken(token));
					break;
				case 4:
					var _g2 = _g1.r;
					var _g2 = _g1.opt;
					_gthis.tokenText(token,_gthis.printEregToken(token));
					break;
				default:
					_gthis.tokenText(token,token.toString());
				}
				break;
			case 8:
				var text = _g.s;
				_gthis.tokenText(token,_gthis.printCommentLine(text));
				break;
			default:
				_gthis.tokenText(token,token.toString());
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,finalRun: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 7) {
				var text = _g.s;
				_gthis.tokenText(token,_gthis.printComment(text,token));
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,printStringToken: function(token) {
		var text = this.parsedCode.getString(token.pos.min,token.pos.max);
		if(!this.config.whitespace.formatStringInterpolation) {
			return text;
		}
		if(StringTools.startsWith(text,"'")) {
			var start = 0;
			var index;
			while(true) {
				index = text.indexOf("${",start);
				if(!(index >= 0)) {
					break;
				}
				if(this.isDollarEscaped(text,index)) {
					return text;
				}
				start = index + 1;
				var indexEnd = text.indexOf("}",index + 2);
				var fragment = text.substring(index + 2,indexEnd);
				if(fragment.indexOf("{") >= 0) {
					continue;
				}
				var formatted = this.formatFragment(fragment);
				start += formatted.length;
				text = HxOverrides.substr(text,0,index + 2) + formatted + HxOverrides.substr(text,indexEnd,null);
			}
		}
		return text;
	}
	,isDollarEscaped: function(text,index) {
		var escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	,formatFragment: function(fragment) {
		try {
			var fileName = "string interpolation";
			var this1 = haxe_io_Bytes.ofString(fragment);
			var tokens = this.makeTokens(this1,fileName);
			var this1 = haxe_io_Bytes.ofString(fragment);
			var stream = new tokentree_TokenStream(tokens,this1);
			var root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) if(stream.hasMore()) {
				tokentree_walk_WalkStatement.walkStatement(stream,root);
			}
			var this1 = haxe_io_Bytes.ofString(fragment);
			var inputData = { fileName : fileName, content : this1, tokenList : tokens, tokenTree : root, config : this.config, entryPoint : tokentree_TokenTreeEntryPoint.ExpressionLevel};
			var interpolParsedCode = new formatter_codedata_ParsedCode(inputData);
			var interpolIndenter = new formatter_marker_Indenter(this.config.indentation);
			interpolIndenter.setParsedCode(interpolParsedCode);
			var markTokenText = new formatter_marker_MarkTokenText(this.config,interpolParsedCode,interpolIndenter);
			var markWhitespace = new formatter_marker_MarkWhitespace(this.config,interpolParsedCode,interpolIndenter);
			markTokenText.run();
			markWhitespace.run();
			var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,interpolParsedCode);
			var lines = new formatter_codedata_CodeLines(interpolParsedCode,interpolIndenter);
			var formatted = lines.print(outputLineEnds);
			return StringTools.trim(formatted);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return fragment;
	}
	,makeTokens: function(fragment,name) {
		var tokens = [];
		try {
			var lexer = new haxeparser_HaxeLexer(fragment,name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to make tokens " + (e == null ? "null" : Std.string(e)));
		}
		return tokens;
	}
	,printEregToken: function(token) {
		return this.parsedCode.getString(token.pos.min,token.pos.max);
	}
	,printComment: function(text,token) {
		var lines = text.split(this.parsedCode.lineSeparator);
		var indent = this.indenter.calcIndent(token);
		var startsWithStar = lines.length >= 3;
		var _g = 1;
		var _g1 = lines.length - 1;
		while(_g < _g1) {
			var index = _g++;
			if(!new EReg("^\\s*\\*(\\s|$)","").match(lines[index])) {
				startsWithStar = false;
				break;
			}
		}
		var linesNew = [];
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			linesNew.push(this.convertLeadingIndent(line));
		}
		lines = this.removeCommentPrefix(linesNew);
		var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,this.parsedCode);
		text = "/*" + lines[0];
		var _g = 1;
		var _g1 = lines.length;
		while(_g < _g1) {
			var index = _g++;
			text += outputLineEnds;
			var line = lines[index];
			var lineIndent = indent;
			var lastLine = index == lines.length - 1;
			if(!lastLine) {
				++lineIndent;
			}
			if(startsWithStar) {
				lineIndent = indent;
			}
			if(!lastLine && line.length <= 0) {
				lineIndent = 0;
			}
			if(!lastLine && startsWithStar) {
				line = " " + line;
			}
			if(lastLine) {
				if(new EReg("^\\s*\\*\\s*[^\\s\\*]","").match(line)) {
					line = " " + line;
				}
				var leadingWS = new EReg("^\\s*}","");
				if(leadingWS.match(line)) {
					line = StringTools.trim(line);
				} else {
					if(new EReg("^\\s*[^*\\s]","").match(line)) {
						lineIndent = indent + 1;
					}
					line = StringTools.rtrim(line);
					if(!StringTools.endsWith(line,"*")) {
						line += " ";
					}
				}
				if(new EReg("^\\s*$","").match(line)) {
					line = " ";
				}
			}
			text += this.indenter.makeIndentString(lineIndent) + line;
		}
		return text + "*/";
	}
	,removeCommentPrefix: function(lines) {
		var prefixReg = new EReg("^(\\s*)","");
		var prefix = null;
		var linesNew = [];
		var endIndex = lines.length - 1;
		var lastLine = lines[lines.length - 1];
		if(!new EReg("^\\s*(\\**$|\\})","").match(lastLine)) {
			endIndex = lines.length;
		}
		var _g = 1;
		var _g1 = endIndex;
		while(_g < _g1) {
			var index = _g++;
			var line = lines[index];
			prefixReg.match(line);
			var linePrefix = prefixReg.matched(1);
			if(linePrefix.length <= 0) {
				continue;
			}
			if(prefix == null || prefix.length > linePrefix.length) {
				prefix = linePrefix;
			}
		}
		if(prefix != null) {
			linesNew = [];
			var startPrefix = prefix + " *";
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				if(StringTools.startsWith(line,startPrefix)) {
					line = HxOverrides.substr(line,startPrefix.length - 1,null);
				}
				if(StringTools.startsWith(line,prefix)) {
					line = HxOverrides.substr(line,prefix.length,null);
				}
				linesNew.push(line);
			}
			lines = linesNew;
		}
		var lastLine = lines[lines.length - 1];
		if(new EReg("^\\s*\\*\\**$","").match(lastLine)) {
			lines[lines.length - 1] = StringTools.ltrim(lastLine);
		}
		return lines;
	}
	,convertLeadingIndent: function(line) {
		var spaceIndent = StringTools.lpad(""," ",this.config.indentation.tabWidth);
		var oneIndent = this.config.indentation.character;
		var whitespaceReg = new EReg("^\\s+","");
		if(!whitespaceReg.match(line)) {
			return line;
		}
		var match = whitespaceReg.matched(0);
		if(this.config.indentation.character == "\t") {
			var newPrefix = StringTools.replace(match,spaceIndent,oneIndent);
			line = newPrefix + HxOverrides.substr(line,match.length,null);
		} else {
			var newPrefix = StringTools.replace(match,"\t",oneIndent);
			line = newPrefix + HxOverrides.substr(line,match.length,null);
		}
		return line;
	}
	,printCommentLine: function(text) {
		if(new EReg("^[/\\*\\-\\s]+","").match(text)) {
			return "//" + StringTools.rtrim(text);
		}
		if(this.config.whitespace.addLineCommentSpace) {
			return "// " + StringTools.trim(text);
		}
		return "//" + StringTools.trim(text);
	}
	,__class__: formatter_marker_MarkTokenText
});
var formatter_marker_MarkWhitespace = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.MarkWhitespace"] = formatter_marker_MarkWhitespace;
formatter_marker_MarkWhitespace.__name__ = "formatter.marker.MarkWhitespace";
formatter_marker_MarkWhitespace.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkWhitespace.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.k;
				_gthis.markKeyword(token);
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "is":
						_gthis.markIs(token);
						break;
					case "from":case "to":
						var parent = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(token)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdAbstract));
						if(parent != null) {
							_gthis.whitespace(token,"around");
							_gthis.wrapBefore(token,true);
						}
						_gthis.fixConstAfterConst(token);
						break;
					default:
						_gthis.fixConstAfterConst(token);
					}
				} else {
					_gthis.fixConstAfterConst(token);
				}
				break;
			case 3:
				var _g1 = _g.s;
				_gthis.markSharp(token);
				break;
			case 4:
				var _g1 = _g.s;
				_gthis.markDollar(token);
				break;
			case 5:
				var _g1 = _g.op;
				_gthis.markUnop(token);
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token.parent)) {
						_gthis.whitespace(token,"none");
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 3:
					if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
						var policy = formatter_config_WhitespacePolicy.remove(_gthis.config.whitespace.binopPolicy,"after");
						var prev = _gthis.getPreviousToken(token);
						switch(prev.token.tok._hx_index) {
						case 15:case 19:
							policy = formatter_config_WhitespacePolicy.remove(policy,"before");
							break;
						default:
						}
						_gthis.whitespace(token,policy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 4:
					_gthis.markOpAssign(token);
					break;
				case 7:
					_gthis.markGt(token);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						_gthis.whitespace(token,_gthis.config.whitespace.typeParamOpenPolicy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 21:
					_gthis.markOpSpread(token);
					break;
				case 23:
					_gthis.markIn(token);
					break;
				default:
					_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
				}
				break;
			case 7:
				var _g1 = _g.s;
				_gthis.markComment(token);
				break;
			case 8:
				var _g1 = _g.s;
				_gthis.whitespace(token,"before");
				break;
			case 10:
				_gthis.markSemicolon(token);
				break;
			case 12:
				_gthis.markDblDot(token);
				break;
			case 13:
				_gthis.markArrow(token);
				break;
			case 14:
				_gthis.whitespace(token,_gthis.config.whitespace.commaPolicy);
				break;
			case 15:
				_gthis.successiveParenthesis(token,false,_gthis.config.whitespace.openingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 16:
				_gthis.successiveParenthesis(token,true,_gthis.config.whitespace.closingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 17:
				_gthis.markBrOpen(token);
				break;
			case 18:
				_gthis.markBrClose(token);
				break;
			case 19:
				_gthis.markPOpen(token);
				break;
			case 20:
				_gthis.markPClose(token);
				break;
			case 21:
				if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
					_gthis.whitespace(token,_gthis.config.whitespace.ternaryPolicy);
				} else {
					_gthis.whitespace(token,"noneAfter");
				}
				break;
			case 22:
				_gthis.markAt(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markOpSpread: function(token) {
		var prev = this.getPreviousToken(token);
		var policy = this.config.whitespace.intervalPolicy;
		if(prev != null) {
			policy = prev.token.tok._hx_index == 14 ? formatter_config_WhitespacePolicy.add(this.config.whitespace.intervalPolicy,"before") : this.config.whitespace.intervalPolicy;
		}
		this.whitespace(token,policy);
	}
	,markGt: function(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(token)) {
			this.whitespace(token,this.config.whitespace.typeExtensionPolicy);
			return;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
			var policy = this.config.whitespace.typeParamClosePolicy;
			var next = this.getNextToken(token);
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					var _g1 = _g.k;
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 10:case 14:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 18:case 20:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				default:
				}
			}
			this.whitespace(token,policy);
		} else {
			this.whitespace(token,this.config.whitespace.binopPolicy);
		}
	}
	,fixConstAfterConst: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.k;
				this.whitespace(token,"after");
				break;
			case 2:
				var _g1 = _g.c;
				this.whitespace(token,"after");
				break;
			default:
			}
		}
	}
	,successiveParenthesis: function(token,closing,policy,compress) {
		var next = this.getNextToken(token);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.k;
				if(closing) {
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 7:
					if(token.tok._hx_index == 18) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 22:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				default:
				}
				break;
			case 10:case 11:case 12:case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		if(!compress) {
			this.whitespace(token,policy);
			return;
		}
		if(closing) {
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 7) {
						if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(next.token)) {
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
						}
					}
					break;
				case 18:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 15:case 16:case 17:case 19:case 20:
					if(token.tok._hx_index == 20) {
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
						case 1:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 3:case 4:case 5:case 6:case 7:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 8:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 0:case 2:case 9:
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
							break;
						}
					} else {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				default:
				}
			}
		} else {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				var _g = prev.token.tok;
				switch(_g._hx_index) {
				case 6:
					switch(_g.op._hx_index) {
					case 9:
						if(token.tok._hx_index == 17) {
							return;
						}
						break;
					case 21:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					default:
					}
					break;
				case 9:
					var _g1 = _g.s;
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 12:
					switch(prev.whitespaceAfter._hx_index) {
					case 0:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					case 1:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					case 2:
						break;
					}
					break;
				case 13:
					return;
				case 14:
					var _g = this.config.whitespace.commaPolicy;
					if(_g != null) {
						switch(_g) {
						case "after":case "around":case "onlyAfter":
							policy = formatter_config_WhitespacePolicy.add(policy,"before");
							break;
						default:
						}
					}
					break;
				case 15:case 17:case 19:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 20:
					switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.token)._hx_index) {
					case 3:case 4:case 5:case 6:case 7:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					default:
					}
					break;
				default:
				}
			}
		}
		this.whitespace(token,policy);
	}
	,markKeyword: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 2:
				var _g1 = _g.c;
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 20:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 22:
				return;
			default:
			}
		}
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:
				this.whitespace(token,this.config.whitespace.ifPolicy);
				break;
			case 4:
				var policy = this.config.whitespace.ifPolicy;
				this.whitespace(token,formatter_config_WhitespacePolicy.add(policy,"after"));
				break;
			case 5:
				this.whitespace(token,this.config.whitespace.whilePolicy);
				break;
			case 6:
				this.whitespace(token,this.config.whitespace.doPolicy);
				break;
			case 7:
				this.whitespace(token,this.config.whitespace.forPolicy);
				break;
			case 10:
				this.whitespace(token,"after");
				break;
			case 11:case 12:
				this.whitespace(token,"around");
				break;
			case 14:
				this.whitespace(token,this.config.whitespace.switchPolicy);
				break;
			case 20:
				this.whitespace(token,this.config.whitespace.tryPolicy);
				break;
			case 21:
				this.whitespace(token,this.config.whitespace.catchPolicy);
				break;
			case 28:
				this.whitespace(token,"after");
				break;
			case 9:case 16:case 23:case 36:case 37:case 38:
				var next = this.getNextToken(token);
				if(next != null) {
					var _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						var _g1 = _g.k;
						this.whitespace(token,"after");
						return;
					case 2:
						var _g1 = _g.c;
						if(_g1._hx_index == 3) {
							var _g = _g1.s;
							this.whitespace(token,"after");
							return;
						}
						break;
					case 21:
						this.whitespace(token,"after");
						return;
					default:
					}
				}
				this.whitespace(token,"noneAfter");
				break;
			default:
				var next = this.getNextToken(token);
				if(next != null) {
					switch(next.token.tok._hx_index) {
					case 11:
						return;
					case 19:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markIs: function(token) {
		var prev = this.getPreviousToken(token);
		var policy = "around";
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 11:case 19:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markIn: function(token) {
		if(!tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			this.whitespace(token,"around");
			return;
		}
		var policy = "after";
		if(token.hasChildren()) {
			policy = "none";
		}
		this.whitespace(token,policy);
	}
	,markOpAssign: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			this.whitespace(token,this.config.whitespace.binopPolicy);
			return;
		}
		var policy = this.config.whitespace.binopPolicy;
		var _g = prev.token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 14:case 15:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markUnop: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 11:
				var _g = token.tok;
				if(_g._hx_index == 5) {
					if(_g.op._hx_index == 2) {
						this.whitespace(token,"none");
						return;
					}
				}
				break;
			case 10:case 14:
				return;
			case 16:case 18:case 20:
				return;
			default:
			}
		}
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		var _g = prev.token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g = _g1.s;
				var _g = token.tok;
				if(_g._hx_index == 5) {
					switch(_g.op._hx_index) {
					case 2:case 3:case 4:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markDollar: function(token) {
		var next = this.getNextToken(token);
		if(next == null) {
			return;
		}
		var _g = next.token.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			this.whitespace(token,"after");
			break;
		case 2:
			var _g1 = _g.c;
			this.whitespace(token,"after");
			break;
		default:
		}
	}
	,markDblDot: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		if(type == null) {
			type = tokentree_utils_ColonType.Unknown;
		}
		var policy = this.config.whitespace.colonPolicy;
		switch(type._hx_index) {
		case 0:
			policy = this.config.whitespace.caseColonPolicy;
			break;
		case 1:
			policy = this.config.whitespace.typeHintColonPolicy;
			break;
		case 2:
			policy = this.config.whitespace.typeCheckColonPolicy;
			break;
		case 3:
			policy = this.config.whitespace.ternaryPolicy;
			break;
		case 4:
			policy = this.config.whitespace.objectFieldColonPolicy;
			break;
		case 5:
			this.whitespace(token,"none");
			return;
		case 6:
			policy = this.config.whitespace.colonPolicy;
			break;
		}
		policy = this.correctDblDotSharp(token,policy);
		this.whitespace(token,policy);
	}
	,correctDblDotSharp: function(token,policy) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return policy;
		}
		var _g = prev.token.tok;
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(prev.token.parent == null) {
				return policy;
			}
			var _g1 = prev.token.parent.tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		case 3:
			if(_g.s != "end") {
				policy = formatter_config_WhitespacePolicy.add(policy,"before");
			}
			break;
		case 20:
			if(prev.token.parent == null) {
				return policy;
			}
			var _g = prev.token.parent.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		default:
		}
		return policy;
	}
	,markSemicolon: function(token) {
		var next = this.getNextToken(token);
		var policy = this.config.whitespace.semicolonPolicy;
		if(next != null) {
			if(next.token.tok._hx_index == 18) {
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
			}
		}
		this.whitespace(token,policy);
	}
	,markSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.whitespace(token,"around");
				break;
			case "elseif":
				this.whitespace(token,"around");
				break;
			case "end":
				var prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 15:case 17:case 19:
						break;
					default:
						this.whitespace(token,"before");
					}
				}
				var next = this.getNextToken(token);
				if(next != null) {
					var _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						var _g1 = _g.k;
						this.whitespace(token,"after");
						break;
					case 2:
						var _g1 = _g.c;
						this.whitespace(token,"after");
						break;
					case 10:case 14:
						break;
					case 15:case 17:case 19:case 21:
						this.whitespace(token,"after");
						break;
					default:
					}
				}
				break;
			case "error":
				this.whitespace(token,"after");
				break;
			case "if":
				this.whitespace(token,"after");
				var prev = this.getPreviousToken(token);
				if(prev != null) {
					var _g = prev.token.tok;
					switch(_g._hx_index) {
					case 1:
						var _g1 = _g.k;
						this.whitespace(token,"before");
						break;
					case 2:
						var _g1 = _g.c;
						this.whitespace(token,"before");
						break;
					default:
					}
				}
				var next = this.getNextToken(token);
				if(next != null) {
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild != null) {
						this.whitespace(lastChild,"after");
					}
				}
				break;
			default:
			}
		}
	}
	,markArrow: function(token) {
		var arrowType = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
		if(arrowType == null) {
			arrowType = tokentree_utils_ArrowType.ArrowFunction;
		}
		switch(arrowType._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.arrowFunctionsPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe3Policy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe4Policy);
			break;
		}
	}
	,determinePOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token);
		if(type == null) {
			type = tokentree_utils_POpenType.Expression;
		}
		switch(type._hx_index) {
		case 0:
			this.config.whitespace.parenConfig.metadataParens.openingPolicy = formatter_config_WhitespacePolicy.remove(this.config.whitespace.parenConfig.metadataParens.openingPolicy,"before");
			return this.config.whitespace.parenConfig.metadataParens;
		case 1:
			var _g = token.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					var policy = { openingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.openingPolicy, closingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.closingPolicy, removeInnerWhenEmpty : this.config.whitespace.parenConfig.anonFuncParamParens.removeInnerWhenEmpty};
					switch(policy.openingPolicy) {
					case "after":
						policy.openingPolicy = "around";
						break;
					case "around":
						break;
					case "before":
						break;
					case "none":
						policy.openingPolicy = "before";
						break;
					case "noneAfter":
						policy.openingPolicy = "onlyBefore";
						break;
					case "noneBefore":
						policy.openingPolicy = "before";
						break;
					case "onlyAfter":
						policy.openingPolicy = "around";
						break;
					case "onlyBefore":
						break;
					}
					return policy;
				case 22:
					return this.config.whitespace.parenConfig.funcParamParens;
				default:
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var _g = _g1.s;
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			default:
				return this.config.whitespace.parenConfig.anonFuncParamParens;
			}
			break;
		case 2:
			return this.config.whitespace.parenConfig.callParens;
		case 3:
			if(this.config.whitespace.parenConfig.switchConditionParens != null) {
				return this.config.whitespace.parenConfig.switchConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 4:
			if(this.config.whitespace.parenConfig.whileConditionParens != null) {
				return this.config.whitespace.parenConfig.whileConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 5:
			if(this.config.whitespace.parenConfig.ifConditionParens != null) {
				return this.config.whitespace.parenConfig.ifConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 6:
			if(this.config.whitespace.parenConfig.sharpConditionParens != null) {
				return this.config.whitespace.parenConfig.sharpConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 7:
			if(this.config.whitespace.parenConfig.catchParens != null) {
				return this.config.whitespace.parenConfig.catchParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 8:
			return this.config.whitespace.parenConfig.forLoopParens;
		case 9:
			return this.config.whitespace.parenConfig.expressionParens;
		}
	}
	,markPOpen: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 5:
				var _g1 = _g.op;
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			case 6:
				var _g1 = _g.op;
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			case 7:
				var _g1 = _g.s;
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			default:
			}
		}
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 20) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markPClose: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 19) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,determineBrOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
		if(type == null) {
			type = tokentree_utils_BrOpenType.Unknown;
		}
		switch(type._hx_index) {
		case 0:
			return this.config.whitespace.bracesConfig.blockBraces;
		case 1:
			return this.config.whitespace.bracesConfig.typedefBraces;
		case 2:
			return this.config.whitespace.bracesConfig.objectLiteralBraces;
		case 3:
			return this.config.whitespace.bracesConfig.anonTypeBraces;
		case 4:
			return this.config.whitespace.bracesConfig.unknownBraces;
		}
	}
	,markBrOpen: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 18) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markBrClose: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 17) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markComment: function(token) {
		var policy = "around";
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 9) {
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					}
				}
				break;
			case 15:case 17:case 19:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			case 16:case 18:case 20:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markAt: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		switch(prev.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:case 2:
			return;
		}
		var _g = prev.token.tok;
		switch(_g._hx_index) {
		case 0:
			return;
		case 1:
			var _g1 = _g.k;
			break;
		case 2:
			var _g1 = _g.c;
			break;
		case 3:
			var _g1 = _g.s;
			break;
		case 4:
			var _g1 = _g.s;
			break;
		case 5:
			var _g1 = _g.op;
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
					return;
				}
			}
			break;
		case 7:
			var _g1 = _g.s;
			return;
		case 8:
			var _g1 = _g.s;
			return;
		case 9:
			var _g1 = _g.s;
			break;
		case 10:
			return;
		case 11:
			break;
		case 12:
			break;
		case 13:
			break;
		case 14:
			break;
		case 16:
			break;
		case 18:
			break;
		case 15:case 17:case 19:
			return;
		case 20:
			break;
		case 21:
			break;
		case 22:
			break;
		case 23:
			return;
		}
		this.whitespace(token,"before");
	}
	,__class__: formatter_marker_MarkWhitespace
});
var formatter_marker_wrapping_MarkWrappingBase = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
	this.wrappingQueue = [];
};
$hxClasses["formatter.marker.wrapping.MarkWrappingBase"] = formatter_marker_wrapping_MarkWrappingBase;
formatter_marker_wrapping_MarkWrappingBase.__name__ = "formatter.marker.wrapping.MarkWrappingBase";
formatter_marker_wrapping_MarkWrappingBase.__super__ = formatter_marker_MarkerBase;
formatter_marker_wrapping_MarkWrappingBase.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	noWrap: function(open,close) {
		var colon = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(open,tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.DblDot);
		if(colon != null) {
			var type = tokentree_utils_TokenTreeCheckUtils.getColonType(colon);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				this.noLineEndBefore(open);
				break;
			case 5:
				break;
			case 6:
				break;
			}
		}
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				break _hx_loop1;
			default:
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				continue;
			} else {
				switch(lastChild.tok._hx_index) {
				case 10:case 14:
					this.noLineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
		this.noLineEndBefore(close);
	}
	,keep2: function(open,close,items,addIndent,location) {
		var tokens = [];
		var _g = [];
		var _g1 = 0;
		while(_g1 < items.length) {
			var item = items[_g1];
			++_g1;
			_g.push(item.last);
		}
		tokens = _g;
		if(items.length > 0) {
			tokens.unshift(items[0].first);
		}
		var _g = [];
		var _g1 = 0;
		while(_g1 < items.length) {
			var item = items[_g1];
			++_g1;
			_g.push(item.first);
		}
		tokens = tokens.concat(_g);
		if(close != null) {
			tokens.push(close);
		}
		tokens.push(close);
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
				this.additionalIndent(token,addIndent);
			} else {
				this.noLineEndBefore(token);
				this.wrapBefore(token,false);
			}
		}
	}
	,keep: function(open,close,addIndent) {
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var last = false;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				last = true;
				break;
			default:
			}
			if(this.parsedCode.isOriginalNewlineBefore(child)) {
				this.lineEndBefore(child);
				this.additionalIndent(child,addIndent);
			} else {
				this.noLineEndBefore(child);
				this.wrapBefore(child,false);
			}
			if(last) {
				break;
			}
		}
		if(!this.parsedCode.isOriginalNewlineBefore(open)) {
			this.noLineEndBefore(open);
		}
	}
	,wrapChildOneLineEach2: function(open,close,items,addIndent,location,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		switch(location) {
		case "afterLast":
			var _g = 0;
			while(_g < items.length) {
				var item = items[_g];
				++_g;
				this.additionalIndent(item.first,addIndent);
				this.lineEndBefore(item.first);
				var _g1 = item.last.tok;
				if(_g1._hx_index == 3) {
					var _g2 = _g1.s;
					this.lineEndBefore(item.last);
				}
			}
			break;
		case "beforeLast":
			var item = items[0];
			this.additionalIndent(item.first,addIndent);
			this.lineEndBefore(item.first);
			item = items.pop();
			var _g = 0;
			while(_g < items.length) {
				var it = items[_g];
				++_g;
				this.additionalIndent(it.last,addIndent);
				this.lineEndBefore(it.last);
			}
			items.push(item);
			break;
		}
		if(keepFirst) {
			if(open != null) {
				this.noLineEndAfter(open);
			}
			var lastToken = items[items.length - 1].last;
			if(lastToken.tok._hx_index != 10) {
				var next = this.getNextToken(lastToken);
				if(next == null) {
					this.noLineEndAfter(lastToken);
					return;
				}
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 22:case 23:case 36:
						this.noLineEndAfter(lastToken);
						break;
					default:
					}
					break;
				case 10:
					break;
				default:
					this.noLineEndAfter(lastToken);
				}
			}
		} else {
			var lastToken = items[items.length - 1].last;
			var next = this.getNextToken(lastToken);
			if(next == null) {
				this.lineEndAfter(lastToken);
				return;
			}
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 22:case 23:case 36:
					this.lineEndAfter(lastToken);
					break;
				default:
				}
				break;
			case 10:
				break;
			case 14:
				break;
			case 15:case 17:case 19:
				break;
			default:
				this.lineEndAfter(lastToken);
			}
		}
	}
	,wrapChildOneLineEach: function(open,close,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(!keepFirst) {
			this.lineEndAfter(open);
		}
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 3:
				var _g3 = _g2.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					if(keepFirst) {
						this.noLineEndBefore(child);
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var _g4 = _g2.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.noLineEndBefore(child);
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				this.lineEndAfter(child);
			} else {
				this.lineEndAfter(lastChild);
			}
		}
		if(close == null) {
			return;
		}
		switch(close.tok._hx_index) {
		case 16:case 18:case 20:
			this.lineEndBefore(close);
			break;
		default:
		}
	}
	,wrapChildOneLineEachSharp: function(sharp,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var children = sharp.children;
		var skipFirst = false;
		this.lineEndBefore(sharp);
		var _g = sharp.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.lineEndAfter(sharp);
				break;
			case "elseif":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			case "end":
				this.lineEndAfter(sharp);
				return;
			case "if":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			default:
			}
		}
		var _g = 0;
		while(_g < children.length) {
			var child = children[_g];
			++_g;
			if(skipFirst) {
				skipFirst = false;
				continue;
			}
			var _g1 = child.tok;
			switch(_g1._hx_index) {
			case 3:
				var _g2 = _g1.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g1.op._hx_index == 7) {
					if(keepFirst) {
						this.whitespace(child,"noneBefore");
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var _g3 = _g1.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.whitespace(child,"noneBefore");
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
		}
	}
	,wrapFillLine2AfterLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var first = false;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				this.noLineEndBefore(item.first);
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			var lengthAfter = this.calcLineLengthAfter(lastItem.last);
			if(lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(lastItem.first);
				this.additionalIndent(lastItem.first,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLineWithLeading2AfterLast: function(open,close,items,maxLineLength,addIndent) {
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(!first) {
					this.noLineEndBefore(item.first);
				} else {
					this.lineEndBefore(item.first);
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		var lastItem = items[items.length - 1];
		switch(lastItem.last.tok._hx_index) {
		case 10:
			break;
		case 12:
			break;
		case 16:case 18:case 20:
			if(this.isNewLineAfter(lastItem.last)) {
				this.lineEndAfter(lastItem.last);
			}
			break;
		default:
			this.lineEndAfter(lastItem.last);
		}
	}
	,wrapFillLine2BeforeLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				var prev = this.getPreviousToken(item.first);
				if(prev != null) {
					this.lineEndBefore(prev.token);
					this.additionalIndent(prev.token,addIndent);
					lineLength += prev.text.length;
				}
				if(item.multiline) {
					lineLength += item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(first) {
					this.noLineEndBefore(item.first);
				} else {
					var prev1 = this.getPreviousToken(item.first);
					if(prev1 != null) {
						this.noLineEndBefore(prev1.token);
					}
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent) + item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			var lengthAfter = this.calcLineLengthAfter(lastItem.last);
			var prev = this.getPreviousToken(lastItem.first);
			if(prev != null && lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(prev.token);
				this.additionalIndent(prev.token,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLine: function(open,close,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var lineStart = this.findLineStartToken(open);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent + addIndent);
		var first = true;
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 0) {
					continue;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					this.whitespace(child,"noneBefore");
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var _g3 = _g2.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				this.whitespace(child,"noneBefore");
				if(useTrailing) {
					var trailing = this.calcLineLengthAfter(child);
					if(trailing + lineLength > maxLineLength) {
						var prev1 = child.previousSibling;
						if(prev1 == null) {
							return;
						}
						this.lineEndBefore(prev1);
						this.additionalIndent(prev1,addIndent);
					}
				}
				return;
			case 17:
				continue;
			default:
				this.additionalIndent(child,addIndent);
			}
			var tokenLength = this.calcLength(child);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				lastChild = child;
			}
			lineLength += tokenLength;
			if(lineLength > maxLineLength) {
				this.lineEndBefore(child);
				this.noLineEndAfter(lastChild);
				indent = this.indenter.calcIndent(child);
				lineLength = tokenLength + this.indenter.calcAbsoluteIndent(indent);
			} else {
				this.noLineEndAfter(lastChild);
			}
			if(first) {
				first = false;
				this.noLineEndBefore(child);
			}
		}
	}
	,calcLineLength: function(token) {
		var indent = this.indenter.calcIndent(token);
		return formatter_marker_MarkerBase.prototype.calcLineLength.call(this,token) + this.indenter.calcAbsoluteIndent(indent);
	}
	,hasEmptyFunctionBody: function(token) {
		var last = token.getLastChild();
		if(last.tok._hx_index == 10) {
			return true;
		}
		var body = token.nextSibling;
		if(body == null) {
			return true;
		}
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		while(body != null && body.tok._hx_index == 22) body = body.nextSibling;
		if(body == null) {
			return true;
		}
		switch(body.tok._hx_index) {
		case 10:
			return true;
		case 17:
			var brClose = body.getFirstChild();
			if(brClose == null) {
				return false;
			}
			if(brClose.tok._hx_index == 18) {
				return true;
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	,makeWrappableItems: function(token) {
		var items = [];
		var lastIndex = -1;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					return items;
				}
				break;
			case 16:case 18:case 20:
				return items;
			default:
			}
			if(child.index <= lastIndex) {
				continue;
			}
			var endToken = this.findItemEnd(child);
			if(endToken == null) {
				continue;
			}
			lastIndex = endToken.index;
			var sameLine = this.isSameLineBetween(child,endToken,false);
			var firstLineLength = this.calcLengthUntilNewline(child,endToken);
			if(this.isMultilineToken(endToken)) {
				sameLine = false;
			}
			var lastLineLength = 0;
			if(!sameLine) {
				lastLineLength = this.calcLineLengthAfter(endToken);
			}
			var item = { first : child, last : endToken, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
			items.push(item);
		}
		return items;
	}
	,findItemEnd: function(child) {
		var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
		if(endToken == null) {
			return null;
		}
		if(endToken.index == child.index) {
			var _g = child.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				var next = child.nextSibling;
				if(next != null) {
					return this.findItemEnd(next);
				}
				break;
			case 8:
				var _g1 = _g.s;
				var next = child.nextSibling;
				if(next != null) {
					return this.findItemEnd(next);
				}
				break;
			default:
			}
		}
		if(endToken.tok._hx_index == 14) {
			var next = this.getNextToken(endToken);
			if(next == null) {
				return endToken;
			}
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 7:
				var s = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			case 8:
				var s = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			default:
			}
			return endToken;
		}
		var next = this.getNextToken(endToken);
		if(next == null) {
			return endToken;
		}
		var _g = next.token.tok;
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(next.token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null) {
					return endToken;
				}
				return this.findItemEnd(next.token);
			} else {
				return this.findItemEnd(next.token);
			}
			break;
		case 7:
			var _g1 = _g.s;
			return this.findItemEnd(next.token);
		case 8:
			var _g1 = _g.s;
			return this.findItemEnd(next.token);
		default:
		}
		return endToken;
	}
	,determineWrapType2: function(rules,token,items) {
		var itemCount = items.length;
		if(items.length <= 0) {
			return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
		}
		var maxItemLength = 0;
		var totalItemLength = 0;
		var lineLength = this.calcLineLength(token);
		var hasMultiLineItem = false;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			totalItemLength += item.firstLineLength + item.lastLineLength;
			if(item.multiline) {
				hasMultiLineItem = true;
			}
			var length = Math.floor(Math.max(item.firstLineLength,item.lastLineLength));
			if(length > maxItemLength) {
				maxItemLength = length;
			}
		}
		var _g = 0;
		var _g1 = rules.rules;
		while(_g < _g1.length) {
			var rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,determineWrapType: function(rules,itemCount,maxItemLength,totalItemLength,lineLength) {
		var _g = 0;
		var _g1 = rules.rules;
		while(_g < _g1.length) {
			var rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,false)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,matchesRule: function(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem) {
		var _g = 0;
		var _g1 = rule.conditions;
		while(_g < _g1.length) {
			var cond = _g1[_g];
			++_g;
			switch(cond.cond) {
			case "anyItemLength <= n":
				if(maxItemLength > cond.value) {
					return false;
				}
				break;
			case "anyItemLength >= n":
				if(maxItemLength < cond.value) {
					return false;
				}
				break;
			case "exceedsMaxLineLength":
				if(cond.value == 1) {
					if(lineLength <= this.config.wrapping.maxLineLength) {
						return false;
					}
				} else if(lineLength > this.config.wrapping.maxLineLength) {
					return false;
				}
				break;
			case "hasMultilineItems":
				if(cond.value == 1) {
					if(!hasMultiLineItem) {
						return false;
					}
				} else if(hasMultiLineItem) {
					return false;
				}
				break;
			case "itemCount <= n":
				if(itemCount > cond.value) {
					return false;
				}
				break;
			case "itemCount >= n":
				if(itemCount < cond.value) {
					return false;
				}
				break;
			case "lineLength <= n":
				if(lineLength > cond.value) {
					return false;
				}
				break;
			case "lineLength >= n":
				if(lineLength < cond.value) {
					return false;
				}
				break;
			case "totalItemLength <= n":
				if(totalItemLength > cond.value) {
					return false;
				}
				break;
			case "totalItemLength >= n":
				if(totalItemLength < cond.value) {
					return false;
				}
				break;
			}
		}
		return true;
	}
	,applyRule: function(origin,rule,open,close,items,addIndent,useTrailing) {
		var location = "afterLast";
		if(rule.location != null) {
			location = rule.location;
		}
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			switch(location) {
			case "afterLast":
				this.wrapFillLine2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "fillLineWithLeadingBreak":
			switch(location) {
			case "afterLast":
				this.wrapFillLineWithLeading2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "keep":
			this.keep2(open,close,items,addIndent,location);
			break;
		case "noWrap":
			this.noWrappingBetween(open,close,false);
			break;
		case "onePerLine":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location,true);
			break;
		}
	}
	,applyWrappingQueue: function() {
		var _g = 0;
		var _g1 = this.wrappingQueue;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.applyWrappingPlace(place);
		}
	}
	,applyWrappingPlace: function(place) {
		var rule = this.determineWrapType2(place.rules,place.start,place.items);
		var additionalIndent = rule.additionalIndent;
		if(place.overrideAdditionalIndent != null) {
			additionalIndent = place.overrideAdditionalIndent;
		}
		this.applyRule(place.origin,rule,place.start,place.end,place.items,additionalIndent,place.useTrailing);
	}
	,queueWrapping: function(place,name) {
		if(place.items == null || place.items.length <= 0) {
			return;
		}
		var startIndex = this.getPlaceStartIndex(place);
		var endIndex = this.getPlaceEndIndex(place);
		if(startIndex < 0 || endIndex < 0) {
			return;
		}
		var index = 0;
		var _g = 0;
		var _g1 = this.wrappingQueue.length;
		while(_g < _g1) {
			var index = _g++;
			var p = this.wrappingQueue[index];
			var itemStart = this.getPlaceStartIndex(p);
			if(startIndex > itemStart) {
				continue;
			}
			if(startIndex == itemStart) {
				var itemEnd = this.getPlaceEndIndex(p);
				if(endIndex > itemEnd) {
					this.wrappingQueue.splice(index,0,place);
					return;
				}
				continue;
			}
			this.wrappingQueue.splice(index,0,place);
			return;
		}
		this.wrappingQueue.push(place);
	}
	,getPlaceStartIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.start != null) {
			return place.start.index;
		} else {
			return place.items[0].first.index;
		}
	}
	,getPlaceEndIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.end != null) {
			return place.end.index;
		} else {
			return place.items[place.items.length - 1].last.index;
		}
	}
	,__class__: formatter_marker_wrapping_MarkWrappingBase
});
var formatter_marker_wrapping_MarkWrapping = function(config,parsedCode,indenter) {
	formatter_marker_wrapping_MarkWrappingBase.call(this,config,parsedCode,indenter);
};
$hxClasses["formatter.marker.wrapping.MarkWrapping"] = formatter_marker_wrapping_MarkWrapping;
formatter_marker_wrapping_MarkWrapping.__name__ = "formatter.marker.wrapping.MarkWrapping";
formatter_marker_wrapping_MarkWrapping.__super__ = formatter_marker_wrapping_MarkWrappingBase;
formatter_marker_wrapping_MarkWrapping.prototype = $extend(formatter_marker_wrapping_MarkWrappingBase.prototype,{
	run: function() {
		var _gthis = this;
		var wrappableTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 0:
					return tokentree_FilterResult.FoundGoDeeper;
				case 9:
					return tokentree_FilterResult.FoundGoDeeper;
				case 22:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
				}
				break;
			case 8:
				var _g1 = _g.s;
				return tokentree_FilterResult.FoundGoDeeper;
			case 11:
				return tokentree_FilterResult.FoundGoDeeper;
			case 13:
				return tokentree_FilterResult.FoundGoDeeper;
			case 14:
				_gthis.wrapAfter(token,true);
				return tokentree_FilterResult.GoDeeper;
			case 15:
				return tokentree_FilterResult.FoundGoDeeper;
			case 17:
				return tokentree_FilterResult.FoundGoDeeper;
			case 19:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		wrappableTokens.reverse();
		var _g = 0;
		while(_g < wrappableTokens.length) {
			var token = wrappableTokens[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 6:
				switch(_g1.op._hx_index) {
				case 0:
					this.wrapAfter(token,true);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						this.wrapTypeParameter(token);
					}
					break;
				case 22:
					this.wrapAfter(token,true);
					break;
				default:
				}
				break;
			case 8:
				var _g2 = _g1.s;
				this.wrapBefore(token,false);
				break;
			case 11:
				break;
			case 13:
				this.wrapAfter(token,true);
				break;
			case 15:
				this.arrayWrapping(token);
				break;
			case 17:
				this.markBrWrapping(token);
				break;
			case 19:
				this.markPWrapping(token);
				break;
			default:
			}
		}
		this.markMethodChaining(this.parsedCode.root);
		this.markMultiVarChaining();
		this.markImplementsExtendsChaining();
		this.markOpBoolChaining();
		this.markOpAddChaining();
		this.markCasePatternChaining();
		this.applyWrappingQueue();
	}
	,wrapTypeParameter: function(token) {
		var close = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.TypeParameterWrapping, start : token, end : null, items : items, rules : this.config.wrapping.typeParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapTypeParameter");
	}
	,markBrWrapping: function(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:
			this.typedefWrapping(token);
			break;
		case 2:
			this.objectLiteralWrapping(token);
			break;
		case 3:
			this.anonTypeWrapping(token);
			break;
		case 4:
			break;
		}
	}
	,typedefWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(this.isNewLineBefore(token)) {
			return;
		}
		if(this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.noWrap(token,brClose);
			return;
		}
	}
	,anonTypeWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		var next = this.getNextToken(brClose);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.k;
				this.lineEndAfter(brClose);
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "from":case "to":
						this.noLineEndAfter(brClose);
						break;
					default:
						this.lineEndAfter(brClose);
					}
				} else {
					this.lineEndAfter(brClose);
				}
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					this.noLineEndAfter(brClose);
				}
				break;
			case 17:
				switch(this.config.lineEnds.leftCurly) {
				case "after":case "none":
					this.noLineEndAfter(brClose);
					break;
				case "before":case "both":
					break;
				}
				break;
			default:
			}
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		var items = this.makeWrappableItems(token);
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.AnonTypeWrapping, start : token, end : brClose, items : items, rules : this.config.wrapping.anonType, useTrailing : true, overrideAdditionalIndent : null});
	}
	,objectLiteralWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 1) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		var maxLength = 0;
		var totalLength = 0;
		var itemCount = 0;
		var _g = 0;
		var _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 8:
				var _g3 = _g2.s;
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 18:
				break _hx_loop1;
			default:
			}
			var length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		var lineLength = this.calcLineLength(token);
		var rule = this.determineWrapType(this.config.wrapping.objectLiteral,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 11:case 14:
					this.whitespace(brClose,"noneAfter");
					break;
				case 12:
					this.noLineEndAfter(brClose);
					break;
				default:
				}
			}
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				var _g = prev.token.tok;
				switch(_g._hx_index) {
				case 1:
					var _g1 = _g.k;
					this.noLineEndBefore(token);
					this.whitespace(token,"before");
					break;
				case 6:
					var _g1 = _g.op;
					this.noLineEndBefore(token);
					break;
				case 14:case 19:
					this.noLineEndBefore(token);
					break;
				default:
				}
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	,markPWrapping: function(token) {
		var pClose = this.getCloseToken(token);
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
		case 0:
			this.wrapMetadataCallParameter(token);
			break;
		case 1:
			this.wrapFunctionSignature(token);
			break;
		case 2:
			this.wrapCallParameter(token);
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		}
	}
	,arrayWrapping: function(token) {
		var bkClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		var itemsWithoutMetadata = [];
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var _g1 = item.first.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 5:case 7:
					if(this.config.sameLine.comprehensionFor == "keep") {
						return;
					}
					itemsWithoutMetadata.push(item);
					break;
				default:
					itemsWithoutMetadata.push(item);
				}
				break;
			case 22:
				if(item.firstLineLength > 30) {
					this.lineEndBefore(token);
					this.lineEndBefore(item.first);
				}
				break;
			default:
				itemsWithoutMetadata.push(item);
			}
		}
		if(this.config.wrapping.arrayMatrixWrap != "noMatrixWrap") {
			if(this.tryMatrixWrap(token,bkClose,itemsWithoutMetadata)) {
				return;
			}
		}
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.ArrayWrapping, start : token, end : bkClose, items : itemsWithoutMetadata, rules : this.config.wrapping.arrayWrap, useTrailing : true, overrideAdditionalIndent : null});
	}
	,tryMatrixWrap: function(open,close,items) {
		var prev = null;
		var run = 1;
		var lineRun = 0;
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var index = _g++;
			var item = items[index];
			if(prev == null) {
				prev = item;
				continue;
			}
			if(item.multiline) {
				return false;
			}
			if(this.parsedCode.isOriginalSameLine(prev.first,item.first)) {
				++run;
				prev = item;
				continue;
			}
			if(lineRun != 0) {
				if(lineRun != run) {
					return false;
				}
			}
			lineRun = run;
			run = 1;
			prev = item;
		}
		if(lineRun <= 1) {
			return false;
		}
		if(lineRun != run) {
			return false;
		}
		this.lineEndAfter(open);
		if(this.config.wrapping.arrayMatrixWrap == "matrixWrapWithAlign") {
			var _g = [];
			var _g1 = 0;
			var _g2 = lineRun;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(0);
			}
			var maxCols = _g;
			var _g = 0;
			var _g1 = items.length;
			while(_g < _g1) {
				var index = _g++;
				var item = items[index];
				var col = index % lineRun;
				if(item.firstLineLength > maxCols[col]) {
					maxCols[col] = item.firstLineLength;
				}
			}
			var _g = 0;
			var _g1 = items.length;
			while(_g < _g1) {
				var index = _g++;
				var item = items[index];
				var expectedLength = maxCols[index % lineRun];
				if(index == items.length - 1) {
					if(item.last.tok._hx_index == 14) {
						--expectedLength;
					} else {
						expectedLength -= 2;
					}
				}
				if(item.firstLineLength < expectedLength) {
					this.spacesBefore(item.first,expectedLength - item.firstLineLength);
				}
			}
		}
		var index = lineRun - 1;
		while(index < items.length) {
			var item = items[index];
			this.lineEndAfter(item.last);
			index += lineRun;
		}
		return true;
	}
	,calcLineLength: function(token) {
		if(token == null) {
			return 0;
		}
		return formatter_marker_wrapping_MarkWrappingBase.prototype.calcLineLength.call(this,token);
	}
	,wrapFunctionSignature: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var rules = this.config.wrapping.functionSignature;
		var _g = token.parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				rules = this.config.wrapping.anonFunctionSignature;
			}
		}
		var emptyBody = this.hasEmptyFunctionBody(token);
		var items = this.makeWrappableItems(token);
		var addIndent = null;
		if(emptyBody) {
			addIndent = 0;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.FunctionSignatureWrapping, start : token, end : pClose, items : items, rules : rules, useTrailing : true, overrideAdditionalIndent : addIndent},"wrapFunctionSignature");
	}
	,wrapCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CallParameterWrapping, start : token, end : pClose, items : items, rules : this.config.wrapping.callParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapCallParameter");
	}
	,wrapMetadataCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MetadataCallParameterWrapping, start : token, end : pClose, items : items, rules : this.config.wrapping.metadataCallParameter, useTrailing : false, overrideAdditionalIndent : null},"wrapMetadataCallParameter");
	}
	,markMethodChaining: function(startToken) {
		var _gthis = this;
		if(startToken == null) {
			return;
		}
		var chainStarts = startToken.filterCallback(function(token,index) {
			if(token.tok._hx_index == 11) {
				var prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					var _g = prev.token.tok;
					switch(_g._hx_index) {
					case 7:
						var _g1 = _g.s;
						break;
					case 8:
						var _g2 = _g.s;
						break;
					case 20:
						_gthis.wrapBefore(token,true);
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markInternalMethodChaining(chainStart);
			this.markSingleMethodChain(chainStart);
		}
	}
	,markInternalMethodChaining: function(startToken) {
		var _gthis = this;
		startToken.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 15:case 17:case 19:
				_gthis.markMethodChaining(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markSingleMethodChain: function(chainStart) {
		var _gthis = this;
		var chainedCalls = chainStart.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 11:
				var prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					var _g = prev.token.tok;
					switch(_g._hx_index) {
					case 7:
						var _g1 = _g.s;
						break;
					case 8:
						var _g2 = _g.s;
						break;
					case 20:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
				return tokentree_FilterResult.GoDeeper;
			case 15:case 17:case 19:
				return tokentree_FilterResult.SkipSubtree;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var firstMethodCall = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(chainStart))),tokentree_TokenTreeDef.Dot);
		if(firstMethodCall != null) {
			chainedCalls.unshift(firstMethodCall);
			chainStart = firstMethodCall;
		}
		var items = [];
		var chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainStart);
		var info = this.getPreviousToken(chainStart);
		var chainOpen = chainStart.parent;
		if(info != null) {
			chainOpen = info.token;
		}
		var _g = 0;
		var _g1 = chainedCalls.length;
		while(_g < _g1) {
			var index = _g++;
			var child = chainedCalls[index];
			var endToken = chainEnd;
			if(index + 1 < chainedCalls.length) {
				var next = chainedCalls[index + 1];
				info = this.getPreviousToken(next);
				if(info != null) {
					endToken = info.token;
				}
			}
			items.push(this.makeWrappableItem(child,endToken));
		}
		chainEnd = null;
		if(chainOpen != null) {
			chainEnd = this.getCloseToken(chainOpen);
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MethodChainWrapping, start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.methodChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleMethodChain");
	}
	,markOpBoolChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				var _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markSingleOpBoolChain(chainStart);
		}
	}
	,markSingleOpBoolChain: function(itemStart) {
		var items = [];
		var firstItemStart = itemStart;
		var _g = itemStart.tok;
		if(_g._hx_index == 6) {
			var _g1 = _g.op;
			if(itemStart.previousSibling != null) {
				firstItemStart = itemStart.previousSibling;
			}
		}
		var prev = this.getPreviousToken(firstItemStart);
		var chainStart = itemStart;
		if(prev != null) {
			chainStart = prev.token;
		}
		var chainEnd = itemStart.getLastChild();
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:case 20:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var first = true;
		var _g = 0;
		var _g1 = itemStart.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 6) {
				switch(_g2.op._hx_index) {
				case 14:case 15:
					if(first) {
						itemStart = firstItemStart;
						first = false;
					}
					items.push(this.makeWrappableItem(itemStart,child));
					var next = this.getNextToken(child);
					if(next == null) {
						return;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpBoolChainWrapping, start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.opBoolChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpBoolChain");
	}
	,markCasePatternChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 15) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markSingleCasePatternChain(chainStart);
		}
	}
	,markSingleCasePatternChain: function(itemContainer) {
		var items = [];
		var chainStart = itemContainer;
		var chainEnd = tokentree_TokenTreeAccessHelper.firstOf(itemContainer,tokentree_TokenTreeDef.DblDot);
		var next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		var itemStart = next.token;
		var _g = 0;
		var _g1 = itemContainer.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 12) {
				break;
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				items.push(this.makeWrappableItem(child,lastToken));
			}
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CasePatternWrapping, start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.casePattern, useTrailing : false, overrideAdditionalIndent : null},"markSingleCasePatternChain");
	}
	,markOpAddChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				var _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markSingleOpAddChain(chainStart);
		}
	}
	,markSingleOpAddChain: function(itemContainer) {
		var items = [];
		var prev = this.getPreviousToken(this.findOpAddItemStart(itemContainer));
		var chainStart = this.findOpAddItemStart(itemContainer);
		var chainEnd = itemContainer.getLastChild();
		if(chainStart.tok._hx_index == 19) {
			var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(chainStart);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			case 7:
				break;
			case 8:
				break;
			case 9:
				break;
			}
		}
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		var itemStart = next.token;
		var _g = 0;
		var _g1 = itemContainer.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 6) {
				switch(_g2.op._hx_index) {
				case 0:case 3:
					items.push(this.makeWrappableItem(itemStart,child));
					var next = this.getNextToken(child);
					if(next == null) {
						continue;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpAddChainWrapping, start : chainStart, end : null, items : items, rules : this.config.wrapping.opAddSubChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpAddChain");
	}
	,findOpAddItemStart: function(itemStart) {
		if(itemStart == null || itemStart.tok == tokentree_TokenTreeDef.Root) {
			return itemStart;
		}
		var parent = itemStart;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 23:case 28:case 36:
					break;
				default:
					return parent;
				}
				break;
			case 6:
				var _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					return parent;
				case 20:
					var _g2 = _g1.op;
					return parent;
				default:
				}
				break;
			case 15:
				var bkClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BkClose);
				if(bkClose == null || bkClose.index > itemStart.index) {
					return parent;
				}
				break;
			case 17:
				var brClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
				if(brClose == null || brClose.index > itemStart.index) {
					return parent;
				}
				break;
			case 19:
				var pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(pClose == null || pClose.index > itemStart.index) {
					return parent;
				}
				break;
			default:
			}
			itemStart = parent;
			parent = parent.parent;
		}
		return itemStart;
	}
	,makeWrappableItem: function(start,end) {
		var sameLine = this.isSameLineBetween(start,end,false);
		var firstLineLength = 0;
		var lastLineLength = 0;
		if(sameLine) {
			firstLineLength = this.calcLengthBetween(start,end) + this.calcTokenLength(end);
		} else {
			firstLineLength = this.calcLengthUntilNewline(start,end);
			lastLineLength = this.calcLineLengthBefore(end) + this.calcTokenLength(end);
		}
		return { first : start, last : end, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
	}
	,markImplementsExtendsChaining: function() {
		var classesAndInterfaces = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 27:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 26:case 31:case 39:
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classesAndInterfaces.length) {
			var type = classesAndInterfaces[_g];
			++_g;
			var items = [];
			var impls = type.filterCallback(function(token,index) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.SkipSubtree;
					case 11:case 12:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var _g1 = 0;
			while(_g1 < impls.length) {
				var impl = impls[_g1];
				++_g1;
				var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(impl);
				items.push(this.makeWrappableItem(impl,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			var chainOpen = items[0].first;
			var prev = this.getPreviousToken(items[0].first);
			if(prev != null) {
				chainOpen = prev.token;
			}
			var chainEnd = items[items.length - 1].last;
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.ImplementsWrapping, start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.implementsExtends, useTrailing : false, overrideAdditionalIndent : null},"markImplementsExtendsChaining");
		}
	}
	,markMultiVarChaining: function() {
		var allVars = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					if(token.hasChildren() && token.children.length > 1) {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					return tokentree_FilterResult.SkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allVars.length) {
			var v = allVars[_g];
			++_g;
			var items = [];
			var _g1 = 0;
			var _g2 = v.children;
			while(_g1 < _g2.length) {
				var child = _g2[_g1];
				++_g1;
				var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				items.push(this.makeWrappableItem(child,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			var chainOpen = v;
			var chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(v);
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MultiVarWrapping, start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.multiVar, useTrailing : false, overrideAdditionalIndent : null},"markMultiVarChaining");
		}
	}
	,__class__: formatter_marker_wrapping_MarkWrapping
});
var formatter_marker_wrapping_WrappingOrigin = $hxEnums["formatter.marker.wrapping.WrappingOrigin"] = { __ename__:"formatter.marker.wrapping.WrappingOrigin",__constructs__:null
	,AnonTypeWrapping: {_hx_name:"AnonTypeWrapping",_hx_index:0,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ArrayWrapping: {_hx_name:"ArrayWrapping",_hx_index:1,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CallParameterWrapping: {_hx_name:"CallParameterWrapping",_hx_index:2,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CasePatternWrapping: {_hx_name:"CasePatternWrapping",_hx_index:3,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,FunctionSignatureWrapping: {_hx_name:"FunctionSignatureWrapping",_hx_index:4,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ImplementsWrapping: {_hx_name:"ImplementsWrapping",_hx_index:5,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MetadataCallParameterWrapping: {_hx_name:"MetadataCallParameterWrapping",_hx_index:6,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MethodChainWrapping: {_hx_name:"MethodChainWrapping",_hx_index:7,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MultiVarWrapping: {_hx_name:"MultiVarWrapping",_hx_index:8,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpAddChainWrapping: {_hx_name:"OpAddChainWrapping",_hx_index:9,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpBoolChainWrapping: {_hx_name:"OpBoolChainWrapping",_hx_index:10,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,TypeParameterWrapping: {_hx_name:"TypeParameterWrapping",_hx_index:11,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
};
formatter_marker_wrapping_WrappingOrigin.__constructs__ = [formatter_marker_wrapping_WrappingOrigin.AnonTypeWrapping,formatter_marker_wrapping_WrappingOrigin.ArrayWrapping,formatter_marker_wrapping_WrappingOrigin.CallParameterWrapping,formatter_marker_wrapping_WrappingOrigin.CasePatternWrapping,formatter_marker_wrapping_WrappingOrigin.FunctionSignatureWrapping,formatter_marker_wrapping_WrappingOrigin.ImplementsWrapping,formatter_marker_wrapping_WrappingOrigin.MetadataCallParameterWrapping,formatter_marker_wrapping_WrappingOrigin.MethodChainWrapping,formatter_marker_wrapping_WrappingOrigin.MultiVarWrapping,formatter_marker_wrapping_WrappingOrigin.OpAddChainWrapping,formatter_marker_wrapping_WrappingOrigin.OpBoolChainWrapping,formatter_marker_wrapping_WrappingOrigin.TypeParameterWrapping];
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.exceptionStack = function(fullStack) {
	if(fullStack == null) {
		fullStack = false;
	}
	var eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
	return fullStack ? eStack : haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var j = _g++;
			if(haxe_CallStack.equalItems(this1[i],stack[j])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				var m2 = item2.m;
				var m1 = item1.m;
				return m1 == m2;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				var item21 = item2.s;
				var file2 = item2.file;
				var line2 = item2.line;
				var col2 = item2.column;
				var col1 = item1.column;
				var line1 = item1.line;
				var file1 = item1.file;
				var item11 = item1.s;
				if(file1 == file2 && line1 == line2 && col1 == col2) {
					return haxe_CallStack.equalItems(item11,item21);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				var class2 = item2.classname;
				var method2 = item2.method;
				var method1 = item1.method;
				var class1 = item1.classname;
				if(class1 == class2) {
					return method1 == method2;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				var v2 = item2.v;
				var v1 = item1.v;
				return v1 == v2;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var s1 = s.s;
		var file = s.file;
		var line = s.line;
		var col = s.column;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var cname = s.classname;
		var meth = s.method;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
	this.__skipStack = 0;
	var old = Error.prepareStackTrace;
	Error.prepareStackTrace = function(e) { return e.stack; }
	if(((native) instanceof Error)) {
		this.stack = native.stack;
	} else {
		var e = null;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,haxe_Exception);
			e = this;
		} else {
			e = new Error();
			if(typeof(e.stack) == "undefined") {
				try { throw e; } catch(_) {}
				this.__skipStack++;
			}
		}
		this.stack = e.stack;
	}
	Error.prepareStackTrace = old;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		e.__skipStack++;
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,__shiftStack: function() {
		this.__skipStack++;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,get_stack: function() {
		var _g = this.__exceptionStack;
		if(_g == null) {
			var value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			var s = _g;
			return s;
		}
	}
	,setProperty: function(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	,__class__: haxe_Exception
});
var haxe_NativeStackTrace = function() { };
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.saveStack = function(e) {
	haxe_NativeStackTrace.lastError = e;
};
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.exceptionStack = function() {
	return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Serializer = function() {
	this.buf = new StringBuf();
	this.cache = [];
	this.useCache = haxe_Serializer.USE_CACHE;
	this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
	this.shash = new haxe_ds_StringMap();
	this.scount = 0;
};
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = "haxe.Serializer";
haxe_Serializer.prototype = {
	toString: function() {
		return this.buf.b;
	}
	,serializeString: function(s) {
		var x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g = 0;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		var _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			var v1 = v;
			if(isNaN(v1)) {
				this.buf.b += "k";
			} else if(!isFinite(v1)) {
				this.buf.b += v1 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v1 == null ? "null" : "" + v1;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				var className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			var c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.b += "a";
				var l = v["length"];
				var _g1 = 0;
				var _g2 = l;
				while(_g1 < _g2) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				var d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v1.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				var v1 = v;
				var _g_head = v1.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					var id = Reflect.field(k1,"__id__");
					Reflect.deleteField(k1,"__id__");
					this.serialize(k1);
					k1["__id__"] = id;
					this.serialize(v1.h[k1.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				var v1 = v;
				var h = v1.h;
				var _g_h = h;
				var _g_keys = Object.keys(h);
				var _g_length = _g_keys.length;
				var _g_current = 0;
				while(_g_current < _g_length) {
					var k = _g_keys[_g_current++];
					this.serializeString(k);
					this.serialize(v1.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				var v1 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v1.length * 8 / 6));
				this.buf.b += ":";
				var i = 0;
				var max = v1.length - 2;
				var b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					var this1 = new Array(haxe_Serializer.BASE64.length);
					b64 = this1;
					var _g1 = 0;
					var _g2 = haxe_Serializer.BASE64.length;
					while(_g1 < _g2) {
						var i1 = _g1++;
						b64[i1] = HxOverrides.cca(haxe_Serializer.BASE64,i1);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					var b3 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					var b1 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				var e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
			}
			this.buf.b += ":";
			var params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			var _g = 0;
			while(_g < params.length) {
				var p = params[_g];
				++_g;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
	,__class__: haxe_Serializer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return $hxClasses[name];
	}
	,resolveEnum: function(name) {
		return $hxEnums[name];
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = this.buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = haxe_Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.prototype = {
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			var name = this.unserialize();
			var e = this.resolver.resolveEnum(name);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			return e;
		case 67:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				var value = this.unserialize();
				h.h[s] = value;
			}
			this.pos++;
			return h;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			this.pos++;
			var index = this.readDigits();
			var _this = edecl.__constructs__;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i]._hx_name;
			}
			var tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name + "@" + index);
			}
			var e = this.unserializeEnum(edecl,tag);
			this.cache.push(e);
			return e;
		case 107:
			return NaN;
		case 108:
			var l = new haxe_ds_List();
			this.cache.push(l);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 112:
			return Infinity;
		case 113:
			var h = new haxe_ds_IntMap();
			this.cache.push(h);
			var buf = this.buf;
			var c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				var i = this.readDigits();
				var value = this.unserialize();
				h.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h;
		case 114:
			var n = this.readDigits();
			if(n < 0 || n >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n];
		case 115:
			var len = this.readDigits();
			var buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i < max) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				var c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				var c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					var c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			var len = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
	this.__skipStack++;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds__$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["haxe.ds._List.ListIterator"] = haxe_ds__$List_ListIterator;
haxe_ds__$List_ListIterator.__name__ = "haxe.ds._List.ListIterator";
haxe_ds__$List_ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: haxe_ds__$List_ListIterator
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_http_HttpBase = function(url) {
	this.url = url;
	this.headers = [];
	this.params = [];
	this.emptyOnData = $bind(this,this.onData);
};
$hxClasses["haxe.http.HttpBase"] = haxe_http_HttpBase;
haxe_http_HttpBase.__name__ = "haxe.http.HttpBase";
haxe_http_HttpBase.prototype = {
	setHeader: function(name,value) {
		var _g = 0;
		var _g1 = this.headers.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.headers[i].name == name) {
				this.headers[i] = { name : name, value : value};
				return this;
			}
		}
		this.headers.push({ name : name, value : value});
		return this;
	}
	,setParameter: function(name,value) {
		var _g = 0;
		var _g1 = this.params.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.params[i].name == name) {
				this.params[i] = { name : name, value : value};
				return this;
			}
		}
		this.params.push({ name : name, value : value});
		return this;
	}
	,onData: function(data) {
	}
	,onBytes: function(data) {
	}
	,onError: function(msg) {
	}
	,onStatus: function(status) {
	}
	,hasOnData: function() {
		return !Reflect.compareMethods($bind(this,this.onData),this.emptyOnData);
	}
	,success: function(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	,get_responseData: function() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
	,__class__: haxe_http_HttpBase
};
var haxe_http_HttpJs = function(url) {
	this.async = true;
	this.withCredentials = false;
	haxe_http_HttpBase.call(this,url);
};
$hxClasses["haxe.http.HttpJs"] = haxe_http_HttpJs;
haxe_http_HttpJs.__name__ = "haxe.http.HttpJs";
haxe_http_HttpJs.__super__ = haxe_http_HttpBase;
haxe_http_HttpJs.prototype = $extend(haxe_http_HttpBase.prototype,{
	request: function(post) {
		var _gthis = this;
		this.responseAsString = null;
		this.responseBytes = null;
		var r = this.req = js_Browser.createXMLHttpRequest();
		var onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			var s;
			try {
				s = r.status;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				s = null;
			}
			if(s == 0 && js_Browser.get_supported() && $global.location != null) {
				var protocol = $global.location.protocol.toLowerCase();
				var rlocalProtocol = new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","");
				var isLocal = rlocalProtocol.match(protocol);
				if(isLocal) {
					s = r.response != null ? 200 : 404;
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				_gthis.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				_gthis.req = null;
				_gthis.success(haxe_io_Bytes.ofData(r.response));
			} else if(s == null || s == 0 && r.response == null) {
				_gthis.req = null;
				_gthis.onError("Failed to connect or resolve host");
			} else if(s == null) {
				_gthis.req = null;
				var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
				_gthis.responseBytes = onreadystatechange;
				_gthis.onError("Http Error #" + r.status);
			} else {
				switch(s) {
				case 12007:
					_gthis.req = null;
					_gthis.onError("Unknown host");
					break;
				case 12029:
					_gthis.req = null;
					_gthis.onError("Failed to connect to host");
					break;
				default:
					_gthis.req = null;
					var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
					_gthis.responseBytes = onreadystatechange;
					_gthis.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		var uri;
		var _g = this.postData;
		var _g1 = this.postBytes;
		if(_g == null) {
			if(_g1 == null) {
				uri = null;
			} else {
				var bytes = _g1;
				uri = new Blob([bytes.b.bufferValue]);
			}
		} else if(_g1 == null) {
			var str = _g;
			uri = str;
		} else {
			uri = null;
		}
		if(uri != null) {
			post = true;
		} else {
			var _g = 0;
			var _g1 = this.params;
			while(_g < _g1.length) {
				var p = _g1[_g];
				++_g;
				if(uri == null) {
					uri = "";
				} else {
					uri = (uri == null ? "null" : Std.string(uri)) + "&";
				}
				var s = p.name;
				var value = (uri == null ? "null" : Std.string(uri)) + encodeURIComponent(s) + "=";
				var s1 = p.value;
				uri = value + encodeURIComponent(s1);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				var question = this.url.split("?").length <= 1;
				r.open("GET",this.url + (question ? "?" : "&") + (uri == null ? "null" : Std.string(uri)),this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
			r.responseType = "arraybuffer";
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var e = haxe_Exception.caught(_g).unwrap();
			this.req = null;
			this.onError(e.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.name == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		var _g = 0;
		var _g1 = this.headers;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			r.setRequestHeader(h.name,h.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
	,__class__: haxe_http_HttpJs
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:"haxe.io.Encoding",__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:"haxe.io.Error",__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__:"haxe.macro.StringLiteralKind",__constructs__:null
	,DoubleQuotes: {_hx_name:"DoubleQuotes",_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_name:"SingleQuotes",_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
haxe_macro_StringLiteralKind.__constructs__ = [haxe_macro_StringLiteralKind.DoubleQuotes,haxe_macro_StringLiteralKind.SingleQuotes];
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__:"haxe.macro.Constant",__constructs__:null
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CIdent",$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CRegexp",$_.__params__ = ["r","opt"],$_)
};
haxe_macro_Constant.__constructs__ = [haxe_macro_Constant.CInt,haxe_macro_Constant.CFloat,haxe_macro_Constant.CString,haxe_macro_Constant.CIdent,haxe_macro_Constant.CRegexp];
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:"haxe.macro.Binop",__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:"haxe.macro.Unop",__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__:"haxe.macro.ComplexType",__constructs__:null
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TPath",$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TFunction",$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TAnonymous",$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TParent",$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TExtend",$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TOptional",$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TNamed",$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TIntersection",$_.__params__ = ["tl"],$_)
};
haxe_macro_ComplexType.__constructs__ = [haxe_macro_ComplexType.TPath,haxe_macro_ComplexType.TFunction,haxe_macro_ComplexType.TAnonymous,haxe_macro_ComplexType.TParent,haxe_macro_ComplexType.TExtend,haxe_macro_ComplexType.TOptional,haxe_macro_ComplexType.TNamed,haxe_macro_ComplexType.TIntersection];
var haxe_macro_Printer = function(tabString) {
	if(tabString == null) {
		tabString = "\t";
	}
	this.tabs = "";
	this.tabString = tabString;
};
$hxClasses["haxe.macro.Printer"] = haxe_macro_Printer;
haxe_macro_Printer.__name__ = "haxe.macro.Printer";
haxe_macro_Printer.prototype = {
	printUnop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		case 5:
			return "...";
		}
	}
	,printBinop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			var op1 = op.op;
			return this.printBinop(op1) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
	,__class__: haxe_macro_Printer
};
var haxe_remoting_AsyncConnection = function() { };
$hxClasses["haxe.remoting.AsyncConnection"] = haxe_remoting_AsyncConnection;
haxe_remoting_AsyncConnection.__name__ = "haxe.remoting.AsyncConnection";
haxe_remoting_AsyncConnection.__isInterface__ = true;
haxe_remoting_AsyncConnection.prototype = {
	__class__: haxe_remoting_AsyncConnection
};
var haxe_remoting_AsyncProxy = function(c) {
	this.__cnx = c;
};
$hxClasses["haxe.remoting.AsyncProxy"] = haxe_remoting_AsyncProxy;
haxe_remoting_AsyncProxy.__name__ = "haxe.remoting.AsyncProxy";
haxe_remoting_AsyncProxy.prototype = {
	__class__: haxe_remoting_AsyncProxy
};
var haxe_remoting_HttpAsyncConnection = function(data,path) {
	this.__data = data;
	this.__path = path;
};
$hxClasses["haxe.remoting.HttpAsyncConnection"] = haxe_remoting_HttpAsyncConnection;
haxe_remoting_HttpAsyncConnection.__name__ = "haxe.remoting.HttpAsyncConnection";
haxe_remoting_HttpAsyncConnection.__interfaces__ = [haxe_remoting_AsyncConnection];
haxe_remoting_HttpAsyncConnection.urlConnect = function(url) {
	return new haxe_remoting_HttpAsyncConnection({ url : url, error : function(e) {
		throw haxe_Exception.thrown(e);
	}},[]);
};
haxe_remoting_HttpAsyncConnection.prototype = {
	resolve: function(name) {
		var c = new haxe_remoting_HttpAsyncConnection(this.__data,this.__path.slice());
		c.__path.push(name);
		return c;
	}
	,setErrorHandler: function(h) {
		this.__data.error = h;
	}
	,call: function(params,onResult) {
		var h = new haxe_http_HttpJs(this.__data.url);
		var s = new haxe_Serializer();
		s.serialize(this.__path);
		s.serialize(params);
		h.setHeader("X-Haxe-Remoting","1");
		h.setParameter("__x",s.toString());
		var error = this.__data.error;
		h.onData = function(response) {
			var ok = true;
			var ret;
			try {
				if(HxOverrides.substr(response,0,3) != "hxr") {
					throw haxe_Exception.thrown("Invalid response : '" + response + "'");
				}
				var s = new haxe_Unserializer(HxOverrides.substr(response,3,null));
				ret = s.unserialize();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				var err = haxe_Exception.caught(_g).unwrap();
				ret = null;
				ok = false;
				error(err);
			}
			if(ok && onResult != null) {
				onResult(ret);
			}
		};
		h.onError = error;
		h.request(true);
	}
	,__class__: haxe_remoting_HttpAsyncConnection
};
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__:"haxeparser.Keyword",__constructs__:null
	,KwdFunction: {_hx_name:"KwdFunction",_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_name:"KwdClass",_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_name:"KwdVar",_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_name:"KwdIf",_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_name:"KwdElse",_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_name:"KwdWhile",_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_name:"KwdDo",_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_name:"KwdFor",_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_name:"KwdBreak",_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_name:"KwdContinue",_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_name:"KwdReturn",_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_name:"KwdExtends",_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_name:"KwdImplements",_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_name:"KwdImport",_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_name:"KwdSwitch",_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_name:"KwdCase",_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_name:"KwdDefault",_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_name:"KwdStatic",_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_name:"KwdPublic",_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_name:"KwdPrivate",_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_name:"KwdTry",_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_name:"KwdCatch",_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_name:"KwdNew",_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_name:"KwdThis",_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_name:"KwdThrow",_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_name:"KwdExtern",_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_name:"KwdEnum",_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_name:"KwdInterface",_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_name:"KwdUntyped",_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_name:"KwdCast",_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_name:"KwdOverride",_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_name:"KwdTypedef",_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_name:"KwdDynamic",_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_name:"KwdPackage",_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_name:"KwdInline",_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_name:"KwdUsing",_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_name:"KwdNull",_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_name:"KwdTrue",_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_name:"KwdFalse",_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_name:"KwdAbstract",_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_name:"KwdMacro",_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_name:"KwdFinal",_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOperator: {_hx_name:"KwdOperator",_hx_index:42,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverload: {_hx_name:"KwdOverload",_hx_index:43,__enum__:"haxeparser.Keyword",toString:$estr}
};
haxeparser_Keyword.__constructs__ = [haxeparser_Keyword.KwdFunction,haxeparser_Keyword.KwdClass,haxeparser_Keyword.KwdVar,haxeparser_Keyword.KwdIf,haxeparser_Keyword.KwdElse,haxeparser_Keyword.KwdWhile,haxeparser_Keyword.KwdDo,haxeparser_Keyword.KwdFor,haxeparser_Keyword.KwdBreak,haxeparser_Keyword.KwdContinue,haxeparser_Keyword.KwdReturn,haxeparser_Keyword.KwdExtends,haxeparser_Keyword.KwdImplements,haxeparser_Keyword.KwdImport,haxeparser_Keyword.KwdSwitch,haxeparser_Keyword.KwdCase,haxeparser_Keyword.KwdDefault,haxeparser_Keyword.KwdStatic,haxeparser_Keyword.KwdPublic,haxeparser_Keyword.KwdPrivate,haxeparser_Keyword.KwdTry,haxeparser_Keyword.KwdCatch,haxeparser_Keyword.KwdNew,haxeparser_Keyword.KwdThis,haxeparser_Keyword.KwdThrow,haxeparser_Keyword.KwdExtern,haxeparser_Keyword.KwdEnum,haxeparser_Keyword.KwdInterface,haxeparser_Keyword.KwdUntyped,haxeparser_Keyword.KwdCast,haxeparser_Keyword.KwdOverride,haxeparser_Keyword.KwdTypedef,haxeparser_Keyword.KwdDynamic,haxeparser_Keyword.KwdPackage,haxeparser_Keyword.KwdInline,haxeparser_Keyword.KwdUsing,haxeparser_Keyword.KwdNull,haxeparser_Keyword.KwdTrue,haxeparser_Keyword.KwdFalse,haxeparser_Keyword.KwdAbstract,haxeparser_Keyword.KwdMacro,haxeparser_Keyword.KwdFinal,haxeparser_Keyword.KwdOperator,haxeparser_Keyword.KwdOverload];
var haxeparser_KeywordPrinter = function() { };
$hxClasses["haxeparser.KeywordPrinter"] = haxeparser_KeywordPrinter;
haxeparser_KeywordPrinter.__name__ = "haxeparser.KeywordPrinter";
haxeparser_KeywordPrinter.toString = function(kwd) {
	switch(kwd._hx_index) {
	case 0:
		return "function";
	case 1:
		return "class";
	case 2:
		return "var";
	case 3:
		return "if";
	case 4:
		return "else";
	case 5:
		return "while";
	case 6:
		return "do";
	case 7:
		return "for";
	case 8:
		return "break";
	case 9:
		return "continue";
	case 10:
		return "return";
	case 11:
		return "extends";
	case 12:
		return "implements";
	case 13:
		return "import";
	case 14:
		return "switch";
	case 15:
		return "case";
	case 16:
		return "default";
	case 17:
		return "static";
	case 18:
		return "public";
	case 19:
		return "private";
	case 20:
		return "try";
	case 21:
		return "catch";
	case 22:
		return "new";
	case 23:
		return "this";
	case 24:
		return "throw";
	case 25:
		return "extern";
	case 26:
		return "enum";
	case 27:
		return "interface";
	case 28:
		return "untyped";
	case 29:
		return "cast";
	case 30:
		return "override";
	case 31:
		return "typedef";
	case 32:
		return "dynamic";
	case 33:
		return "package";
	case 34:
		return "inline";
	case 35:
		return "using";
	case 36:
		return "null";
	case 37:
		return "true";
	case 38:
		return "false";
	case 39:
		return "abstract";
	case 40:
		return "macro";
	case 41:
		return "final";
	case 42:
		return "operator";
	case 43:
		return "overload";
	}
};
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__:"haxeparser.TokenDef",__constructs__:null
	,Kwd: ($_=function(k) { return {_hx_index:0,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Kwd",$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Sharp",$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Dollar",$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:4,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Unop",$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Binop",$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Comment",$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="CommentLine",$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="IntInterval",$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_name:"Semicolon",_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_name:"DblDot",_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_name:"BkOpen",_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_name:"BkClose",_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_name:"BrOpen",_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_name:"BrClose",_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_name:"POpen",_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_name:"PClose",_hx_index:19,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Question: {_hx_name:"Question",_hx_index:20,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_name:"At",_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
};
haxeparser_TokenDef.__constructs__ = [haxeparser_TokenDef.Kwd,haxeparser_TokenDef.Const,haxeparser_TokenDef.Sharp,haxeparser_TokenDef.Dollar,haxeparser_TokenDef.Unop,haxeparser_TokenDef.Binop,haxeparser_TokenDef.Comment,haxeparser_TokenDef.CommentLine,haxeparser_TokenDef.IntInterval,haxeparser_TokenDef.Semicolon,haxeparser_TokenDef.Dot,haxeparser_TokenDef.DblDot,haxeparser_TokenDef.Arrow,haxeparser_TokenDef.Comma,haxeparser_TokenDef.BkOpen,haxeparser_TokenDef.BkClose,haxeparser_TokenDef.BrOpen,haxeparser_TokenDef.BrClose,haxeparser_TokenDef.POpen,haxeparser_TokenDef.PClose,haxeparser_TokenDef.Question,haxeparser_TokenDef.At,haxeparser_TokenDef.Eof];
var haxeparser_TokenDefPrinter = function() { };
$hxClasses["haxeparser.TokenDefPrinter"] = haxeparser_TokenDefPrinter;
haxeparser_TokenDefPrinter.__name__ = "haxeparser.TokenDefPrinter";
haxeparser_TokenDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		var k = def.k;
		return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index]._hx_name,3,null).toLowerCase();
	case 1:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			var s = _g.v;
			return s;
		case 1:
			var s = _g.f;
			return s;
		case 2:
			var _g1 = _g.kind;
			var s = _g.s;
			return "\"" + s + "\"";
		case 3:
			var s = _g.s;
			return s;
		case 4:
			var r = _g.r;
			var opt = _g.opt;
			return "~/" + r + "/" + opt;
		}
		break;
	case 2:
		var s = def.s;
		return "#" + s;
	case 3:
		var s = def.s;
		return "$" + s;
	case 4:
		var op = def.op;
		return new haxe_macro_Printer("").printUnop(op);
	case 5:
		var op = def.op;
		return new haxe_macro_Printer("").printBinop(op);
	case 6:
		var s = def.s;
		return "/*" + s + "*/";
	case 7:
		var s = def.s;
		return "//" + s;
	case 8:
		var s = def.s;
		return "" + s + "...";
	case 9:
		return ";";
	case 10:
		return ".";
	case 11:
		return ":";
	case 12:
		return "->";
	case 13:
		return ",";
	case 14:
		return "[";
	case 15:
		return "]";
	case 16:
		return "{";
	case 17:
		return "}";
	case 18:
		return "(";
	case 19:
		return ")";
	case 20:
		return "?";
	case 21:
		return "@";
	case 22:
		return "<eof>";
	}
};
haxeparser_TokenDefPrinter.print = function(def) {
	return haxeparser_TokenDefPrinter.toString(def);
};
var haxeparser_Token = function(tok,pos) {
	this.tok = tok;
	this.pos = pos;
};
$hxClasses["haxeparser.Token"] = haxeparser_Token;
haxeparser_Token.__name__ = "haxeparser.Token";
haxeparser_Token.prototype = {
	toString: function() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
	,__class__: haxeparser_Token
};
var haxeparser_TypeDef = $hxEnums["haxeparser.TypeDef"] = { __ename__:"haxeparser.TypeDef",__constructs__:null
	,EClass: ($_=function(d) { return {_hx_index:0,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EClass",$_.__params__ = ["d"],$_)
	,EEnum: ($_=function(d) { return {_hx_index:1,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EEnum",$_.__params__ = ["d"],$_)
	,ETypedef: ($_=function(d) { return {_hx_index:2,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="ETypedef",$_.__params__ = ["d"],$_)
	,EAbstract: ($_=function(a) { return {_hx_index:3,a:a,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EAbstract",$_.__params__ = ["a"],$_)
	,EStatic: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EStatic",$_.__params__ = ["s"],$_)
	,EImport: ($_=function(sl,mode) { return {_hx_index:5,sl:sl,mode:mode,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EImport",$_.__params__ = ["sl","mode"],$_)
	,EUsing: ($_=function(path) { return {_hx_index:6,path:path,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_._hx_name="EUsing",$_.__params__ = ["path"],$_)
};
haxeparser_TypeDef.__constructs__ = [haxeparser_TypeDef.EClass,haxeparser_TypeDef.EEnum,haxeparser_TypeDef.ETypedef,haxeparser_TypeDef.EAbstract,haxeparser_TypeDef.EStatic,haxeparser_TypeDef.EImport,haxeparser_TypeDef.EUsing];
var haxeparser_ClassFlag = $hxEnums["haxeparser.ClassFlag"] = { __ename__:"haxeparser.ClassFlag",__constructs__:null
	,HInterface: {_hx_name:"HInterface",_hx_index:0,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtern: {_hx_name:"HExtern",_hx_index:1,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HPrivate: {_hx_name:"HPrivate",_hx_index:2,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtends: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_._hx_name="HExtends",$_.__params__ = ["t"],$_)
	,HImplements: ($_=function(t) { return {_hx_index:4,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_._hx_name="HImplements",$_.__params__ = ["t"],$_)
	,HFinal: {_hx_name:"HFinal",_hx_index:5,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HAbstract: {_hx_name:"HAbstract",_hx_index:6,__enum__:"haxeparser.ClassFlag",toString:$estr}
};
haxeparser_ClassFlag.__constructs__ = [haxeparser_ClassFlag.HInterface,haxeparser_ClassFlag.HExtern,haxeparser_ClassFlag.HPrivate,haxeparser_ClassFlag.HExtends,haxeparser_ClassFlag.HImplements,haxeparser_ClassFlag.HFinal,haxeparser_ClassFlag.HAbstract];
var haxeparser_AbstractFlag = $hxEnums["haxeparser.AbstractFlag"] = { __ename__:"haxeparser.AbstractFlag",__constructs__:null
	,APrivAbstract: {_hx_name:"APrivAbstract",_hx_index:0,__enum__:"haxeparser.AbstractFlag",toString:$estr}
	,AFromType: ($_=function(ct) { return {_hx_index:1,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_._hx_name="AFromType",$_.__params__ = ["ct"],$_)
	,AToType: ($_=function(ct) { return {_hx_index:2,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_._hx_name="AToType",$_.__params__ = ["ct"],$_)
	,AIsType: ($_=function(ct) { return {_hx_index:3,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_._hx_name="AIsType",$_.__params__ = ["ct"],$_)
	,AExtern: {_hx_name:"AExtern",_hx_index:4,__enum__:"haxeparser.AbstractFlag",toString:$estr}
};
haxeparser_AbstractFlag.__constructs__ = [haxeparser_AbstractFlag.APrivAbstract,haxeparser_AbstractFlag.AFromType,haxeparser_AbstractFlag.AToType,haxeparser_AbstractFlag.AIsType,haxeparser_AbstractFlag.AExtern];
var haxeparser_EnumFlag = $hxEnums["haxeparser.EnumFlag"] = { __ename__:"haxeparser.EnumFlag",__constructs__:null
	,EPrivate: {_hx_name:"EPrivate",_hx_index:0,__enum__:"haxeparser.EnumFlag",toString:$estr}
	,EExtern: {_hx_name:"EExtern",_hx_index:1,__enum__:"haxeparser.EnumFlag",toString:$estr}
};
haxeparser_EnumFlag.__constructs__ = [haxeparser_EnumFlag.EPrivate,haxeparser_EnumFlag.EExtern];
var haxeparser_StaticFlag = $hxEnums["haxeparser.StaticFlag"] = { __ename__:"haxeparser.StaticFlag",__constructs__:null
	,SDynamic: {_hx_name:"SDynamic",_hx_index:0,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SFinal: {_hx_name:"SFinal",_hx_index:1,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SInline: {_hx_name:"SInline",_hx_index:2,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SMacro: {_hx_name:"SMacro",_hx_index:3,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SPrivate: {_hx_name:"SPrivate",_hx_index:4,__enum__:"haxeparser.StaticFlag",toString:$estr}
	,SOverload: {_hx_name:"SOverload",_hx_index:5,__enum__:"haxeparser.StaticFlag",toString:$estr}
};
haxeparser_StaticFlag.__constructs__ = [haxeparser_StaticFlag.SDynamic,haxeparser_StaticFlag.SFinal,haxeparser_StaticFlag.SInline,haxeparser_StaticFlag.SMacro,haxeparser_StaticFlag.SPrivate,haxeparser_StaticFlag.SOverload];
var haxeparser_ImportMode = $hxEnums["haxeparser.ImportMode"] = { __ename__:"haxeparser.ImportMode",__constructs__:null
	,INormal: {_hx_name:"INormal",_hx_index:0,__enum__:"haxeparser.ImportMode",toString:$estr}
	,IAsName: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"haxeparser.ImportMode",toString:$estr}; },$_._hx_name="IAsName",$_.__params__ = ["s"],$_)
	,IAll: {_hx_name:"IAll",_hx_index:2,__enum__:"haxeparser.ImportMode",toString:$estr}
};
haxeparser_ImportMode.__constructs__ = [haxeparser_ImportMode.INormal,haxeparser_ImportMode.IAsName,haxeparser_ImportMode.IAll];
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__:"haxeparser.LexerErrorMsg",__constructs__:null
	,UnterminatedString: {_hx_name:"UnterminatedString",_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_name:"UnterminatedRegExp",_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_name:"UnclosedComment",_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_name:"UnterminatedEscapeSequence",_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_._hx_name="InvalidEscapeSequence",$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_._hx_name="UnknownEscapeSequence",$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_name:"UnclosedCode",_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
haxeparser_LexerErrorMsg.__constructs__ = [haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,haxeparser_LexerErrorMsg.InvalidEscapeSequence,haxeparser_LexerErrorMsg.UnknownEscapeSequence,haxeparser_LexerErrorMsg.UnclosedCode];
var haxeparser_LexerError = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
$hxClasses["haxeparser.LexerError"] = haxeparser_LexerError;
haxeparser_LexerError.__name__ = "haxeparser.LexerError";
haxeparser_LexerError.prototype = {
	__class__: haxeparser_LexerError
};
var hxparse_Lexer = function(input,sourceName) {
	if(sourceName == null) {
		sourceName = "<null>";
	}
	this.current = "";
	this.input = input;
	this.source = sourceName;
	this.pos = 0;
};
$hxClasses["hxparse.Lexer"] = hxparse_Lexer;
hxparse_Lexer.__name__ = "hxparse.Lexer";
hxparse_Lexer.buildRuleset = function(rules,name) {
	if(name == null) {
		name = "";
	}
	var cases = [];
	var functions = [];
	var eofFunction = null;
	var _g = 0;
	while(_g < rules.length) {
		var rule = rules[_g];
		++_g;
		if(rule.rule == "") {
			eofFunction = rule.func;
		} else {
			cases.push(hxparse_LexEngine.parse(rule.rule));
			functions.push(rule.func);
		}
	}
	return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
};
hxparse_Lexer.prototype = {
	curPos: function() {
		return new hxparse_Position(this.source,this.pos - this.current.length,this.pos);
	}
	,token: function(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
		}
		var state = ruleset.state;
		var lastMatch = null;
		var lastMatchPos = this.pos;
		var start = this.pos;
		while(true) {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			var i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
			if(state == null) {
				break;
			}
		}
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			var code = this.input.b[this.pos];
			throw haxe_Exception.thrown(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
	,__class__: hxparse_Lexer
};
var hxparse_RuleBuilder = function() { };
$hxClasses["hxparse.RuleBuilder"] = hxparse_RuleBuilder;
hxparse_RuleBuilder.__name__ = "hxparse.RuleBuilder";
hxparse_RuleBuilder.__isInterface__ = true;
var hxparse__$LexEngine_CharRange = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["hxparse._LexEngine.CharRange"] = hxparse__$LexEngine_CharRange;
hxparse__$LexEngine_CharRange.__name__ = "hxparse._LexEngine.CharRange";
hxparse__$LexEngine_CharRange.prototype = {
	__class__: hxparse__$LexEngine_CharRange
};
var hxparse_LexEngine = function(patterns) {
	this.nodes = [];
	this.finals = [];
	this.states = [];
	this.hstates = new haxe_ds_StringMap();
	this.uid = 0;
	var pid = 0;
	var _g = 0;
	while(_g < patterns.length) {
		var p = patterns[_g];
		++_g;
		var id = pid++;
		var f = new hxparse__$LexEngine_Node(this.uid++,id);
		var n = this.initNode(p,f,id);
		this.nodes.push(n);
		this.finals.push(f);
	}
	this.makeState(this.addNodes([],this.nodes));
};
$hxClasses["hxparse.LexEngine"] = hxparse_LexEngine;
hxparse_LexEngine.__name__ = "hxparse.LexEngine";
hxparse_LexEngine.single = function(c) {
	return [new hxparse__$LexEngine_CharRange(c,c)];
};
hxparse_LexEngine.parse = function(pattern) {
	var this1 = haxe_io_Bytes.ofString(pattern);
	var p = hxparse_LexEngine.parseInner(this1);
	if(p == null) {
		throw haxe_Exception.thrown("Invalid pattern '" + pattern + "'");
	}
	return p.pattern;
};
hxparse_LexEngine.next = function(a,b) {
	if(a == hxparse__$LexEngine_Pattern.Empty) {
		return b;
	} else {
		return hxparse__$LexEngine_Pattern.Next(a,b);
	}
};
hxparse_LexEngine.plus = function(r) {
	if(r._hx_index == 4) {
		var r1 = r.p1;
		var r2 = r.p2;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.plus(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Plus(r);
	}
};
hxparse_LexEngine.star = function(r) {
	if(r._hx_index == 4) {
		var r1 = r.p1;
		var r2 = r.p2;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.star(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Star(r);
	}
};
hxparse_LexEngine.opt = function(r) {
	if(r._hx_index == 4) {
		var r1 = r.p1;
		var r2 = r.p2;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.opt(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
	}
};
hxparse_LexEngine.cinter = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
};
hxparse_LexEngine.cdiff = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
};
hxparse_LexEngine.ccomplement = function(c) {
	var first = c[0];
	var start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
	var out = [];
	var _g = 0;
	while(_g < c.length) {
		var k = c[_g];
		++_g;
		out.push(new hxparse__$LexEngine_CharRange(start,k.min - 1));
		start = k.max + 1;
	}
	if(start <= 255) {
		out.push(new hxparse__$LexEngine_CharRange(start,255));
	}
	return out;
};
hxparse_LexEngine.cunion = function(ca,cb) {
	var i = 0;
	var j = 0;
	var out = [];
	var a = ca[i++];
	var b = cb[j++];
	while(true) {
		if(a == null) {
			out.push(b);
			while(j < cb.length) out.push(cb[j++]);
			break;
		}
		if(b == null) {
			out.push(a);
			while(i < ca.length) out.push(ca[i++]);
			break;
		}
		if(a.min <= b.min) {
			if(a.max + 1 < b.min) {
				out.push(a);
				a = ca[i++];
			} else if(a.max < b.max) {
				b = new hxparse__$LexEngine_CharRange(a.min,b.max);
				a = ca[i++];
			} else {
				b = cb[j++];
			}
		} else {
			var tmp = ca;
			ca = cb;
			cb = tmp;
			var tmp1 = j;
			j = i;
			i = tmp1;
			var tmp2 = a;
			a = b;
			b = tmp2;
		}
	}
	return out;
};
hxparse_LexEngine.parseInner = function(pattern,i,pDepth) {
	if(pDepth == null) {
		pDepth = 0;
	}
	if(i == null) {
		i = 0;
	}
	var readChar = function() {
		i += 1;
		var c = pattern.b[i - 1];
		if(c != c) {
			c = 92;
		} else if(c == 120) {
			c = Std.parseInt("0x" + pattern.getString(i,2));
			i += 2;
		} else if(c >= 48 && c <= 57) {
			var v = c - 48;
			while(true) {
				var cNext = pattern.b[i];
				if(cNext >= 48 && cNext <= 57) {
					v = v * 10 + (cNext - 48);
					i += 1;
				} else {
					break;
				}
			}
			c = v;
		}
		return c;
	};
	var r = hxparse__$LexEngine_Pattern.Empty;
	var l = pattern.length;
	while(i < l) {
		i += 1;
		var c = pattern.b[i - 1];
		if(c > 255) {
			throw haxe_Exception.thrown(c);
		}
		switch(c) {
		case 40:
			var r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
			i = r2.pos;
			r = hxparse_LexEngine.next(r,r2.pattern);
			break;
		case 41:
			if(r == hxparse__$LexEngine_Pattern.Empty) {
				throw haxe_Exception.thrown("Empty group");
			}
			return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
		case 42:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.star(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 43:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.plus(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 46:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
			break;
		case 63:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.opt(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 91:
			if(pattern.length > 1) {
				var range = 0;
				var acc = [];
				var not = pattern.b[i] == 94;
				if(not) {
					i += 1;
				}
				while(true) {
					i += 1;
					var c1 = pattern.b[i - 1];
					if(c1 == 93) {
						if(range != 0) {
							return null;
						}
						break;
					} else if(c1 == 45) {
						if(range != 0) {
							return null;
						}
						var last = acc.pop();
						if(last == null) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							if(last.min != last.max) {
								return null;
							}
							range = last.min;
						}
					} else {
						if(c1 == 92) {
							c1 = readChar();
						}
						if(range == 0) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							acc.push(new hxparse__$LexEngine_CharRange(range,c1));
							range = 0;
						}
					}
				}
				var g = [];
				var _g = 0;
				while(_g < acc.length) {
					var k = acc[_g];
					++_g;
					g = hxparse_LexEngine.cunion(g,[k]);
				}
				if(not) {
					g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
				}
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 92:
			c = readChar();
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			break;
		case 124:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				var r21 = hxparse_LexEngine.parseInner(pattern,i);
				return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r21.pattern), pos : r21.pos};
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		default:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
		}
	}
	if(pDepth != 0) {
		throw haxe_Exception.thrown("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
	}
	return { pattern : r, pos : i};
};
hxparse_LexEngine.prototype = {
	firstState: function() {
		return this.states[0];
	}
	,makeState: function(nodes) {
		var _gthis = this;
		var buf_b = "";
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			buf_b += Std.string(n.id);
			buf_b += String.fromCodePoint(45);
		}
		var key = buf_b;
		var s = this.hstates.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		this.hstates.h[key] = s;
		var trans = this.getTransitions(nodes);
		var _g = 0;
		while(_g < trans.length) {
			var t = trans[_g];
			++_g;
			var target = this.makeState(t.n);
			var _g1 = 0;
			var _g2 = t.chars;
			while(_g1 < _g2.length) {
				var chr = _g2[_g1];
				++_g1;
				var _g3 = chr.min;
				var _g4 = chr.max + 1;
				while(_g3 < _g4) {
					var i = _g3++;
					s.trans[i] = target;
				}
			}
		}
		var setFinal = function() {
			var _g = 0;
			var _g1 = _gthis.finals;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				var _g2 = 0;
				while(_g2 < nodes.length) {
					var n = nodes[_g2];
					++_g2;
					if(n == f) {
						s.finalId = n.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	,getTransitions: function(nodes) {
		var tl = [];
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			var _g1 = 0;
			var _g2 = n.trans;
			while(_g1 < _g2.length) {
				var t = _g2[_g1];
				++_g1;
				tl.push(t);
			}
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		var t0 = tl[0];
		var _g = 1;
		var _g1 = tl.length;
		while(_g < _g1) {
			var i = _g++;
			var t1 = tl[i];
			if(t0.n == t1.n) {
				tl[i - 1] = null;
				t1 = { chars : hxparse_LexEngine.cunion(t0.chars,t1.chars), n : t1.n};
				tl[i] = t1;
			}
			t0 = t1;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		var allChars = hxparse_LexEngine.EMPTY;
		var allStates = new haxe_ds_List();
		var _g = 0;
		while(_g < tl.length) {
			var t = tl[_g];
			++_g;
			var states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t.chars,allChars), n : [t.n]});
			var _g3_head = allStates.h;
			while(_g3_head != null) {
				var val = _g3_head.item;
				_g3_head = _g3_head.next;
				var s = val;
				var nodes = s.n.slice();
				nodes.push(t.n);
				states.push({ chars : hxparse_LexEngine.cinter(s.chars,t.chars), n : nodes});
				states.push({ chars : hxparse_LexEngine.cdiff(s.chars,t.chars), n : s.n});
			}
			var _g4_head = states.h;
			while(_g4_head != null) {
				var val1 = _g4_head.item;
				_g4_head = _g4_head.next;
				var s1 = val1;
				if(s1.chars.length == 0) {
					states.remove(s1);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t.chars);
			allStates = states;
		}
		var states = [];
		var _g4_head = allStates.h;
		while(_g4_head != null) {
			var val = _g4_head.item;
			_g4_head = _g4_head.next;
			var s = val;
			states.push({ chars : s.chars, n : this.addNodes([],s.n)});
		}
		states.sort(function(s1,s2) {
			var a = s1.chars.length;
			var b = s2.chars.length;
			var _g = 0;
			var _g1 = a < b ? a : b;
			while(_g < _g1) {
				var i = _g++;
				var a1 = s1.chars[i];
				var b1 = s2.chars[i];
				if(a1.min != b1.min) {
					return b1.min - a1.min;
				}
				if(a1.max != b1.max) {
					return b1.max - a1.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states;
	}
	,addNode: function(nodes,n) {
		var _g = 0;
		while(_g < nodes.length) {
			var n2 = nodes[_g];
			++_g;
			if(n == n2) {
				return;
			}
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	,addNodes: function(nodes,add) {
		var _g = 0;
		while(_g < add.length) {
			var n = add[_g];
			++_g;
			this.addNode(nodes,n);
		}
		return nodes;
	}
	,node: function(pid) {
		return new hxparse__$LexEngine_Node(this.uid++,pid);
	}
	,initNode: function(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			var c = p.c;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : c, n : finalId});
			return n;
		case 2:
			var p1 = p.p;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p1,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return n;
		case 3:
			var p1 = p.p;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p1,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return an;
		case 4:
			var a = p.p1;
			var b = p.p2;
			return this.initNode(a,this.initNode(b,finalId,pid),pid);
		case 5:
			var a = p.p1;
			var b = p.p2;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.epsilon.push(this.initNode(a,finalId,pid));
			n.epsilon.push(this.initNode(b,finalId,pid));
			return n;
		case 6:
			var p1 = p.p;
			return this.initNode(p1,finalId,pid);
		}
	}
	,__class__: hxparse_LexEngine
};
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__:"hxparse._LexEngine.Pattern",__constructs__:null
	,Empty: {_hx_name:"Empty",_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Match",$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Star",$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Plus",$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Next",$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Choice",$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Group",$_.__params__ = ["p"],$_)
};
hxparse__$LexEngine_Pattern.__constructs__ = [hxparse__$LexEngine_Pattern.Empty,hxparse__$LexEngine_Pattern.Match,hxparse__$LexEngine_Pattern.Star,hxparse__$LexEngine_Pattern.Plus,hxparse__$LexEngine_Pattern.Next,hxparse__$LexEngine_Pattern.Choice,hxparse__$LexEngine_Pattern.Group];
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxparse__$LexEngine_Node = function(id,pid) {
	this.id = id;
	this.pid = pid;
	this.trans = [];
	this.epsilon = [];
};
$hxClasses["hxparse._LexEngine.Node"] = hxparse__$LexEngine_Node;
hxparse__$LexEngine_Node.__name__ = "hxparse._LexEngine.Node";
hxparse__$LexEngine_Node.prototype = {
	__class__: hxparse__$LexEngine_Node
};
var hxparse_Ruleset = function(state,functions,eofFunction,name) {
	if(name == null) {
		name = "";
	}
	this.state = state;
	this.functions = functions;
	this.eofFunction = eofFunction;
	this.name = name;
};
$hxClasses["hxparse.Ruleset"] = hxparse_Ruleset;
hxparse_Ruleset.__name__ = "hxparse.Ruleset";
hxparse_Ruleset.prototype = {
	__class__: hxparse_Ruleset
};
var hxparse_Position = function(source,min,max) {
	this.psource = source;
	this.pmin = min;
	this.pmax = max;
};
$hxClasses["hxparse.Position"] = hxparse_Position;
hxparse_Position.__name__ = "hxparse.Position";
hxparse_Position.union = function(p1,p2) {
	return new hxparse_Position(p1.psource,p1.pmin < p2.pmin ? p1.pmin : p2.pmin,p1.pmax > p2.pmax ? p1.pmax : p2.pmax);
};
hxparse_Position.prototype = {
	toString: function() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	,getLinePosition: function(input) {
		var lineMin = 1;
		var lineMax = 1;
		var posMin = 0;
		var posMax = 0;
		var cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	,format: function(input) {
		var linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
	,__class__: hxparse_Position
};
var haxeparser_HaxeLexer = function(input,sourceName) {
	hxparse_Lexer.call(this,input,sourceName);
};
$hxClasses["haxeparser.HaxeLexer"] = haxeparser_HaxeLexer;
haxeparser_HaxeLexer.__name__ = "haxeparser.HaxeLexer";
haxeparser_HaxeLexer.__interfaces__ = [hxparse_RuleBuilder];
haxeparser_HaxeLexer.mkPos = function(p) {
	return { file : p.psource, min : p.pmin, max : p.pmax};
};
haxeparser_HaxeLexer.mk = function(lexer,td) {
	return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
};
haxeparser_HaxeLexer.unescapePos = function(pos,index,length) {
	return { file : pos.file, min : pos.min + index, max : pos.min + index + length};
};
haxeparser_HaxeLexer.unescape = function(s,pos) {
	var b_b = "";
	var i = 0;
	var esc = false;
	while(s.length != i) {
		var c = HxOverrides.cca(s,i);
		if(esc) {
			var iNext = i + 1;
			var _hx_tmp;
			if(c == null) {
				_hx_tmp = c >= 48 && c <= 51;
				if(_hx_tmp == true) {
					iNext += 2;
				} else {
					var c1 = c;
					throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
				}
			} else {
				switch(c) {
				case 34:case 39:case 92:
					b_b += String.fromCodePoint(c);
					break;
				case 110:
					b_b += "\n";
					break;
				case 114:
					b_b += "\r";
					break;
				case 116:
					b_b += "\t";
					break;
				case 117:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c2;
						if(s.charAt(i + 1) == "{") {
							var endIndex = s.indexOf("}",i + 3);
							if(endIndex == -1) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
							}
							var l = endIndex - (i + 2);
							var chars = HxOverrides.substr(s,i + 2,l);
							if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							c2 = Std.parseInt("0x" + chars);
							if(c2 > 1114111) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							iNext += 2 + l;
						} else {
							var chars1 = HxOverrides.substr(s,i + 1,4);
							if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars1)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars1),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
							}
							c2 = Std.parseInt("0x" + chars1);
							iNext += 4;
						}
						b_b += String.fromCodePoint(c2);
					}
					break;
				case 120:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var chars2 = HxOverrides.substr(s,i + 1,2);
						if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars2)) {
							throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars2),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
						}
						var c3 = Std.parseInt("0x" + chars2);
						b_b += String.fromCodePoint(c3);
						iNext += 2;
					}
					break;
				default:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c4 = c;
						throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c4)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				}
			}
			esc = false;
			i = iNext;
		} else if(c == null) {
			b_b += String.fromCodePoint(c);
			++i;
		} else if(c == 92) {
			++i;
			esc = true;
		} else {
			b_b += String.fromCodePoint(c);
			++i;
		}
	}
	return b_b;
};
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
haxeparser_HaxeLexer.prototype = $extend(hxparse_Lexer.prototype,{
	__class__: haxeparser_HaxeLexer
});
var hxjsonast_Error = function(message,pos) {
	this.message = message;
	this.pos = pos;
};
$hxClasses["hxjsonast.Error"] = hxjsonast_Error;
hxjsonast_Error.__name__ = "hxjsonast.Error";
hxjsonast_Error.prototype = {
	__class__: hxjsonast_Error
};
var hxjsonast_Json = function(value,pos) {
	this.value = value;
	this.pos = pos;
};
$hxClasses["hxjsonast.Json"] = hxjsonast_Json;
hxjsonast_Json.__name__ = "hxjsonast.Json";
hxjsonast_Json.prototype = {
	__class__: hxjsonast_Json
};
var hxjsonast_JsonValue = $hxEnums["hxjsonast.JsonValue"] = { __ename__:"hxjsonast.JsonValue",__constructs__:null
	,JString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JString",$_.__params__ = ["s"],$_)
	,JNumber: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JNumber",$_.__params__ = ["s"],$_)
	,JObject: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JObject",$_.__params__ = ["fields"],$_)
	,JArray: ($_=function(values) { return {_hx_index:3,values:values,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JArray",$_.__params__ = ["values"],$_)
	,JBool: ($_=function(b) { return {_hx_index:4,b:b,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JBool",$_.__params__ = ["b"],$_)
	,JNull: {_hx_name:"JNull",_hx_index:5,__enum__:"hxjsonast.JsonValue",toString:$estr}
};
hxjsonast_JsonValue.__constructs__ = [hxjsonast_JsonValue.JString,hxjsonast_JsonValue.JNumber,hxjsonast_JsonValue.JObject,hxjsonast_JsonValue.JArray,hxjsonast_JsonValue.JBool,hxjsonast_JsonValue.JNull];
var hxjsonast_JObjectField = function(name,namePos,value) {
	this.name = name;
	this.namePos = namePos;
	this.value = value;
};
$hxClasses["hxjsonast.JObjectField"] = hxjsonast_JObjectField;
hxjsonast_JObjectField.__name__ = "hxjsonast.JObjectField";
hxjsonast_JObjectField.prototype = {
	__class__: hxjsonast_JObjectField
};
var hxjsonast_Parser = function(source,filename) {
	this.source = source;
	this.filename = filename;
	this.pos = 0;
};
$hxClasses["hxjsonast.Parser"] = hxjsonast_Parser;
hxjsonast_Parser.__name__ = "hxjsonast.Parser";
hxjsonast_Parser.parse = function(source,filename) {
	return new hxjsonast_Parser(source,filename).parseRec();
};
hxjsonast_Parser.prototype = {
	parseRec: function() {
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				var save = this.pos;
				var s = this.parseString();
				return new hxjsonast_Json(hxjsonast_JsonValue.JString(s),new hxjsonast_Position(this.filename,save - 1,this.pos));
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				var start = this.pos - 1;
				var minus = c == 45;
				var digit = !minus;
				var zero = c == 48;
				var point = false;
				var e = false;
				var pm = false;
				var end = false;
				while(true) {
					switch(this.source.charCodeAt(this.pos++)) {
					case 43:case 45:
						if(!e || pm) {
							this.invalidNumber(start);
						}
						digit = false;
						pm = true;
						break;
					case 46:
						if(minus || point) {
							this.invalidNumber(start);
						}
						digit = false;
						point = true;
						break;
					case 48:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
							zero = true;
						}
						digit = true;
						break;
					case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
						}
						digit = true;
						zero = false;
						break;
					case 69:case 101:
						if(minus || zero || e) {
							this.invalidNumber(start);
						}
						digit = false;
						e = true;
						break;
					default:
						if(!digit) {
							this.invalidNumber(start);
						}
						this.pos--;
						end = true;
					}
					if(end) {
						break;
					}
				}
				var s1 = HxOverrides.substr(this.source,start,this.pos - start);
				return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(s1),new hxjsonast_Position(this.filename,start,this.pos));
			case 91:
				var values = [];
				var comma = null;
				var startPos = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 44:
					if(comma) {
						comma = false;
					} else {
						this.invalidChar();
					}
					break;
				case 93:
					if(comma == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JArray(values),new hxjsonast_Position(this.filename,startPos,this.pos));
				default:
					if(comma) {
						this.invalidChar();
					}
					this.pos--;
					values.push(this.parseRec());
					comma = true;
				}
				break;
			case 102:
				var save1 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 97 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 115 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save1;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(false),new hxjsonast_Position(this.filename,save1 - 1,this.pos));
			case 110:
				var save2 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 108) {
					this.pos = save2;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position(this.filename,save2 - 1,this.pos));
			case 116:
				var save3 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 114 || this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save3;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(true),new hxjsonast_Position(this.filename,save3 - 1,this.pos));
			case 123:
				var fields = [];
				var names_h = Object.create(null);
				var field = null;
				var fieldPos = null;
				var comma1 = null;
				var startPos1 = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 34:
					if(comma1) {
						this.invalidChar();
					}
					var fieldStartPos = this.pos - 1;
					field = this.parseString();
					fieldPos = new hxjsonast_Position(this.filename,fieldStartPos,this.pos);
					if(Object.prototype.hasOwnProperty.call(names_h,field)) {
						throw haxe_Exception.thrown(new hxjsonast_Error("Duplicate field name \"" + field + "\"",fieldPos));
					} else {
						names_h[field] = true;
					}
					break;
				case 44:
					if(comma1) {
						comma1 = false;
					} else {
						this.invalidChar();
					}
					break;
				case 58:
					if(field == null) {
						this.invalidChar();
					}
					fields.push(new hxjsonast_JObjectField(field,fieldPos,this.parseRec()));
					field = null;
					fieldPos = null;
					comma1 = true;
					break;
				case 125:
					if(field != null || comma1 == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JObject(fields),new hxjsonast_Position(this.filename,startPos1,this.pos));
				default:
					this.invalidChar();
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	,parseString: function() {
		var start = this.pos;
		var buf = null;
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				var s = this.source;
				var len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.source.charCodeAt(this.pos++);
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					var uc = Std.parseInt("0x" + HxOverrides.substr(this.source,this.pos,4));
					this.pos += 4;
					buf.b += String.fromCodePoint(uc);
					break;
				default:
					throw haxe_Exception.thrown(new hxjsonast_Error("Invalid escape sequence \\" + String.fromCodePoint(c),new hxjsonast_Position(this.filename,this.pos - 2,this.pos)));
				}
				start = this.pos;
			} else if(c != c) {
				this.pos--;
				throw haxe_Exception.thrown(new hxjsonast_Error("Unclosed string",new hxjsonast_Position(this.filename,start - 1,this.pos)));
			}
		}
		if(buf == null) {
			return HxOverrides.substr(this.source,start,this.pos - start - 1);
		} else {
			var s = this.source;
			var len = this.pos - start - 1;
			buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
			return buf.b;
		}
	}
	,parseNumber: function(c) {
		var start = this.pos - 1;
		var minus = c == 45;
		var digit = !minus;
		var zero = c == 48;
		var point = false;
		var e = false;
		var pm = false;
		var end = false;
		while(true) {
			switch(this.source.charCodeAt(this.pos++)) {
			case 43:case 45:
				if(!e || pm) {
					this.invalidNumber(start);
				}
				digit = false;
				pm = true;
				break;
			case 46:
				if(minus || point) {
					this.invalidNumber(start);
				}
				digit = false;
				point = true;
				break;
			case 48:
				if(zero && !point) {
					this.invalidNumber(start);
				}
				if(minus) {
					minus = false;
					zero = true;
				}
				digit = true;
				break;
			case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				if(zero && !point) {
					this.invalidNumber(start);
				}
				if(minus) {
					minus = false;
				}
				digit = true;
				zero = false;
				break;
			case 69:case 101:
				if(minus || zero || e) {
					this.invalidNumber(start);
				}
				digit = false;
				e = true;
				break;
			default:
				if(!digit) {
					this.invalidNumber(start);
				}
				this.pos--;
				end = true;
			}
			if(end) {
				break;
			}
		}
		var s = HxOverrides.substr(this.source,start,this.pos - start);
		return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(s),new hxjsonast_Position(this.filename,start,this.pos));
	}
	,nextChar: function() {
		return this.source.charCodeAt(this.pos++);
	}
	,mk: function(pos,value) {
		return new hxjsonast_Json(value,pos);
	}
	,mkPos: function(min,max) {
		return new hxjsonast_Position(this.filename,min,max);
	}
	,invalidChar: function() {
		this.pos--;
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid character: " + this.source.charAt(this.pos),new hxjsonast_Position(this.filename,this.pos,this.pos + 1)));
	}
	,invalidNumber: function(start) {
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid number: " + this.source.substring(start,this.pos),new hxjsonast_Position(this.filename,start,this.pos)));
	}
	,__class__: hxjsonast_Parser
};
var hxjsonast_Position = function(file,min,max) {
	this.file = file;
	this.min = min;
	this.max = max;
};
$hxClasses["hxjsonast.Position"] = hxjsonast_Position;
hxjsonast_Position.__name__ = "hxjsonast.Position";
hxjsonast_Position.prototype = {
	__class__: hxjsonast_Position
};
var hxparse__$LexEngine_Transition = function(chars) {
	this.chars = chars;
};
$hxClasses["hxparse._LexEngine.Transition"] = hxparse__$LexEngine_Transition;
hxparse__$LexEngine_Transition.__name__ = "hxparse._LexEngine.Transition";
hxparse__$LexEngine_Transition.prototype = {
	toString: function() {
		return Std.string(this.chars);
	}
	,__class__: hxparse__$LexEngine_Transition
};
var hxparse_ParserError = function(pos) {
	this.pos = pos;
};
$hxClasses["hxparse.ParserError"] = hxparse_ParserError;
hxparse_ParserError.__name__ = "hxparse.ParserError";
hxparse_ParserError.prototype = {
	toString: function() {
		return "Parser error";
	}
	,__class__: hxparse_ParserError
};
var hxparse_RuleBuilderImpl = function() { };
$hxClasses["hxparse.RuleBuilderImpl"] = hxparse_RuleBuilderImpl;
hxparse_RuleBuilderImpl.__name__ = "hxparse.RuleBuilderImpl";
var hxparse_State = function() {
	this.finalId = -1;
	var this1 = new Array(256);
	this.trans = this1;
};
$hxClasses["hxparse.State"] = hxparse_State;
hxparse_State.__name__ = "hxparse.State";
hxparse_State.prototype = {
	__class__: hxparse_State
};
var hxparse_UnexpectedChar = function(char,pos) {
	hxparse_ParserError.call(this,pos);
	this.char = char;
};
$hxClasses["hxparse.UnexpectedChar"] = hxparse_UnexpectedChar;
hxparse_UnexpectedChar.__name__ = "hxparse.UnexpectedChar";
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
hxparse_UnexpectedChar.prototype = $extend(hxparse_ParserError.prototype,{
	toString: function() {
		return "Unexpected " + this.char;
	}
	,__class__: hxparse_UnexpectedChar
});
var js_Browser = function() { };
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = "js.Browser";
js_Browser.get_supported = function() {
	if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
		return typeof(window.location.protocol) == "string";
	} else {
		return false;
	}
};
js_Browser.getLocalStorage = function() {
	try {
		var s = window.localStorage;
		s.getItem("");
		if(s.length == 0) {
			var key = "_hx_" + Math.random();
			s.setItem(key,key);
			s.removeItem(key);
		}
		return s;
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return null;
	}
};
js_Browser.createXMLHttpRequest = function() {
	if(typeof XMLHttpRequest != "undefined") {
		return new XMLHttpRequest();
	}
	if(typeof ActiveXObject != "undefined") {
		return new ActiveXObject("Microsoft.XMLHTTP");
	}
	throw haxe_Exception.thrown("Unable to create XMLHttpRequest object.");
};
var js_codemirror_ColorPreview = function(cm) {
	this.left = 0;
	this.top = 0;
	this.preview = window.document.createElement("div");
	this.preview.className = "colorPreview";
	this.preview.style.display = "none";
	window.document.body.appendChild(this.preview);
	this.startScroll = cm.getScrollInfo();
};
$hxClasses["js.codemirror.ColorPreview"] = js_codemirror_ColorPreview;
js_codemirror_ColorPreview.__name__ = "js.codemirror.ColorPreview";
js_codemirror_ColorPreview.prototype = {
	update: function(completionManager,cm) {
		var word = completionManager.getCurrentWord(cm,{ word : new EReg("[A-Fx0-9#]+$","i")},cm.getCursor()).word;
		var color = null;
		if(word != null && word.length > 2) {
			if(StringTools.startsWith(word,"0x")) {
				color = HxOverrides.substr(word,2,null);
			} else if(StringTools.startsWith(word,"#")) {
				color = HxOverrides.substr(word,1,null);
			}
			if(color != null) {
				this.startScroll = cm.getScrollInfo();
				var pos = cm.cursorCoords(null);
				this.top = pos.bottom;
				this.left = pos.left;
				this.preview.style.backgroundColor = "#" + color;
				var tmp = pos.left == null ? "null" : "" + pos.left;
				var tmp1 = pos.bottom == null ? "null" : "" + pos.bottom;
				$(this.preview).animate({ left : tmp + "px", top : tmp1 + "px"});
				$(this.preview).fadeIn();
			} else {
				$(this.preview).fadeOut();
			}
		} else {
			$(this.preview).fadeOut();
		}
	}
	,scroll: function(cm) {
		if(this.preview.style.display != "none") {
			var curScroll = cm.getScrollInfo();
			var editor = cm.getWrapperElement().getBoundingClientRect();
			var newTop = this.top + this.startScroll.top - curScroll.top;
			var point = newTop - $(window).scrollTop();
			if(point <= editor.top || point >= editor.bottom) {
				$(this.preview).fadeOut();
				return;
			}
			this.preview.style.top = newTop + "px";
			this.preview.style.left = this.left + this.startScroll.left - curScroll.left + "px";
		}
	}
	,__class__: js_codemirror_ColorPreview
};
var js_jquery_JqEltsIterator = function(j) {
	this.i = 0;
	this.j = j;
};
$hxClasses["js.jquery.JqEltsIterator"] = js_jquery_JqEltsIterator;
js_jquery_JqEltsIterator.__name__ = "js.jquery.JqEltsIterator";
js_jquery_JqEltsIterator.prototype = {
	hasNext: function() {
		return this.i < this.j.length;
	}
	,next: function() {
		return $(this.j[this.i++]);
	}
	,__class__: js_jquery_JqEltsIterator
};
var js_jquery_JqIterator = function(j) {
	this.i = 0;
	this.j = j;
};
$hxClasses["js.jquery.JqIterator"] = js_jquery_JqIterator;
js_jquery_JqIterator.__name__ = "js.jquery.JqIterator";
js_jquery_JqIterator.prototype = {
	hasNext: function() {
		return this.i < this.j.length;
	}
	,next: function() {
		return this.j[this.i++];
	}
	,__class__: js_jquery_JqIterator
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var json2object_Error = $hxEnums["json2object.Error"] = { __ename__:"json2object.Error",__constructs__:null
	,IncorrectType: ($_=function(variable,expected,pos) { return {_hx_index:0,variable:variable,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="IncorrectType",$_.__params__ = ["variable","expected","pos"],$_)
	,IncorrectEnumValue: ($_=function(value,expected,pos) { return {_hx_index:1,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="IncorrectEnumValue",$_.__params__ = ["value","expected","pos"],$_)
	,InvalidEnumConstructor: ($_=function(value,expected,pos) { return {_hx_index:2,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="InvalidEnumConstructor",$_.__params__ = ["value","expected","pos"],$_)
	,UninitializedVariable: ($_=function(variable,pos) { return {_hx_index:3,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="UninitializedVariable",$_.__params__ = ["variable","pos"],$_)
	,UnknownVariable: ($_=function(variable,pos) { return {_hx_index:4,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="UnknownVariable",$_.__params__ = ["variable","pos"],$_)
	,ParserError: ($_=function(message,pos) { return {_hx_index:5,message:message,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="ParserError",$_.__params__ = ["message","pos"],$_)
	,CustomFunctionException: ($_=function(e,pos) { return {_hx_index:6,e:e,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="CustomFunctionException",$_.__params__ = ["e","pos"],$_)
};
json2object_Error.__constructs__ = [json2object_Error.IncorrectType,json2object_Error.IncorrectEnumValue,json2object_Error.InvalidEnumConstructor,json2object_Error.UninitializedVariable,json2object_Error.UnknownVariable,json2object_Error.ParserError,json2object_Error.CustomFunctionException];
var json2object_InternalError = $hxEnums["json2object.InternalError"] = { __ename__:"json2object.InternalError",__constructs__:null
	,AbstractNoJsonRepresentation: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="AbstractNoJsonRepresentation",$_.__params__ = ["name"],$_)
	,CannotGenerateSchema: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="CannotGenerateSchema",$_.__params__ = ["name"],$_)
	,HandleExpr: {_hx_name:"HandleExpr",_hx_index:2,__enum__:"json2object.InternalError",toString:$estr}
	,ParsingThrow: {_hx_name:"ParsingThrow",_hx_index:3,__enum__:"json2object.InternalError",toString:$estr}
	,UnsupportedAbstractEnumType: ($_=function(name) { return {_hx_index:4,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedAbstractEnumType",$_.__params__ = ["name"],$_)
	,UnsupportedEnumAbstractValue: ($_=function(name) { return {_hx_index:5,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedEnumAbstractValue",$_.__params__ = ["name"],$_)
	,UnsupportedMapKeyType: ($_=function(name) { return {_hx_index:6,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedMapKeyType",$_.__params__ = ["name"],$_)
	,UnsupportedSchemaObjectType: ($_=function(name) { return {_hx_index:7,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedSchemaObjectType",$_.__params__ = ["name"],$_)
	,UnsupportedSchemaType: ($_=function(type) { return {_hx_index:8,type:type,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedSchemaType",$_.__params__ = ["type"],$_)
};
json2object_InternalError.__constructs__ = [json2object_InternalError.AbstractNoJsonRepresentation,json2object_InternalError.CannotGenerateSchema,json2object_InternalError.HandleExpr,json2object_InternalError.ParsingThrow,json2object_InternalError.UnsupportedAbstractEnumType,json2object_InternalError.UnsupportedEnumAbstractValue,json2object_InternalError.UnsupportedMapKeyType,json2object_InternalError.UnsupportedSchemaObjectType,json2object_InternalError.UnsupportedSchemaType];
var json2object_CustomFunctionError = function(message) {
	this.message = message;
};
$hxClasses["json2object.CustomFunctionError"] = json2object_CustomFunctionError;
json2object_CustomFunctionError.__name__ = "json2object.CustomFunctionError";
json2object_CustomFunctionError.prototype = {
	__class__: json2object_CustomFunctionError
};
var json2object_JsonParser = function() { };
$hxClasses["json2object.JsonParser"] = json2object_JsonParser;
json2object_JsonParser.__name__ = "json2object.JsonParser";
var json2object_PositionUtils = function(content) {
	this.linesInfo = [];
	var s = 0;
	var e = 0;
	var i = 0;
	var lineCount = 0;
	while(i < content.length) switch(content.charAt(i)) {
	case "\n":
		e = i;
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		++i;
		s = i;
		break;
	case "\r":
		e = i;
		if(content.charAt(i + 1) == "\n") {
			++e;
		}
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		i = e + 1;
		s = i;
		break;
	default:
		++i;
	}
	this.linesInfo.push({ number : lineCount, start : s, end : i});
};
$hxClasses["json2object.PositionUtils"] = json2object_PositionUtils;
json2object_PositionUtils.__name__ = "json2object.PositionUtils";
json2object_PositionUtils.prototype = {
	convertPosition: function(position) {
		var file = position.file;
		var min = position.min;
		var max = position.max;
		var pos = { file : file, min : min + 1, max : max + 1, lines : []};
		var lastLine = this.linesInfo.length - 1;
		var bounds_min = 0;
		var bounds_max = lastLine;
		if(min > this.linesInfo[0].end) {
			while(bounds_max > bounds_min) {
				var i = (bounds_min + bounds_max) / 2 | 0;
				var line = this.linesInfo[i];
				if(line.start == min) {
					bounds_min = i;
					bounds_max = i;
				}
				if(line.end < min) {
					bounds_min = i + 1;
				}
				if(line.start > min || line.end >= min && line.start < min) {
					bounds_max = i;
				}
			}
		}
		var _g = bounds_min;
		var _g1 = this.linesInfo.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.linesInfo[i];
			if(line.start <= min && line.end >= max) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : max - line.start + 1});
				break;
			}
			if(line.start <= min && min <= line.end) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : line.end + 1});
			}
			if(line.start <= max && max <= line.end) {
				pos.lines.push({ number : line.number + 1, start : line.start + 1, end : max - line.start + 1});
			}
			if(line.start >= max || line.end >= max) {
				break;
			}
		}
		return pos;
	}
	,revert: function(position) {
		return new hxjsonast_Position(position.file,position.min - 1,position.max - 1);
	}
	,__class__: json2object_PositionUtils
};
var tokentree_ToTokenTreeDef = {};
tokentree_ToTokenTreeDef._new = function(tok) {
	var this1 = tok;
	return this1;
};
tokentree_ToTokenTreeDef.toTokenTreeDef = function(this1) {
	return this1;
};
tokentree_ToTokenTreeDef.fromTokenDef = function(tok) {
	var tmp;
	switch(tok._hx_index) {
	case 0:
		var k = tok.k;
		tmp = tokentree_TokenTreeDef.Kwd(k);
		break;
	case 1:
		var c = tok.c;
		tmp = tokentree_TokenTreeDef.Const(c);
		break;
	case 2:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Sharp(s);
		break;
	case 3:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Dollar(s);
		break;
	case 4:
		var op = tok.op;
		tmp = tokentree_TokenTreeDef.Unop(op);
		break;
	case 5:
		var op = tok.op;
		tmp = tokentree_TokenTreeDef.Binop(op);
		break;
	case 6:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.Comment(s);
		break;
	case 7:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.CommentLine(s);
		break;
	case 8:
		var s = tok.s;
		tmp = tokentree_TokenTreeDef.IntInterval(s);
		break;
	case 9:
		tmp = tokentree_TokenTreeDef.Semicolon;
		break;
	case 10:
		tmp = tokentree_TokenTreeDef.Dot;
		break;
	case 11:
		tmp = tokentree_TokenTreeDef.DblDot;
		break;
	case 12:
		tmp = tokentree_TokenTreeDef.Arrow;
		break;
	case 13:
		tmp = tokentree_TokenTreeDef.Comma;
		break;
	case 14:
		tmp = tokentree_TokenTreeDef.BkOpen;
		break;
	case 15:
		tmp = tokentree_TokenTreeDef.BkClose;
		break;
	case 16:
		tmp = tokentree_TokenTreeDef.BrOpen;
		break;
	case 17:
		tmp = tokentree_TokenTreeDef.BrClose;
		break;
	case 18:
		tmp = tokentree_TokenTreeDef.POpen;
		break;
	case 19:
		tmp = tokentree_TokenTreeDef.PClose;
		break;
	case 20:
		tmp = tokentree_TokenTreeDef.Question;
		break;
	case 21:
		tmp = tokentree_TokenTreeDef.At;
		break;
	case 22:
		tmp = tokentree_TokenTreeDef.Eof;
		break;
	}
	return tokentree_ToTokenTreeDef._new(tmp);
};
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__:"tokentree.TokenStreamMode",__constructs__:null
	,Strict: {_hx_name:"Strict",_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,Relaxed: {_hx_name:"Relaxed",_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
tokentree_TokenStreamMode.__constructs__ = [tokentree_TokenStreamMode.Strict,tokentree_TokenStreamMode.Relaxed];
var tokentree_TokenStream = function(tokens,bytes) {
	this.tokens = tokens;
	this.bytes = bytes;
	this.sharpIfStack = [];
	this.tempStore = [];
	this.current = 0;
};
$hxClasses["tokentree.TokenStream"] = tokentree_TokenStream;
tokentree_TokenStream.__name__ = "tokentree.TokenStream";
tokentree_TokenStream.prototype = {
	hasMore: function() {
		return this.current < this.tokens.length;
	}
	,consumeToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("auto insert"));
			}
		}
		var token = this.tokens[this.current];
		this.current++;
		var space = "";
		return new tokentree_TokenTree(tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)),space,token.pos,this.current - 1);
	}
	,consumeConstIdent: function() {
		var _g = this.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 4:
			var _g1 = _g.s;
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
			}
		}
	}
	,consumeConst: function() {
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("autoInsert")));
			}
		}
	}
	,consumeTokenDef: function(tokenDef) {
		if(this.matches(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			var s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	,consumeToTempStore: function() {
		this.tempStore.push(this.consumeToken());
	}
	,addToTempStore: function(token) {
		this.tempStore.push(token);
	}
	,applyTempStore: function(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	,hasTempStore: function() {
		return this.tempStore.length > 0;
	}
	,getTempStore: function() {
		return this.tempStore;
	}
	,clearTempStore: function() {
		this.tempStore = [];
	}
	,error: function(s) {
		throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
	}
	,formatCurrentPos: function() {
		var pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	,matches: function(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		return Type.enumEq(tokenDef,tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)));
	}
	,isSharp: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.s;
			return true;
		} else {
			return false;
		}
	}
	,isTypedParam: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var index = this.current + 1;
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		var depth = 1;
		var brDepth = 0;
		var bkDepth = 0;
		var pDepth = 0;
		while(true) {
			token = this.tokens[index++];
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.c;
				break;
			case 3:
				var _g2 = _g.s;
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					--depth;
					if(depth <= 0) {
						return true;
					}
					break;
				case 9:
					++depth;
					break;
				default:
					return false;
				}
				break;
			case 10:
				break;
			case 11:
				break;
			case 12:
				break;
			case 13:
				break;
			case 14:
				++bkDepth;
				break;
			case 15:
				if(bkDepth <= 0) {
					return false;
				}
				--bkDepth;
				break;
			case 16:
				++brDepth;
				break;
			case 17:
				if(brDepth <= 0) {
					return false;
				}
				--brDepth;
				break;
			case 18:
				++pDepth;
				break;
			case 19:
				if(pDepth <= 0) {
					return false;
				}
				--pDepth;
				break;
			default:
				return false;
			}
			if(index >= this.tokens.length) {
				return false;
			}
		}
	}
	,token: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.CommentLine("auto insert");
			}
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,tokenForMatch: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return tokentree_TokenTreeDef.Root;
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,peekNonCommentToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("auto insert"));
			}
		}
		var index = this.current;
		while(index < this.tokens.length) {
			var token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				var _g1 = _g.s;
				break;
			case 7:
				var _g2 = _g.s;
				break;
			default:
				return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok));
			}
		}
		return tokentree_TokenTreeDef.Root;
	}
	,getTokenPos: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	,rewind: function() {
		if(this.current <= 0) {
			return;
		}
		this.current--;
	}
	,getStreamIndex: function() {
		return this.current;
	}
	,rewindTo: function(pos) {
		this.current = pos;
	}
	,consumeOpGt: function() {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	,consumeOpShr: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				var innerGt = this.consumeToken();
				var _g = this.token();
				if(_g._hx_index == 6) {
					if(_g.op._hx_index == 4) {
						var assignTok = this.consumeToken();
						return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
					}
				}
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	,consumeOpSub: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var _g = _g1.v;
				break;
			case 1:
				var _g = _g1.f;
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var previous = this.current - 2;
		if(previous < 0) {
			throw haxe_Exception.thrown("no more tokens");
		}
		var prevTok = this.tokens[previous];
		var _g = prevTok.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 29:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 4:
			var _g1 = _g.op;
			break;
		case 5:
			var _g1 = _g.op;
			break;
		case 8:
			var _g1 = _g.s;
			break;
		case 19:
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			var _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 6:case 7:case 21:
					break;
				default:
					return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
				}
			} else {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 9:case 11:case 13:case 14:case 16:case 18:case 20:
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var n = _g1.v;
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CInt("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				var n = _g1.f;
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CFloat("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			default:
				throw haxe_Exception.thrown("no more tokens");
			}
		} else {
			throw haxe_Exception.thrown("no more tokens");
		}
	}
	,pushSharpIf: function(token) {
		this.sharpIfStack.push(token);
	}
	,popSharpIf: function() {
		var token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	,peekSharpIf: function() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	,createDummyToken: function(tokDef) {
		var pos;
		if(this.current < 0 || this.current >= this.tokens.length) {
			var prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			var prevPos = this.tokens[this.current].pos;
			pos = { min : prevPos.min, max : prevPos.min, file : prevPos.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
	,__class__: tokentree_TokenStream
};
var tokentree_TokenStreamProgress = function(stream) {
	this.stream = stream;
	this.pos = -1;
};
$hxClasses["tokentree.TokenStreamProgress"] = tokentree_TokenStreamProgress;
tokentree_TokenStreamProgress.__name__ = "tokentree.TokenStreamProgress";
tokentree_TokenStreamProgress.prototype = {
	streamHasChanged: function() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		var oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
	,__class__: tokentree_TokenStreamProgress
};
var tokentree_TokenTree = function(tok,space,pos,index,inserted) {
	if(inserted == null) {
		inserted = false;
	}
	this.tok = tok;
	this.pos = pos;
	this.index = index;
	this.inserted = inserted;
	this.space = space;
	this.tokenTypeCache = { };
};
$hxClasses["tokentree.TokenTree"] = tokentree_TokenTree;
tokentree_TokenTree.__name__ = "tokentree.TokenTree";
tokentree_TokenTree.prototype = {
	matches: function(tokenDef) {
		return Type.enumEq(tokenDef,this.tok);
	}
	,isComment: function() {
		var _g = this.tok;
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			return true;
		case 8:
			var _g1 = _g.s;
			return true;
		default:
			return false;
		}
	}
	,isCIdent: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g = _g1.s;
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,isCIdentOrCString: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				var _g = _g1.s;
				var _g = _g1.kind;
				return true;
			case 3:
				var _g = _g1.s;
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,addChild: function(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	,hasChildren: function() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	,getFirstChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	,getLastChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	,getPos: function() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		var fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		var childPos;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			childPos = child.getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	,filter: function(searchFor,mode,maxLevel) {
		if(maxLevel == null) {
			maxLevel = 9999;
		}
		return this.filterCallback(function(token,depth) {
			if(depth > maxLevel) {
				return tokentree_FilterResult.SkipSubtree;
			}
			if(token.matchesAny(searchFor)) {
				if(mode == tokentree_TokenFilterMode.All) {
					return tokentree_FilterResult.FoundGoDeeper;
				}
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,filterCallback: function(callback) {
		var results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	,internalFilterCallback: function(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok._hx_index != 0) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	,matchesAny: function(searchFor) {
		if(searchFor == null || this.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = 0;
		while(_g < searchFor.length) {
			var search = searchFor[_g];
			++_g;
			if(Type.enumEq(this.tok,search)) {
				return true;
			}
		}
		return false;
	}
	,printTokenTree: function(prefix) {
		if(prefix == null) {
			prefix = "";
		}
		var buf_b = "";
		var tokString = "" + Std.string(this.tok);
		if(this.inserted) {
			tokString = "*** " + tokString + " ***";
		}
		if(this.tok != tokentree_TokenTreeDef.Root) {
			buf_b += Std.string("" + prefix + tokString + "\t\t\t\t" + Std.string(this.getPos()));
		}
		if(this.children == null) {
			return buf_b;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			buf_b += Std.string("\n" + prefix + child.printTokenTree(prefix + "  "));
		}
		return buf_b;
	}
	,toString: function() {
		return tokentree_TokenTreeDefPrinter.toString(this.tok);
	}
	,__class__: tokentree_TokenTree
};
var tokentree_TokenFilterMode = $hxEnums["tokentree.TokenFilterMode"] = { __ename__:"tokentree.TokenFilterMode",__constructs__:null
	,All: {_hx_name:"All",_hx_index:0,__enum__:"tokentree.TokenFilterMode",toString:$estr}
	,First: {_hx_name:"First",_hx_index:1,__enum__:"tokentree.TokenFilterMode",toString:$estr}
};
tokentree_TokenFilterMode.__constructs__ = [tokentree_TokenFilterMode.All,tokentree_TokenFilterMode.First];
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__:"tokentree.FilterResult",__constructs__:null
	,FoundSkipSubtree: {_hx_name:"FoundSkipSubtree",_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FoundGoDeeper: {_hx_name:"FoundGoDeeper",_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SkipSubtree: {_hx_name:"SkipSubtree",_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GoDeeper: {_hx_name:"GoDeeper",_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
tokentree_FilterResult.__constructs__ = [tokentree_FilterResult.FoundSkipSubtree,tokentree_FilterResult.FoundGoDeeper,tokentree_FilterResult.SkipSubtree,tokentree_FilterResult.GoDeeper];
var tokentree_TokenTreeAccessHelper = {};
tokentree_TokenTreeAccessHelper.get_token = function(this1) {
	return this1;
};
tokentree_TokenTreeAccessHelper.access = function(tok) {
	return tok;
};
tokentree_TokenTreeAccessHelper.parent = function(this1) {
	if(this1 != null) {
		return this1.parent;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.findParent = function(this1,predicate) {
	var parent = tokentree_TokenTreeAccessHelper.parent(this1);
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		if(predicate(parent)) {
			return parent;
		}
		parent = tokentree_TokenTreeAccessHelper.parent(parent);
	}
	return null;
};
tokentree_TokenTreeAccessHelper.previousSibling = function(this1) {
	if(this1 != null) {
		return this1.previousSibling;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.nextSibling = function(this1) {
	if(this1 != null) {
		return this1.nextSibling;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstChild = function(this1) {
	if(this1 != null) {
		return this1.getFirstChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.lastChild = function(this1) {
	if(this1 != null) {
		return this1.getLastChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			return tok;
		}
	}
	return null;
};
tokentree_TokenTreeAccessHelper.lastOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var found = null;
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			found = tok;
		}
	}
	return found;
};
tokentree_TokenTreeAccessHelper.child = function(this1,index) {
	if(this1 != null && this1.children != null) {
		return this1.children[index];
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.matches = function(this1,tok) {
	if(this1 != null && Type.enumEq(this1.tok,tok)) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.isComment = function(this1) {
	if(this1 != null && this1.isComment()) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.isCIdent = function(this1) {
	if(this1 != null && this1.isCIdent()) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.or = function(this1,other) {
	if(this1 != null) {
		return this1;
	} else {
		return other;
	}
};
tokentree_TokenTreeAccessHelper.exists = function(this1) {
	return this1 != null;
};
var tokentree_TokenTreeBuilder = function() { };
$hxClasses["tokentree.TokenTreeBuilder"] = tokentree_TokenTreeBuilder;
tokentree_TokenTreeBuilder.__name__ = "tokentree.TokenTreeBuilder";
tokentree_TokenTreeBuilder.buildTokenTree = function(tokens,bytes,entryPoint) {
	if(entryPoint == null) {
		entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
	}
	return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
};
tokentree_TokenTreeBuilder.buildTokenTreeFromStream = function(stream,entryPoint) {
	var root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
	switch(entryPoint._hx_index) {
	case 0:
		tokentree_walk_WalkFile.walkFile(stream,root);
		break;
	case 1:
		tokentree_walk_WalkClass.walkClassBody(stream,root);
		break;
	case 2:
		tokentree_walk_WalkStatement.walkStatement(stream,root);
		break;
	case 3:
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,root);
		break;
	}
	if(stream.hasMore()) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
		case 1:
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
			if(stream.hasMore()) {
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
			}
			break;
		}
	}
	var tempStore = stream.getTempStore();
	switch(tokentree_TokenStream.MODE._hx_index) {
	case 0:
		if(tempStore.length != 0) {
			throw haxe_Exception.thrown("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
		}
		break;
	case 1:
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			root.addChild(stored);
		}
		break;
	}
	return root;
};
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__:"tokentree.TokenTreeEntryPoint",__constructs__:null
	,TypeLevel: {_hx_name:"TypeLevel",_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FieldLevel: {_hx_name:"FieldLevel",_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,ExpressionLevel: {_hx_name:"ExpressionLevel",_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,TypeHintLevel: {_hx_name:"TypeHintLevel",_hx_index:3,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
tokentree_TokenTreeEntryPoint.__constructs__ = [tokentree_TokenTreeEntryPoint.TypeLevel,tokentree_TokenTreeEntryPoint.FieldLevel,tokentree_TokenTreeEntryPoint.ExpressionLevel,tokentree_TokenTreeEntryPoint.TypeHintLevel];
var tokentree_TokenTreeDef = $hxEnums["tokentree.TokenTreeDef"] = { __ename__:"tokentree.TokenTreeDef",__constructs__:null
	,Root: {_hx_name:"Root",_hx_index:0,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Kwd: ($_=function(k) { return {_hx_index:1,k:k,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Kwd",$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Sharp",$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Dollar",$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Unop",$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Binop",$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Comment",$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="CommentLine",$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:9,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="IntInterval",$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_name:"Semicolon",_hx_index:10,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:11,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,DblDot: {_hx_name:"DblDot",_hx_index:12,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:13,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:14,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkOpen: {_hx_name:"BkOpen",_hx_index:15,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkClose: {_hx_name:"BkClose",_hx_index:16,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrOpen: {_hx_name:"BrOpen",_hx_index:17,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrClose: {_hx_name:"BrClose",_hx_index:18,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,POpen: {_hx_name:"POpen",_hx_index:19,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,PClose: {_hx_name:"PClose",_hx_index:20,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Question: {_hx_name:"Question",_hx_index:21,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,At: {_hx_name:"At",_hx_index:22,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:23,__enum__:"tokentree.TokenTreeDef",toString:$estr}
};
tokentree_TokenTreeDef.__constructs__ = [tokentree_TokenTreeDef.Root,tokentree_TokenTreeDef.Kwd,tokentree_TokenTreeDef.Const,tokentree_TokenTreeDef.Sharp,tokentree_TokenTreeDef.Dollar,tokentree_TokenTreeDef.Unop,tokentree_TokenTreeDef.Binop,tokentree_TokenTreeDef.Comment,tokentree_TokenTreeDef.CommentLine,tokentree_TokenTreeDef.IntInterval,tokentree_TokenTreeDef.Semicolon,tokentree_TokenTreeDef.Dot,tokentree_TokenTreeDef.DblDot,tokentree_TokenTreeDef.Arrow,tokentree_TokenTreeDef.Comma,tokentree_TokenTreeDef.BkOpen,tokentree_TokenTreeDef.BkClose,tokentree_TokenTreeDef.BrOpen,tokentree_TokenTreeDef.BrClose,tokentree_TokenTreeDef.POpen,tokentree_TokenTreeDef.PClose,tokentree_TokenTreeDef.Question,tokentree_TokenTreeDef.At,tokentree_TokenTreeDef.Eof];
var tokentree_TokenTreeDefPrinter = function() { };
$hxClasses["tokentree.TokenTreeDefPrinter"] = tokentree_TokenTreeDefPrinter;
tokentree_TokenTreeDefPrinter.__name__ = "tokentree.TokenTreeDefPrinter";
tokentree_TokenTreeDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		return "<root>";
	case 1:
		var k = def.k;
		return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index]._hx_name,3,null).toLowerCase();
	case 2:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			var s = _g.v;
			return s;
		case 1:
			var s = _g.f;
			return s;
		case 2:
			var _g1 = _g.kind;
			var s = _g.s;
			return "\"" + s + "\"";
		case 3:
			var s = _g.s;
			return s;
		case 4:
			var r = _g.r;
			var opt = _g.opt;
			return "~/" + r + "/" + opt;
		}
		break;
	case 3:
		var s = def.s;
		return "#" + s;
	case 4:
		var s = def.s;
		return "$" + s;
	case 5:
		var op = def.op;
		return new haxe_macro_Printer("").printUnop(op);
	case 6:
		var op = def.op;
		return new haxe_macro_Printer("").printBinop(op);
	case 7:
		var s = def.s;
		return "/*" + s + "*/";
	case 8:
		var s = def.s;
		return "//" + s;
	case 9:
		var s = def.s;
		return "" + s + "...";
	case 10:
		return ";";
	case 11:
		return ".";
	case 12:
		return ":";
	case 13:
		return "->";
	case 14:
		return ",";
	case 15:
		return "[";
	case 16:
		return "]";
	case 17:
		return "{";
	case 18:
		return "}";
	case 19:
		return "(";
	case 20:
		return ")";
	case 21:
		return "?";
	case 22:
		return "@";
	case 23:
		return "<eof>";
	}
};
var tokentree_utils_FieldUtils = function() { };
$hxClasses["tokentree.utils.FieldUtils"] = tokentree_utils_FieldUtils;
tokentree_utils_FieldUtils.__name__ = "tokentree.utils.FieldUtils";
tokentree_utils_FieldUtils.getFieldType = function(field,defaultVisibility) {
	if(field == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var _g = field.tok;
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_FieldUtils.getFunctionFieldType(field,defaultVisibility);
		case 2:case 41:
			return tokentree_utils_FieldUtils.getVarFieldType(field,defaultVisibility);
		default:
		}
	}
	return tokentree_utils_TokenFieldType.Unknown;
};
tokentree_utils_FieldUtils.getFunctionFieldType = function(field,defaultVisibility) {
	var access = tokentree_TokenTreeAccessHelper.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var isOverride = false;
	var isFinal = false;
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.Public;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.Private;
					break;
				case 25:
					isExtern = true;
					break;
				case 30:
					isOverride = true;
					break;
				case 34:
					isInline = true;
					break;
				case 41:
					isFinal = true;
					break;
				default:
				}
				break;
			case 17:case 19:
				break _hx_loop1;
			default:
			}
		}
	}
	return tokentree_utils_TokenFieldType.Function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern);
};
tokentree_utils_FieldUtils.getVarFieldType = function(field,defaultVisibility) {
	var access = tokentree_TokenTreeAccessHelper.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var _g = field.tok;
	var isFinal = _g._hx_index == 1 && _g.k._hx_index == 41;
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.Public;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.Private;
					break;
				case 25:
					isExtern = true;
					break;
				case 34:
					isInline = true;
					break;
				default:
				}
			}
		}
	}
	access = tokentree_TokenTreeAccessHelper.firstOf(access,tokentree_TokenTreeDef.POpen);
	if(isFinal || access == null) {
		return tokentree_utils_TokenFieldType.Var(name,visibility,isStatic,isInline,isFinal,isExtern);
	}
	var getterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.firstChild(access));
	var setterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.child(access,1));
	return tokentree_utils_TokenFieldType.Prop(name,visibility,isStatic,getterAccess,setterAccess);
};
tokentree_utils_FieldUtils.makePropertyAccess = function(accessToken) {
	if(accessToken == null) {
		return tokentree_utils_TokenPropertyAccess.Default;
	}
	var _g = accessToken.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 16:
			return tokentree_utils_TokenPropertyAccess.Default;
		case 32:
			return tokentree_utils_TokenPropertyAccess.DynamicAccess;
		case 36:
			return tokentree_utils_TokenPropertyAccess.NullAccess;
		default:
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "get":
				return tokentree_utils_TokenPropertyAccess.Get;
			case "never":
				return tokentree_utils_TokenPropertyAccess.Never;
			case "set":
				return tokentree_utils_TokenPropertyAccess.Set;
			default:
				return tokentree_utils_TokenPropertyAccess.Default;
			}
		} else {
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		break;
	default:
		return tokentree_utils_TokenPropertyAccess.Default;
	}
};
tokentree_utils_FieldUtils.isOperatorFunction = function(functionToken) {
	return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(functionToken),function(meta) {
		var _g = meta.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "arrayAccess":
					return true;
				case "op":
					return true;
				case "resolve":
					return true;
				default:
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
};
var tokentree_utils_TokenFieldType = $hxEnums["tokentree.utils.TokenFieldType"] = { __ename__:"tokentree.utils.TokenFieldType",__constructs__:null
	,Function: ($_=function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern) { return {_hx_index:0,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isOverride:isOverride,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Function",$_.__params__ = ["name","visibility","isStatic","isInline","isOverride","isFinal","isExtern"],$_)
	,Var: ($_=function(name,visibility,isStatic,isInline,isFinal,isExtern) { return {_hx_index:1,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Var",$_.__params__ = ["name","visibility","isStatic","isInline","isFinal","isExtern"],$_)
	,Prop: ($_=function(name,visibility,isStatic,getter,setter) { return {_hx_index:2,name:name,visibility:visibility,isStatic:isStatic,getter:getter,setter:setter,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Prop",$_.__params__ = ["name","visibility","isStatic","getter","setter"],$_)
	,Unknown: {_hx_name:"Unknown",_hx_index:3,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}
};
tokentree_utils_TokenFieldType.__constructs__ = [tokentree_utils_TokenFieldType.Function,tokentree_utils_TokenFieldType.Var,tokentree_utils_TokenFieldType.Prop,tokentree_utils_TokenFieldType.Unknown];
var tokentree_utils_TokenFieldVisibility = $hxEnums["tokentree.utils.TokenFieldVisibility"] = { __ename__:"tokentree.utils.TokenFieldVisibility",__constructs__:null
	,Public: {_hx_name:"Public",_hx_index:0,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
};
tokentree_utils_TokenFieldVisibility.__constructs__ = [tokentree_utils_TokenFieldVisibility.Public,tokentree_utils_TokenFieldVisibility.Private];
var tokentree_utils_TokenPropertyAccess = $hxEnums["tokentree.utils.TokenPropertyAccess"] = { __ename__:"tokentree.utils.TokenPropertyAccess",__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NullAccess: {_hx_name:"NullAccess",_hx_index:1,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Get: {_hx_name:"Get",_hx_index:2,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Set: {_hx_name:"Set",_hx_index:3,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,DynamicAccess: {_hx_name:"DynamicAccess",_hx_index:4,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:5,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
};
tokentree_utils_TokenPropertyAccess.__constructs__ = [tokentree_utils_TokenPropertyAccess.Default,tokentree_utils_TokenPropertyAccess.NullAccess,tokentree_utils_TokenPropertyAccess.Get,tokentree_utils_TokenPropertyAccess.Set,tokentree_utils_TokenPropertyAccess.DynamicAccess,tokentree_utils_TokenPropertyAccess.Never];
var tokentree_utils_TokenTreeCheckUtils = function() { };
$hxClasses["tokentree.utils.TokenTreeCheckUtils"] = tokentree_utils_TokenTreeCheckUtils;
tokentree_utils_TokenTreeCheckUtils.__name__ = "tokentree.utils.TokenTreeCheckUtils";
tokentree_utils_TokenTreeCheckUtils.isImportMult = function(token) {
	var _g = token.tok;
	switch(_g._hx_index) {
	case 6:
		if(_g.op._hx_index == 1) {
			return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
		} else {
			return false;
		}
		break;
	case 11:
		return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isImport = function(token) {
	var parent = token;
	while(parent != null) {
		if(parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 13:
				return true;
			case 25:
				break;
			case 35:
				return true;
			case 40:
				break;
			default:
				return false;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
			} else {
				return false;
			}
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeParameter = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		switch(_g.op._hx_index) {
		case 7:
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null;
		case 9:
			return tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)) != null;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		if(_g.op._hx_index == 7) {
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))))),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.filterOpSub = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	if(!(_g._hx_index == 6 && _g.op._hx_index == 3)) {
		return false;
	}
	var prev = token.previousSibling;
	if(token.previousSibling == null) {
		prev = token.parent;
	} else {
		prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
		if(prev == null) {
			return false;
		}
	}
	var _g = prev.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 10:
			return true;
		default:
			return false;
		}
		break;
	case 6:
		if(_g.op._hx_index == 23) {
			return true;
		} else {
			return true;
		}
		break;
	case 12:
		return true;
	case 13:
		return true;
	case 14:
		return true;
	case 15:
		return true;
	case 16:
		return false;
	case 17:
		return true;
	case 18:
		return true;
	case 19:
		return true;
	case 20:
		var pOpen = prev.parent;
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(pOpen);
		switch(type._hx_index) {
		case 0:
			return true;
		case 1:
			return true;
		case 2:
			return false;
		case 3:
			return true;
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 7:
			return false;
		case 8:
			return true;
		case 9:
			return false;
		}
		break;
	case 21:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isUnaryLeftSided = function(tok) {
	var child = tok.getFirstChild();
	if(child == null) {
		return false;
	}
	var _g = child.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 23:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		return true;
	case 19:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTernary = function(token) {
	if(token == null) {
		return false;
	}
	if(token.tok._hx_index == 12) {
		return tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent);
	}
	if(token.tok._hx_index != 21) {
		return false;
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) == null) {
		return false;
	}
	if(token.parent == null) {
		return false;
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:case 2:
			return false;
		case 41:
			return false;
		default:
			return true;
		}
		break;
	case 3:
		var _g1 = _g.s;
		return false;
	case 6:
		var _g1 = _g.op;
		return true;
	case 14:
		return false;
	case 19:
		var prev = token.previousSibling;
		if(prev == null) {
			return false;
		}
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
		if(lastToken == null) {
			return false;
		}
		switch(lastToken.tok._hx_index) {
		case 10:
			return false;
		case 14:
			return false;
		default:
			return true;
		}
		break;
	default:
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract = function(type) {
	var _g = type.tok;
	if(_g._hx_index == 1) {
		if(_g.k._hx_index == 39) {
			var name = tokentree_TokenTreeAccessHelper.firstChild(type);
			if(name == null || name.children == null || name.children.length <= 0) {
				return false;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(name,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
				return true;
			}
			var _g = 0;
			var _g1 = name.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				if(child.tok._hx_index != 22) {
					continue;
				}
				var enumTok = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum));
				if(enumTok == null) {
					continue;
				}
				return true;
			}
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeStructure = function(typedefToken) {
	var afterAssign = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(typedefToken)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)));
	if(tokentree_TokenTreeAccessHelper.matches(afterAssign,tokentree_TokenTreeDef.BrOpen) == null) {
		return tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(afterAssign),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd)) != null;
	} else {
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnum = function(enumToken) {
	var _g = enumToken.tok;
	if(!(_g._hx_index == 1 && _g.k._hx_index == 26)) {
		return false;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(enumToken)) {
		return false;
	}
	if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(enumToken),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.At) != null) {
		return false;
	}
	return true;
};
tokentree_utils_TokenTreeCheckUtils.isTypeMacroClass = function(classToken) {
	var _g = classToken.tok;
	if(_g._hx_index == 1 && _g.k._hx_index == 1) {
		return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(classToken),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdMacro)) != null;
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isBrOpenAnonTypeOrTypedef = function(token) {
	switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
	case 0:
		return false;
	case 1:
		return true;
	case 2:
		return false;
	case 3:
		return true;
	case 4:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getName = function(token) {
	if(token == null) {
		return null;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return "new";
		} else {
			return null;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var ident = _g1.s;
			return ident;
		} else {
			return null;
		}
		break;
	default:
		return null;
	}
};
tokentree_utils_TokenTreeCheckUtils.getNameToken = function(token) {
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
		return token;
	}
	var nameToken = tokentree_TokenTreeAccessHelper.firstChild(token);
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	nameToken = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(nameToken,tokentree_TokenTreeDef.Question));
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isNameToken = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getMetadata = function(declToken) {
	var ident = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(declToken));
	if(ident == null || !ident.hasChildren()) {
		return [];
	}
	var _this = ident.children;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(_this[i],tokentree_TokenTreeDef.At)),tokentree_TokenTreeDef.DblDot));
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = result;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	return _g;
};
tokentree_utils_TokenTreeCheckUtils.getDocComment = function(declToken) {
	var access = declToken;
	while(true) {
		access = tokentree_TokenTreeAccessHelper.previousSibling(access);
		if(access == null) {
			return null;
		}
		var _g = access.tok;
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			return access;
		case 8:
			var _g2 = _g.s;
			continue;
		default:
			return null;
		}
	}
};
tokentree_utils_TokenTreeCheckUtils.isModifier = function(keyword) {
	if(keyword == null) {
		return false;
	}
	var _g = keyword.tok;
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 17:
			return true;
		case 18:
			return true;
		case 19:
			return true;
		case 25:
			return true;
		case 30:
			return true;
		case 32:
			return true;
		case 34:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.tokenTypeCache.brOpenType != null) {
		return token.tokenTypeCache.brOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
	token.tokenTypeCache.brOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 10) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "from":case "to":
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
		} else {
			return tokentree_utils_BrOpenType.Block;
		}
		break;
	case 4:
		var _g1 = _g.s;
		return tokentree_utils_BrOpenType.Block;
	case 6:
		switch(_g.op._hx_index) {
		case 4:
			if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
				return tokentree_utils_BrOpenType.TypedefDecl;
			}
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		case 9:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 12:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		var parent = token.parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 16:
				return tokentree_utils_BrOpenType.ObjectDecl;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		case 2:
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				var _g = _g1.s;
				var _g = _g1.kind;
				break;
			case 3:
				var _g = _g1.s;
				break;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		default:
			return tokentree_utils_BrOpenType.AnonType;
		}
		parent = parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.AnonType;
			case 2:
				return tokentree_utils_BrOpenType.AnonType;
			case 41:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				return tokentree_utils_BrOpenType.AnonType;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 17:
			return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
		case 19:
			return tokentree_utils_BrOpenType.AnonType;
		case 21:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 15:
		return tokentree_utils_BrOpenType.ObjectDecl;
	case 19:
		var pOpenType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
		switch(pOpenType._hx_index) {
		case 0:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 1:
			return tokentree_utils_BrOpenType.AnonType;
		case 2:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 3:
			return tokentree_utils_BrOpenType.Unknown;
		case 4:
			return tokentree_utils_BrOpenType.Unknown;
		case 5:
			return tokentree_utils_BrOpenType.Unknown;
		case 6:
			return tokentree_utils_BrOpenType.Unknown;
		case 7:
			return tokentree_utils_BrOpenType.Unknown;
		case 8:
			return tokentree_utils_BrOpenType.Unknown;
		case 9:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 21:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	default:
	}
	return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
};
tokentree_utils_TokenTreeCheckUtils.determinBrChildren = function(token) {
	if(token.children == null || token.children.length <= 0) {
		var _g = token.parent.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.k;
			return tokentree_utils_BrOpenType.Block;
		} else {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
	}
	if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
		if(token.children.length == 1) {
			var _g = token.parent.tok;
			if(_g._hx_index == 1) {
				var _g1 = _g.k;
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
		if(token.children.length == 2 && token.getLastChild().tok._hx_index == 10) {
			var _g = token.parent.tok;
			if(_g._hx_index == 1) {
				var _g1 = _g.k;
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	if(token.nextSibling != null && token.nextSibling.tok._hx_index == 13) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	var onlyComment = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		var _g2 = child.tok;
		switch(_g2._hx_index) {
		case 2:
			var _g3 = _g2.c;
			switch(_g3._hx_index) {
			case 2:
				var _g4 = _g3.s;
				var _g5 = _g3.kind;
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			case 3:
				var _g6 = _g3.s;
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
			break;
		case 3:
			var _g7 = _g2.s;
			break;
		case 7:
			var _g8 = _g2.s;
			break;
		case 8:
			var _g9 = _g2.s;
			break;
		case 18:
			if(onlyComment) {
				if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
					var _g10 = token.parent.tok;
					if(_g10._hx_index == 1) {
						var _g11 = _g10.k;
						return tokentree_utils_BrOpenType.Block;
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
			return tokentree_utils_BrOpenType.ObjectDecl;
		default:
			return tokentree_utils_BrOpenType.Block;
		}
	}
	return tokentree_utils_BrOpenType.ObjectDecl;
};
tokentree_utils_TokenTreeCheckUtils.getPOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_POpenType.Expression;
	}
	switch(token.tok._hx_index) {
	case 19:
		break;
	case 20:
		return tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
	default:
		return tokentree_utils_POpenType.Expression;
	}
	if(token.tokenTypeCache.pOpenType != null) {
		return token.tokenTypeCache.pOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
	token.tokenTypeCache.pOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determinePOpenType = function(token) {
	var parent = token.parent;
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
		return tokentree_utils_POpenType.At;
	}
	if(token.hasChildren() && tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren(token)) {
		return tokentree_utils_POpenType.Parameter;
	}
	_hx_loop1: while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 3:
			switch(_g.s) {
			case "elseif":case "if":
				if(parent.getFirstChild() == token) {
					return tokentree_utils_POpenType.SharpCondition;
				}
				parent = parent.parent;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				parent = parent.parent;
			} else {
				break _hx_loop1;
			}
			break;
		default:
			break _hx_loop1;
		}
	}
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_POpenType.Parameter;
		case 3:
			var firstChild = parent.getFirstChild();
			if(firstChild == null) {
				return tokentree_utils_POpenType.IfCondition;
			}
			if(firstChild.index == token.index) {
				return tokentree_utils_POpenType.IfCondition;
			}
			return tokentree_utils_POpenType.Expression;
		case 5:
			return tokentree_utils_POpenType.WhileCondition;
		case 7:
			return tokentree_utils_POpenType.ForLoop;
		case 14:
			return tokentree_utils_POpenType.SwitchCondition;
		case 21:
			return tokentree_utils_POpenType.Catch;
		case 22:
			return tokentree_utils_POpenType.Parameter;
		default:
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_POpenType.Call;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(parent.previousSibling == null) {
						var pOpen = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.POpen);
						if(pOpen == null) {
							return tokentree_utils_POpenType.Parameter;
						}
						if(pOpen.index == token.index) {
							return tokentree_utils_POpenType.Parameter;
						}
						return tokentree_utils_POpenType.Expression;
					}
					return tokentree_utils_POpenType.Call;
				case 39:
					return tokentree_utils_POpenType.Parameter;
				default:
					return tokentree_utils_POpenType.Call;
				}
				break;
			case 17:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent.parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return tokentree_utils_POpenType.Parameter;
				}
				return tokentree_utils_POpenType.Call;
			default:
				return tokentree_utils_POpenType.Call;
			}
		}
		break;
	case 19:
		return tokentree_utils_POpenType.Expression;
	default:
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_POpenType.Parameter;
	}
	return tokentree_utils_POpenType.Expression;
};
tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren = function(token) {
	var skip = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		if(child.tok._hx_index == 20) {
			skip = false;
		}
		if(skip) {
			continue;
		}
		if(child.tok._hx_index == 13) {
			return true;
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.hasAtParent = function(token) {
	var parent = token.parent;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			break;
		case 2:
			var _g2 = _g.c;
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		case 12:
			break;
		case 22:
			return true;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isInsideTypedef = function(token) {
	if(token == null) {
		return false;
	}
	var parent = token;
	while(parent.parent != null) {
		var _g = parent.tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 31) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isDeprecated = function(declToken) {
	return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(declToken),function(meta) {
		var _g = meta.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "deprecated") {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
};
tokentree_utils_TokenTreeCheckUtils.getArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	if(token.tokenTypeCache.arrowType != null) {
		return token.tokenTypeCache.arrowType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
	if(type == null) {
		type = tokentree_utils_ArrowType.ArrowFunction;
	}
	token.tokenTypeCache.arrowType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var child = token.getFirstChild();
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index != 40) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
			} else {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 7:
			var _g3 = _g.s;
			break;
		case 8:
			var _g4 = _g.s;
			break;
		case 10:case 11:case 13:case 21:
			break;
		case 17:
			var brClose = child.getFirstChild();
			if(brClose.tok._hx_index == 18) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
			if(brType == null) {
				brType = tokentree_utils_BrOpenType.Unknown;
			}
			if(brType != null) {
				switch(brType._hx_index) {
				case 0:
					return tokentree_utils_ArrowType.ArrowFunction;
				case 3:
					break;
				default:
				}
			}
			child = child.nextSibling;
			continue;
		case 19:
			break;
		default:
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		child = child.getFirstChild();
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
	if(resultType != null) {
		return resultType;
	}
	return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
};
tokentree_utils_TokenTreeCheckUtils.checkArrowChildren = function(parent) {
	var child = parent.getFirstChild();
	if(child == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var seenArrow = false;
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			return tokentree_utils_ArrowType.ArrowFunction;
		case 2:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
			} else {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 7:
			var _g4 = _g.s;
			break;
		case 8:
			var _g5 = _g.s;
			break;
		case 10:case 11:
			break;
		case 12:case 17:
			break;
		case 13:
			seenArrow = true;
			break;
		case 19:
			var result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
			if(result != null) {
				return result;
			}
			child = child.nextSibling;
			continue;
		case 20:
			break;
		case 21:
			break;
		default:
			return tokentree_utils_ArrowType.NewFunctionType;
		}
		child = child.getFirstChild();
	}
	if(seenArrow) {
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return tokentree_utils_ArrowType.NewFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen = function(token) {
	if(token.children == null || token.children.length <= 1) {
		return null;
	}
	if(token.parent.isCIdent()) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var childArrows = token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 13) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	});
	if(childArrows.length <= 0) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var childArrows = token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 12) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	});
	if(childArrows.length > 0) {
		return tokentree_utils_ArrowType.NewFunctionType;
	}
	return tokentree_utils_ArrowType.OldFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowParent = function(parent) {
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g = _g1.s;
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(parent.parent)) {
						return tokentree_utils_ArrowType.OldFunctionType;
					}
					return tokentree_utils_ArrowType.ArrowFunction;
				case 22:
					return tokentree_utils_ArrowType.ArrowFunction;
				default:
				}
				break;
			case 12:
				var type = tokentree_utils_TokenTreeCheckUtils.getColonType(parent.parent);
				switch(type._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 2:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 0:case 3:case 4:case 5:case 6:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 13:
				return tokentree_utils_ArrowType.OldFunctionType;
			case 19:
				var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent);
				if(type == null) {
					type = tokentree_utils_POpenType.Expression;
				}
				switch(type._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 9:
					return tokentree_utils_ArrowType.OldFunctionType;
				default:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			default:
			}
		} else {
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		break;
	case 19:
		break;
	default:
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.getColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(token.tokenTypeCache.colonType != null) {
		return token.tokenTypeCache.colonType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
	token.tokenTypeCache.colonType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
		return tokentree_utils_ColonType.Ternary;
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	var _g = parent.tok;
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_ColonType.Unknown;
		}
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_ColonType.TypeHint;
		case 15:case 16:
			return tokentree_utils_ColonType.SwitchCase;
		case 22:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 23:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		default:
		}
		break;
	case 2:
		var _g1 = _g.c;
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 6:
		if(_g.op._hx_index == 9) {
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		}
		break;
	case 17:
		var brClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
		if(brClose == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(brClose.pos.max <= token.pos.min) {
			return tokentree_utils_ColonType.TypeCheck;
		}
		break;
	case 19:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
	case 21:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 22:
		return tokentree_utils_ColonType.At;
	default:
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.findColonParent = function(token) {
	var parent = token;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				return tokentree_utils_ColonType.TypeHint;
			default:
			}
			break;
		case 17:
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(brType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.Unknown;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 3:
				return tokentree_utils_ColonType.TypeHint;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			}
			break;
		case 19:
			var pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
			if(pClose != null && pClose.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TypeCheck;
			}
			var pType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent);
			switch(pType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.Unknown;
			case 3:
				return tokentree_utils_ColonType.TypeCheck;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			case 5:
				return tokentree_utils_ColonType.Unknown;
			case 6:
				return tokentree_utils_ColonType.Unknown;
			case 7:
				return tokentree_utils_ColonType.Unknown;
			case 8:
				return tokentree_utils_ColonType.TypeCheck;
			case 9:
				return tokentree_utils_ColonType.TypeCheck;
			}
			break;
		default:
		}
		parent = parent.parent;
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.getLastToken = function(token) {
	if(token == null) {
		return null;
	}
	if(token.children == null) {
		return token;
	}
	if(token.children.length <= 0) {
		return token;
	}
	var lastChild = token.getLastChild();
	while(lastChild != null) {
		var newLast = lastChild.getLastChild();
		if(newLast == null) {
			return lastChild;
		}
		lastChild = newLast;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isMetadata = function(token) {
	if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
		return false;
	}
	var parent = token.parent;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) switch(parent.tok._hx_index) {
	case 12:
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		if(parent.tok._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 22:
		return true;
	default:
		parent = parent.parent;
	}
	return false;
};
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__:"tokentree.utils.BrOpenType",__constructs__:null
	,Block: {_hx_name:"Block",_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TypedefDecl: {_hx_name:"TypedefDecl",_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ObjectDecl: {_hx_name:"ObjectDecl",_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,AnonType: {_hx_name:"AnonType",_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,Unknown: {_hx_name:"Unknown",_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
tokentree_utils_BrOpenType.__constructs__ = [tokentree_utils_BrOpenType.Block,tokentree_utils_BrOpenType.TypedefDecl,tokentree_utils_BrOpenType.ObjectDecl,tokentree_utils_BrOpenType.AnonType,tokentree_utils_BrOpenType.Unknown];
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__:"tokentree.utils.POpenType",__constructs__:null
	,At: {_hx_name:"At",_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Parameter: {_hx_name:"Parameter",_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Call: {_hx_name:"Call",_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SwitchCondition: {_hx_name:"SwitchCondition",_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,WhileCondition: {_hx_name:"WhileCondition",_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,IfCondition: {_hx_name:"IfCondition",_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SharpCondition: {_hx_name:"SharpCondition",_hx_index:6,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Catch: {_hx_name:"Catch",_hx_index:7,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,ForLoop: {_hx_name:"ForLoop",_hx_index:8,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Expression: {_hx_name:"Expression",_hx_index:9,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
tokentree_utils_POpenType.__constructs__ = [tokentree_utils_POpenType.At,tokentree_utils_POpenType.Parameter,tokentree_utils_POpenType.Call,tokentree_utils_POpenType.SwitchCondition,tokentree_utils_POpenType.WhileCondition,tokentree_utils_POpenType.IfCondition,tokentree_utils_POpenType.SharpCondition,tokentree_utils_POpenType.Catch,tokentree_utils_POpenType.ForLoop,tokentree_utils_POpenType.Expression];
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__:"tokentree.utils.ArrowType",__constructs__:null
	,ArrowFunction: {_hx_name:"ArrowFunction",_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,OldFunctionType: {_hx_name:"OldFunctionType",_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,NewFunctionType: {_hx_name:"NewFunctionType",_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
tokentree_utils_ArrowType.__constructs__ = [tokentree_utils_ArrowType.ArrowFunction,tokentree_utils_ArrowType.OldFunctionType,tokentree_utils_ArrowType.NewFunctionType];
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__:"tokentree.utils.ColonType",__constructs__:null
	,SwitchCase: {_hx_name:"SwitchCase",_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeHint: {_hx_name:"TypeHint",_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeCheck: {_hx_name:"TypeCheck",_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Ternary: {_hx_name:"Ternary",_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,ObjectLiteral: {_hx_name:"ObjectLiteral",_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,At: {_hx_name:"At",_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Unknown: {_hx_name:"Unknown",_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
tokentree_utils_ColonType.__constructs__ = [tokentree_utils_ColonType.SwitchCase,tokentree_utils_ColonType.TypeHint,tokentree_utils_ColonType.TypeCheck,tokentree_utils_ColonType.Ternary,tokentree_utils_ColonType.ObjectLiteral,tokentree_utils_ColonType.At,tokentree_utils_ColonType.Unknown];
var tokentree_walk_WalkAbstract = function() { };
$hxClasses["tokentree.walk.WalkAbstract"] = tokentree_walk_WalkAbstract;
tokentree_walk_WalkAbstract.__name__ = "tokentree.walk.WalkAbstract";
tokentree_walk_WalkAbstract.walkAbstract = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:case 27:
			stream.addToTempStore(typeTok);
			tokentree_walk_WalkType.walkType(stream,parent);
			return;
		default:
		}
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 19) {
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
	}
	var typeParent = name;
	var typeChild;
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					var fromToken = stream.consumeToken();
					name.addChild(fromToken);
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
					break;
				default:
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
			} else {
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
			break;
		case 7:
			var _g2 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		default:
			typeChild = stream.consumeToken();
			typeParent.addChild(typeChild);
			typeParent = typeChild;
		}
	}
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkAbstract.walkAbstractBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
			break;
		case 7:
			var _g2 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkArrayAccess = function() { };
$hxClasses["tokentree.walk.WalkArrayAccess"] = tokentree_walk_WalkArrayAccess;
tokentree_walk_WalkArrayAccess.__name__ = "tokentree.walk.WalkArrayAccess";
tokentree_walk_WalkArrayAccess.walkArrayAccess = function(stream,parent) {
	var bkOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BkOpen);
	parent.addChild(bkOpen);
	stream.applyTempStore(bkOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
				break;
			case 5:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
				break;
			case 7:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkFor.walkFor(stream,bkOpen);
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 6:
			if(_g.op._hx_index == 22) {
				var child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				tokentree_walk_WalkStatement.walkStatement(stream,child);
			} else {
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 14:
			var comma = stream.consumeToken();
			var child1 = bkOpen.getLastChild();
			if(child1 == null) {
				child1 = bkOpen;
			}
			child1.addChild(comma);
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
			break;
		case 16:
			break _hx_loop1;
		case 17:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
			break;
		case 19:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
		}
	}
	bkOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BkClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "is") {
					tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
				}
			}
			break;
		case 6:
			var _g1 = _g.op;
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		case 11:case 15:
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkAt = function() { };
$hxClasses["tokentree.walk.WalkAt"] = tokentree_walk_WalkAt;
tokentree_walk_WalkAt.__name__ = "tokentree.walk.WalkAt";
tokentree_walk_WalkAt.walkAt = function(stream) {
	var atTok = stream.consumeTokenDef(tokentree_TokenTreeDef.At);
	var parent = atTok;
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		atTok.addChild(dblDot);
		parent = dblDot;
	}
	tokentree_walk_WalkAt.walkIdent(stream,parent);
	return atTok;
};
tokentree_walk_WalkAt.walkIdent = function(stream,parent) {
	var ident;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.k;
		ident = stream.consumeToken();
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			ident = stream.consumeConstIdent();
		} else {
			return;
		}
		break;
	case 6:
		if(_g.op._hx_index == 23) {
			ident = stream.consumeToken();
		} else {
			return;
		}
		break;
	default:
		return;
	}
	parent.addChild(ident);
	switch(stream.token()._hx_index) {
	case 11:
		var child = stream.consumeToken();
		ident.addChild(child);
		tokentree_walk_WalkAt.walkIdent(stream,child);
		break;
	case 19:
		var pOpenPos = stream.getTokenPos();
		if(ident.pos.max == pOpenPos.min) {
			var tempStore = stream.getTempStore();
			stream.clearTempStore();
			tokentree_walk_WalkPOpen.walkPOpen(stream,ident,false);
			var _g = 0;
			while(_g < tempStore.length) {
				var temp = tempStore[_g];
				++_g;
				stream.addToTempStore(temp);
			}
		}
		break;
	default:
	}
};
tokentree_walk_WalkAt.walkAts = function(stream) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) if(stream.token()._hx_index == 22) {
		stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	}
};
var tokentree_walk_WalkBinopSub = function() { };
$hxClasses["tokentree.walk.WalkBinopSub"] = tokentree_walk_WalkBinopSub;
tokentree_walk_WalkBinopSub.__name__ = "tokentree.walk.WalkBinopSub";
tokentree_walk_WalkBinopSub.walkBinopSub = function(stream,parent) {
	var sub = stream.consumeOpSub(parent);
	parent.addChild(sub);
	var _g = sub.tok;
	if(_g._hx_index == 2) {
		var _g1 = _g.c;
		tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,sub);
	}
};
var tokentree_walk_WalkBlock = function() { };
$hxClasses["tokentree.walk.WalkBlock"] = tokentree_walk_WalkBlock;
tokentree_walk_WalkBlock.__name__ = "tokentree.walk.WalkBlock";
tokentree_walk_WalkBlock.walkBlock = function(stream,parent) {
	while(stream.tokenForMatch()._hx_index == 22) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		parent.addChild(openTok);
		stream.applyTempStore(openTok);
		tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
		stream.applyTempStore(openTok);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkBlock.walkBlockContinue = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 14:
			var child = stream.consumeToken();
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				parent.addChild(child);
			} else {
				lastChild.addChild(child);
			}
			break;
		case 18:
			break _hx_loop1;
		case 16:case 20:
			var child1 = stream.consumeToken();
			parent.addChild(child1);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
};
tokentree_walk_WalkBlock.walkBlockEnd = function(stream,parent) {
	parent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 7) {
				return;
			}
		}
		tokentree_walk_WalkBlock.walkAfterBlock(stream,parent);
		if(stream.hasMore()) {
			if(stream.token()._hx_index == 10) {
				var semicolon = stream.consumeToken();
				parent.addChild(semicolon);
			}
		}
	}
};
tokentree_walk_WalkBlock.walkAfterBlock = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
		}
		break;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 7:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 8:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 10:
		return;
	case 11:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 13:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 19:
		var _g = parent.parent.tok;
		if(_g._hx_index == 4) {
			var _g1 = _g.s;
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
var tokentree_walk_WalkClass = function() { };
$hxClasses["tokentree.walk.WalkClass"] = tokentree_walk_WalkClass;
tokentree_walk_WalkClass.__name__ = "tokentree.walk.WalkClass";
tokentree_walk_WalkClass.walkClass = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var name = typeTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
		}
		break;
	case 4:
		var _g1 = _g.s;
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		break;
	default:
	}
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkClass.walkClassBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkClass.walkClassExtends = function(stream,name) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkExtends.walkExtends(stream,name);
		tokentree_walk_WalkImplements.walkImplements(stream,name);
		if(stream.isSharp()) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
	}
};
tokentree_walk_WalkClass.walkClassBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 39:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
			tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
			case 1:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
				break;
			}
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(parent);
			break;
		}
	}
};
tokentree_walk_WalkClass.walkClassContinueAfterSharp = function(stream,parent) {
	var brOpen = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.lastOf(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(parent),tokentree_TokenTreeDef.Sharp("if")),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)))),tokentree_TokenTreeDef.BrOpen);
	if(brOpen == null) {
		return;
	}
	if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.BrClose) != null) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
};
var tokentree_walk_WalkComment = function() { };
$hxClasses["tokentree.walk.WalkComment"] = tokentree_walk_WalkComment;
tokentree_walk_WalkComment.__name__ = "tokentree.walk.WalkComment";
tokentree_walk_WalkComment.walkComment = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			var comment = stream.consumeToken();
			parent.addChild(comment);
			break;
		case 8:
			var _g2 = _g.s;
			var comment1 = stream.consumeToken();
			parent.addChild(comment1);
			break;
		default:
			return;
		}
	}
};
tokentree_walk_WalkComment.tryWalkComment = function(stream,parent,expect) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 7:
			var _g1 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			if(stream.matches(expect)) {
				var _g3 = 0;
				while(_g3 < comments.length) {
					var comment = comments[_g3];
					++_g3;
					parent.addChild(comment);
				}
				return;
			}
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkDoWhile = function() { };
$hxClasses["tokentree.walk.WalkDoWhile"] = tokentree_walk_WalkDoWhile;
tokentree_walk_WalkDoWhile.__name__ = "tokentree.walk.WalkDoWhile";
tokentree_walk_WalkDoWhile.walkDoWhile = function(stream,parent) {
	var doTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo));
	parent.addChild(doTok);
	stream.applyTempStore(doTok);
	tokentree_walk_WalkComment.walkComment(stream,doTok);
	tokentree_walk_WalkBlock.walkBlock(stream,doTok);
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	doTok.addChild(whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	if(stream.tokenForMatch()._hx_index == 10) {
		whileTok.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkEnum = function() { };
$hxClasses["tokentree.walk.WalkEnum"] = tokentree_walk_WalkEnum;
tokentree_walk_WalkEnum.__name__ = "tokentree.walk.WalkEnum";
tokentree_walk_WalkEnum.walkEnum = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 39) {
		stream.addToTempStore(typeTok);
		tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
		return;
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
var tokentree_walk_WalkExtends = function() { };
$hxClasses["tokentree.walk.WalkExtends"] = tokentree_walk_WalkExtends;
tokentree_walk_WalkExtends.__name__ = "tokentree.walk.WalkExtends";
tokentree_walk_WalkExtends.walkExtends = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 11)) {
		return;
	}
	var parentType = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends));
	parent.addChild(parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkExtends.walkExtends(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkFieldDef = function() { };
$hxClasses["tokentree.walk.WalkFieldDef"] = tokentree_walk_WalkFieldDef;
tokentree_walk_WalkFieldDef.__name__ = "tokentree.walk.WalkFieldDef";
tokentree_walk_WalkFieldDef.walkFieldDef = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				var tok = stream.consumeToken();
				parent.addChild(tok);
				parent = tok;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 7:
			var _g1 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			var _g2 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			break _hx_loop1;
		}
	}
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
	switch(stream.token()._hx_index) {
	case 10:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		break;
	case 14:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Comma));
		break;
	default:
	}
};
var tokentree_walk_WalkFile = function() { };
$hxClasses["tokentree.walk.WalkFile"] = tokentree_walk_WalkFile;
tokentree_walk_WalkFile.__name__ = "tokentree.walk.WalkFile";
tokentree_walk_WalkFile.walkFile = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 1:case 26:case 27:case 31:case 39:
				tokentree_walk_WalkType.walkType(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 32:case 34:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 13:case 33:case 35:
				stream.applyTempStore(parent);
				tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index == 17) {
				tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
			}
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 10:case 14:case 16:case 18:case 20:
			parent.addChild(stream.consumeToken());
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
		}
	}
	var tempStore = stream.getTempStore();
	var _g = 0;
	while(_g < tempStore.length) {
		var stored = tempStore[_g];
		++_g;
		var _g1 = stored.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 18:case 19:case 25:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
			break;
		case 22:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
			case 1:
				parent.addChild(stored);
				break;
			}
			break;
		default:
			parent.addChild(stored);
		}
	}
};
var tokentree_walk_WalkFinal = function() { };
$hxClasses["tokentree.walk.WalkFinal"] = tokentree_walk_WalkFinal;
tokentree_walk_WalkFinal.__name__ = "tokentree.walk.WalkFinal";
tokentree_walk_WalkFinal.walkFinal = function(stream,parent) {
	var name = null;
	var finalTok = stream.consumeToken();
	stream.addToTempStore(finalTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return;
			case 1:case 27:
				return;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			default:
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				break _hx_loop1;
			}
			break;
		case 7:
			var _g3 = _g.s;
			stream.consumeToTempStore();
			break;
		case 8:
			var _g4 = _g.s;
			stream.consumeToTempStore();
			break;
		default:
		}
	}
	parent.addChild(finalTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = finalTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			finalTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		var tempStore = stream.getTempStore();
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			var _g1 = stored.tok;
			if(_g1._hx_index == 1) {
				if(_g1.k._hx_index != 41) {
					name.addChild(stored);
				}
			} else {
				name.addChild(stored);
			}
		}
		stream.clearTempStore();
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g2 = stream.tokenForMatch();
		if(_g2._hx_index == 6 && _g2.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			var comma = stream.consumeToken();
			name.addChild(comma);
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkFor = function() { };
$hxClasses["tokentree.walk.WalkFor"] = tokentree_walk_WalkFor;
tokentree_walk_WalkFor.__name__ = "tokentree.walk.WalkFor";
tokentree_walk_WalkFor.walkFor = function(stream,parent) {
	var forTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor));
	parent.addChild(forTok);
	stream.applyTempStore(forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkBlock.walkBlock(stream,forTok);
};
tokentree_walk_WalkFor.walkForPOpen = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkComment.walkComment(stream,pOpen);
	var identifier = null;
	var _g = stream.token();
	if(_g._hx_index == 4) {
		var _g1 = _g.s;
		tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
		identifier = pOpen.getLastChild();
	} else {
		identifier = stream.consumeConstIdent();
		pOpen.addChild(identifier);
	}
	tokentree_walk_WalkComment.walkComment(stream,identifier);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 22) {
		var arrowTok = stream.consumeToken();
		identifier.addChild(arrowTok);
		var _g = stream.token();
		if(_g._hx_index == 4) {
			var _g1 = _g.s;
			tokentree_walk_WalkStatement.walkStatement(stream,arrowTok);
		} else {
			arrowTok.addChild(stream.consumeConstIdent());
		}
	}
	var inTok = null;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 6:
		if(_g.op._hx_index == 23) {
			inTok = stream.consumeToken();
			identifier.addChild(inTok);
			tokentree_walk_WalkComment.walkComment(stream,inTok);
			tokentree_walk_WalkStatement.walkStatement(stream,inTok);
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		break;
	case 20:
		pOpen.addChild(stream.consumeToken());
		tokentree_walk_WalkComment.walkComment(stream,parent);
		return;
	default:
	}
};
var tokentree_walk_WalkFunction = function() { };
$hxClasses["tokentree.walk.WalkFunction"] = tokentree_walk_WalkFunction;
tokentree_walk_WalkFunction.__name__ = "tokentree.walk.WalkFunction";
tokentree_walk_WalkFunction.walkFunction = function(stream,parent) {
	var funcTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
	parent.addChild(funcTok);
	tokentree_walk_WalkComment.walkComment(stream,funcTok);
	var name = funcTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 6:
		if(_g.op._hx_index == 9) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
			name = funcTok.getLastChild();
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 19:
		break;
	default:
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
	}
	stream.applyTempStore(name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkStatement.walkStatement);
		switch(stream.token()._hx_index) {
		case 12:case 17:
			break;
		default:
			return;
		}
	}
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		name.addChild(dblDot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
	}
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
tokentree_walk_WalkFunction.walkFunctionParameters = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		if(stream.tokenForMatch()._hx_index == 20) {
			break;
		}
		tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
	}
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
};
var tokentree_walk_WalkIf = function() { };
$hxClasses["tokentree.walk.WalkIf"] = tokentree_walk_WalkIf;
tokentree_walk_WalkIf.__name__ = "tokentree.walk.WalkIf";
tokentree_walk_WalkIf.walkIf = function(stream,parent) {
	var ifTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf));
	parent.addChild(ifTok);
	stream.applyTempStore(ifTok);
	tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
	if(stream.tokenForMatch()._hx_index == 12) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
	tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 4) {
		var elseTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
		ifTok.addChild(elseTok);
		tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
	}
};
var tokentree_walk_WalkImplements = function() { };
$hxClasses["tokentree.walk.WalkImplements"] = tokentree_walk_WalkImplements;
tokentree_walk_WalkImplements.__name__ = "tokentree.walk.WalkImplements";
tokentree_walk_WalkImplements.walkImplements = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 12)) {
		return;
	}
	var interfacePart = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements));
	parent.addChild(interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkImplements.walkImplements(stream,parent);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkInterface = function() { };
$hxClasses["tokentree.walk.WalkInterface"] = tokentree_walk_WalkInterface;
tokentree_walk_WalkInterface.__name__ = "tokentree.walk.WalkInterface";
tokentree_walk_WalkInterface.walkInterface = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkInterface.walkInterfaceBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkLtGt = function() { };
$hxClasses["tokentree.walk.WalkLtGt"] = tokentree_walk_WalkLtGt;
tokentree_walk_WalkLtGt.__name__ = "tokentree.walk.WalkLtGt";
tokentree_walk_WalkLtGt.walkLtGt = function(stream,parent) {
	var ltTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
	parent.addChild(ltTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				break _hx_loop1;
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 12:
			var dblDot = stream.consumeToken();
			ltTok.addChild(dblDot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			break;
		case 14:
			var comma = stream.consumeToken();
			ltTok.addChild(comma);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			var _g1 = stream.token();
			if(!(_g1._hx_index == 6 && _g1.op._hx_index == 7)) {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,ltTok);
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
		}
	}
	ltTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)));
};
var tokentree_walk_WalkNew = function() { };
$hxClasses["tokentree.walk.WalkNew"] = tokentree_walk_WalkNew;
tokentree_walk_WalkNew.__name__ = "tokentree.walk.WalkNew";
tokentree_walk_WalkNew.walkNew = function(stream,parent) {
	var newTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
	parent.addChild(newTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		break;
	case 19:
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		break;
	default:
	}
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	case 11:case 15:
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	default:
	}
};
var tokentree_walk_WalkPOpen = function() { };
$hxClasses["tokentree.walk.WalkPOpen"] = tokentree_walk_WalkPOpen;
tokentree_walk_WalkPOpen.__name__ = "tokentree.walk.WalkPOpen";
tokentree_walk_WalkPOpen.walkPOpen = function(stream,parent,walkTrailingComments) {
	if(walkTrailingComments == null) {
		walkTrailingComments = true;
	}
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
	if(walkTrailingComments) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	if(stream.hasMore()) {
		if(stream.token()._hx_index == 13) {
			var arrow = stream.consumeToken();
			pOpen.addChild(arrow);
			tokentree_walk_WalkBlock.walkBlock(stream,arrow);
		}
	}
	return pOpen;
};
tokentree_walk_WalkPOpen.walkPOpenParts = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
			break;
		case 14:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			break;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			break;
		case 20:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkPackageImport = function() { };
$hxClasses["tokentree.walk.WalkPackageImport"] = tokentree_walk_WalkPackageImport;
tokentree_walk_WalkPackageImport.__name__ = "tokentree.walk.WalkPackageImport";
tokentree_walk_WalkPackageImport.walkPackageImport = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
			break;
		case 10:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			return;
		default:
			var newChild1 = stream.consumeToken();
			parent.addChild(newChild1);
			parent = newChild1;
		}
	}
};
var tokentree_walk_WalkQuestion = function() { };
$hxClasses["tokentree.walk.WalkQuestion"] = tokentree_walk_WalkQuestion;
tokentree_walk_WalkQuestion.__name__ = "tokentree.walk.WalkQuestion";
tokentree_walk_WalkQuestion.walkQuestion = function(stream,parent) {
	var ternary = tokentree_walk_WalkQuestion.isTernary(parent);
	var question = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
	parent.addChild(question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(!ternary) {
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		return;
	}
	tokentree_walk_WalkStatement.walkStatement(stream,question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(stream.tokenForMatch()._hx_index != 12) {
		return;
	}
	var dblDotTok = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	question.addChild(dblDotTok);
	tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
};
tokentree_walk_WalkQuestion.isTernary = function(parent) {
	var lastChild = parent.getLastChild();
	if(lastChild == null) {
		var _g = parent.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			return true;
		} else {
			lastChild = parent;
		}
	}
	var _g = lastChild.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return true;
		case 22:
			return true;
		case 29:
			return true;
		case 36:case 37:case 38:
			return true;
		case 23:case 28:case 40:
			return true;
		default:
			return false;
		}
		break;
	case 2:
		var _g1 = _g.c;
		return true;
	case 4:
		var _g1 = _g.s;
		return true;
	case 5:
		var _g1 = _g.op;
		return true;
	case 6:
		switch(_g.op._hx_index) {
		case 0:case 3:
			return true;
		default:
			return false;
		}
		break;
	case 12:
		return true;
	case 15:
		return true;
	case 17:
		return true;
	case 19:
		return true;
	case 20:
		return true;
	default:
		return false;
	}
};
var tokentree_walk_WalkSharp = function() { };
$hxClasses["tokentree.walk.WalkSharp"] = tokentree_walk_WalkSharp;
tokentree_walk_WalkSharp.__name__ = "tokentree.walk.WalkSharp";
tokentree_walk_WalkSharp.walkSharp = function(stream,parent,walker) {
	var _g = stream.token();
	if(_g._hx_index == 3) {
		switch(_g.s) {
		case "else":
			tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
			break;
		case "elseif":
			tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
			break;
		case "end":
			tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
			break;
		case "error":
			var errorToken = stream.consumeToken();
			parent.addChild(errorToken);
			var _g = stream.token();
			if(_g._hx_index == 2) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var _g = _g1.s;
					var _g = _g1.kind;
					errorToken.addChild(stream.consumeToken());
				}
			}
			break;
		case "if":
			tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
			break;
		default:
			parent.addChild(stream.consumeToken());
		}
	}
};
tokentree_walk_WalkSharp.walkSharpIf = function(stream,parent,walker) {
	var ifToken = stream.consumeToken();
	parent.addChild(ifToken);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	stream.pushSharpIf(ifToken);
	var newParent = ifToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) try {
		walker(stream,newParent);
		switch(stream.token()._hx_index) {
		case 14:case 18:case 20:
			var newChild = stream.consumeToken();
			newParent.addChild(newChild);
			break;
		default:
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(((_g1) instanceof tokentree_walk_SharpElseException)) {
			var e = _g1;
			newParent = e.token;
		} else if(((_g1) instanceof tokentree_walk_SharpEndException)) {
			stream.popSharpIf();
			return;
		} else {
			throw _g;
		}
	}
};
tokentree_walk_WalkSharp.walkSharpElse = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpElseIf = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpEnd = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var endToken = stream.consumeToken();
	stream.applyTempStore(sharpIfParent);
	sharpIfParent.addChild(endToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpEndException());
};
tokentree_walk_WalkSharp.walkSharpIfExpr = function(stream,parent) {
	var childToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.k;
			childToken = stream.consumeToken();
			parent.addChild(childToken);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index != 11) {
				return;
			}
			var pos = stream.getTokenPos();
			if(pos == null) {
				return;
			}
			if(pos.min == childToken.pos.max + 1) {
				continue;
			}
			var dot = stream.consumeToken();
			childToken.addChild(dot);
			tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
			return;
		case 2:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 11) {
					return;
				}
				var pos1 = stream.getTokenPos();
				if(pos1 == null) {
					return;
				}
				if(pos1.min == childToken.pos.max + 1) {
					continue;
				}
				var dot1 = stream.consumeToken();
				childToken.addChild(dot1);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot1);
				return;
			} else {
				return;
			}
			break;
		case 5:
			if(_g.op._hx_index == 2) {
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
				return;
			} else {
				return;
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			return;
		default:
			return;
		}
	}
};
var tokentree_walk_SharpElseException = function(token) {
	this.token = token;
};
$hxClasses["tokentree.walk.SharpElseException"] = tokentree_walk_SharpElseException;
tokentree_walk_SharpElseException.__name__ = "tokentree.walk.SharpElseException";
tokentree_walk_SharpElseException.prototype = {
	__class__: tokentree_walk_SharpElseException
};
var tokentree_walk_SharpEndException = function() {
};
$hxClasses["tokentree.walk.SharpEndException"] = tokentree_walk_SharpEndException;
tokentree_walk_SharpEndException.__name__ = "tokentree.walk.SharpEndException";
tokentree_walk_SharpEndException.prototype = {
	__class__: tokentree_walk_SharpEndException
};
var tokentree_walk_WalkStatement = function() { };
$hxClasses["tokentree.walk.WalkStatement"] = tokentree_walk_WalkStatement;
tokentree_walk_WalkStatement.__name__ = "tokentree.walk.WalkStatement";
tokentree_walk_WalkStatement.walkStatement = function(stream,parent) {
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	if(stream.tokenForMatch()._hx_index == 10) {
		var semicolon = stream.consumeToken();
		var lastChild;
		var _g = parent.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 0:case 3:case 14:case 15:
				lastChild = parent.parent.getLastChild();
				break;
			default:
				lastChild = parent.getLastChild();
			}
		} else {
			lastChild = parent.getLastChild();
		}
		if(lastChild == null) {
			lastChild = parent;
		}
		switch(lastChild.tok._hx_index) {
		case 16:case 18:case 20:
			lastChild = parent;
			break;
		default:
		}
		lastChild.addChild(semicolon);
	}
};
tokentree_walk_WalkStatement.walkStatementWithoutSemicolon = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var wantMore = true;
	tokentree_walk_WalkAt.walkAts(stream);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.k;
		if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
			wantMore = true;
		} else {
			return;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "final":
				if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
					wantMore = true;
				} else {
					return;
				}
				break;
			case "is":
				wantMore = true;
				break;
			default:
				wantMore = false;
			}
		} else {
			wantMore = false;
		}
		break;
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
		return;
	case 4:
		var name = _g.s;
		tokentree_walk_WalkStatement.walkDollarStatement(stream,parent);
		return;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			if(!stream.hasMore()) {
				return;
			}
			var _g1 = stream.token();
			switch(_g1._hx_index) {
			case 2:
				var _g2 = _g1.c;
				if(_g2._hx_index == 3) {
					if(_g2.s == "is") {
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
					}
				}
				break;
			case 6:
				var _g2 = _g1.op;
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				break;
			case 11:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				break;
			default:
			}
			return;
		}
		break;
	case 6:
		switch(_g.op._hx_index) {
		case 3:
			tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
			return;
		case 7:
			var gtTok = stream.consumeOpGt();
			parent.addChild(gtTok);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,gtTok);
			return;
		case 9:
			if(stream.isTypedParam()) {
				tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
				if(stream.tokenForMatch()._hx_index == 13) {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
				return;
			}
			wantMore = true;
			break;
		case 12:
			if(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 15) {
						var orTok = stream.consumeToken();
						parent.addChild(orTok);
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent.parent);
						return;
					}
				}
			}
			wantMore = true;
			break;
		default:
			wantMore = true;
		}
		break;
	case 9:
		var _g1 = _g.s;
		wantMore = true;
		break;
	case 10:
		return;
	case 11:
		wantMore = true;
		break;
	case 12:
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 40) {
				tokentree_walk_WalkStatement.walkDblDot(stream,parent);
				return;
			}
			break;
		case 11:
			return;
		default:
		}
		if(parent.tok._hx_index == 11) {
			return;
		}
		if(tokentree_walk_WalkQuestion.isTernary(parent)) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			return;
		}
		wantMore = true;
		break;
	case 13:
		wantMore = true;
		break;
	case 14:
		return;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		return;
	case 16:case 18:case 20:
		return;
	case 17:
		tokentree_walk_WalkBlock.walkBlock(stream,parent);
		return;
	case 19:
		tokentree_walk_WalkStatement.walkPOpen(stream,parent);
		return;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		return;
	default:
		wantMore = false;
	}
	var newChild = stream.consumeToken();
	parent.addChild(newChild);
	stream.applyTempStore(newChild);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
	if(wantMore) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
	}
	tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
};
tokentree_walk_WalkStatement.walkTrailingComment = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	if(_g._hx_index == 8) {
		var _g1 = _g.s;
		var currentPos = stream.getStreamIndex();
		var commentTok = stream.consumeToken();
		var _g = stream.tokenForMatch();
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			stream.rewindTo(currentPos);
			return;
		}
		parent.addChild(commentTok);
	}
};
tokentree_walk_WalkStatement.walkStatementContinue = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
		}
		break;
	case 5:
		var _g1 = _g.op;
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		switch(_g.op._hx_index) {
		case 0:case 3:
			tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
			break;
		case 7:
			var ltParent = parent;
			_hx_loop1: while(true) {
				var _g1 = ltParent.tok;
				switch(_g1._hx_index) {
				case 0:
					break _hx_loop1;
				case 2:
					var _g2 = _g1.c;
					ltParent = ltParent.parent;
					break;
				case 4:
					var _g3 = _g1.s;
					ltParent = ltParent.parent;
					break;
				case 6:
					switch(_g1.op._hx_index) {
					case 7:
						ltParent = ltParent.parent;
						break;
					case 9:
						return;
					default:
						break _hx_loop1;
					}
					break;
				case 11:case 12:case 13:case 14:case 15:case 17:case 19:
					ltParent = ltParent.parent;
					break;
				default:
					break _hx_loop1;
				}
			}
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 14:case 15:
			tokentree_walk_WalkStatement.walkOpBool(stream,parent);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 7:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 8:
		var _g1 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				var _g = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 10:
		return;
	case 11:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 13:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 15:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 19:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
tokentree_walk_WalkStatement.walkKeyword = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 0:
			tokentree_walk_WalkFunction.walkFunction(stream,parent);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 2:
			tokentree_walk_WalkVar.walkVar(stream,parent);
			break;
		case 3:
			tokentree_walk_WalkIf.walkIf(stream,parent);
			break;
		case 5:
			var tmp;
			if(parent.tok._hx_index != 17) {
				var _g = parent.parent.tok;
				tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			tokentree_walk_WalkWhile.walkWhile(stream,parent);
			break;
		case 6:
			tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
			break;
		case 7:
			tokentree_walk_WalkFor.walkFor(stream,parent);
			break;
		case 10:case 40:
			return true;
		case 14:
			tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
			break;
		case 15:
			return false;
		case 16:
			if(parent.tok._hx_index == 17) {
				return false;
			}
			return true;
		case 20:
			tokentree_walk_WalkTry.walkTry(stream,parent);
			break;
		case 22:
			if(parent.tok._hx_index == 11) {
				var newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			} else {
				tokentree_walk_WalkNew.walkNew(stream,parent);
			}
			break;
		case 23:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			return false;
		case 29:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
			return false;
		case 36:case 37:case 38:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			var _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 14:case 15:
					tokentree_walk_WalkStatement.walkOpBool(stream,newChild);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				}
				break;
			case 21:
				tokentree_walk_WalkQuestion.walkQuestion(stream,newChild);
				break;
			default:
			}
			return false;
		case 41:
			tokentree_walk_WalkFinal.walkFinal(stream,parent);
			break;
		default:
			return true;
		}
	} else {
		return true;
	}
	return false;
};
tokentree_walk_WalkStatement.walkDblDot = function(stream,parent) {
	var question = tokentree_walk_WalkStatement.findQuestionParent(parent);
	if(question != null) {
		return;
	}
	var dblDotTok = stream.consumeToken();
	parent.addChild(dblDotTok);
	if(parent.isCIdentOrCString() && parent.parent.tok._hx_index == 17) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 22) {
		tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
		return;
	}
	if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
		return;
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
};
tokentree_walk_WalkStatement.walkPOpen = function(stream,parent) {
	var pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	if(parent.tok == tokentree_TokenTreeDef.Root) {
		return;
	}
	if(parent.isCIdent()) {
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
	} else {
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:case 5:case 7:case 14:
				var _g = stream.token();
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 3) {
						return;
					}
					break;
				case 11:
					break;
				default:
					return;
				}
				break;
			default:
			}
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
	}
};
tokentree_walk_WalkStatement.findQuestionParent = function(token) {
	var parent = token;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 10:
				return parent;
			case 15:
				return parent;
			case 16:
				return parent;
			case 40:
				parent = tokentree_walk_WalkStatement.findQuestionParent(parent.parent);
				if(parent == null) {
					return null;
				}
				var _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					switch(_g1.k._hx_index) {
					case 15:case 16:
						return parent;
					default:
						return null;
					}
					break;
				case 21:
					return parent;
				default:
					return null;
				}
				break;
			default:
			}
			break;
		case 6:
			var _g2 = _g.op;
			return parent;
		case 14:
			return null;
		case 17:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose) == null) {
				return null;
			}
			break;
		case 19:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
				return null;
			}
			break;
		case 21:
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				return parent;
			}
			return null;
		default:
		}
		parent = parent.parent;
	}
	return null;
};
tokentree_walk_WalkStatement.walkStatementContinueAfterSharp = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 15:case 16:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				lastChild = parent;
			}
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
			break;
		default:
		}
	}
};
tokentree_walk_WalkStatement.walkOpBool = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			case 14:case 15:case 16:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 4:
				break _hx_loop1;
			case 14:case 15:
				token = parent.parent;
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 12:
			token = parent;
			break _hx_loop1;
		case 13:case 21:
			break _hx_loop1;
		case 19:
			if(token.tok._hx_index == 19) {
				token = parent;
			}
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkOpAdd = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 0:case 3:
				token = parent.parent;
				break _hx_loop1;
			case 1:case 2:
				token = parent;
				parent = parent.parent;
				break;
			case 4:
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				break _hx_loop1;
			}
			break;
		case 9:
			var _g3 = _g.s;
			break _hx_loop1;
		case 12:
			break _hx_loop1;
		case 13:case 21:
			break _hx_loop1;
		case 15:case 17:
			break _hx_loop1;
		case 19:
			var pClose = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
			if(pClose == null) {
				token = parent;
				break _hx_loop1;
			}
			token = parent;
			parent = parent.parent;
			break;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkDollarStatement = function(stream,parent) {
	var dollarTok = stream.consumeToken();
	parent.addChild(dollarTok);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	case 11:case 15:case 17:case 19:
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	default:
	}
};
var tokentree_walk_WalkSwitch = function() { };
$hxClasses["tokentree.walk.WalkSwitch"] = tokentree_walk_WalkSwitch;
tokentree_walk_WalkSwitch.__name__ = "tokentree.walk.WalkSwitch";
tokentree_walk_WalkSwitch.walkSwitch = function(stream,parent) {
	var switchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdSwitch));
	parent.addChild(switchTok);
	stream.applyTempStore(switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	var _g = stream.token();
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
	}
	if(stream.tokenForMatch()._hx_index == 17) {
		var brOpen = stream.consumeToken();
		switchTok.addChild(brOpen);
		tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
		brOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
};
tokentree_walk_WalkSwitch.walkSwitchCases = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkCase(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			break;
		case 7:
			var _g2 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			var _g3 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 18:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
tokentree_walk_WalkSwitch.walkCase = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var caseTok = stream.consumeToken();
	parent.addChild(caseTok);
	tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
	var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	caseTok.addChild(dblDot);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
			break;
		case 7:
			var _g2 = _g.s;
			var _g3 = stream.peekNonCommentToken();
			if(_g3 != null) {
				if(_g3._hx_index == 1) {
					switch(_g3.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 8:
			var _g4 = _g.s;
			var _g5 = stream.peekNonCommentToken();
			if(_g5 != null) {
				if(_g5._hx_index == 1) {
					switch(_g5.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
			break;
		case 18:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
		}
	}
};
tokentree_walk_WalkSwitch.relocateSharpTree = function(parent,dblDot) {
	var sharp = parent.getLastChild();
	if(sharp.children.length < 2) {
		return;
	}
	var body = sharp.children[1];
	var _g = body.tok;
	if(_g._hx_index == 1 && _g.k._hx_index == 15) {
		return;
	}
	parent.children.pop();
	dblDot.addChild(sharp);
};
tokentree_walk_WalkSwitch.walkCaseExpr = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 2) {
				var varTok = stream.consumeToken();
				parent.addChild(varTok);
				tokentree_walk_WalkStatement.walkStatement(stream,varTok);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 10:case 12:case 16:case 18:case 20:
			return;
		case 14:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkTry = function() { };
$hxClasses["tokentree.walk.WalkTry"] = tokentree_walk_WalkTry;
tokentree_walk_WalkTry.__name__ = "tokentree.walk.WalkTry";
tokentree_walk_WalkTry.walkTry = function(stream,parent) {
	var tryTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry));
	parent.addChild(tryTok);
	stream.applyTempStore(tryTok);
	tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 21) {
				var _g1 = 0;
				while(_g1 < comments.length) {
					var comment = comments[_g1];
					++_g1;
					tryTok.addChild(comment);
				}
				comments = [];
				tokentree_walk_WalkTry.walkCatch(stream,tryTok);
				currentPos = stream.getStreamIndex();
			} else {
				stream.rewindTo(currentPos);
				return;
			}
			break;
		case 7:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
tokentree_walk_WalkTry.walkCatch = function(stream,parent) {
	var catchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch));
	parent.addChild(catchTok);
	tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
	tokentree_walk_WalkComment.walkComment(stream,catchTok);
	tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
};
var tokentree_walk_WalkType = function() { };
$hxClasses["tokentree.walk.WalkType"] = tokentree_walk_WalkType;
tokentree_walk_WalkType.__name__ = "tokentree.walk.WalkType";
tokentree_walk_WalkType.walkType = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 26:
			tokentree_walk_WalkEnum.walkEnum(stream,parent);
			break;
		case 27:
			tokentree_walk_WalkInterface.walkInterface(stream,parent);
			break;
		case 31:
			tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
			break;
		case 39:
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkTypeNameDef = function() { };
$hxClasses["tokentree.walk.WalkTypeNameDef"] = tokentree_walk_WalkTypeNameDef;
tokentree_walk_WalkTypeNameDef.__name__ = "tokentree.walk.WalkTypeNameDef";
tokentree_walk_WalkTypeNameDef.walkTypeNameDef = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkAt.walkAts(stream);
	if(stream.tokenForMatch()._hx_index == 21) {
		var questTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
		parent.addChild(questTok);
		parent = questTok;
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	var name;
	var bAdd = true;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 22:case 25:case 40:
			name = stream.consumeToken();
			break;
		default:
			name = stream.consumeToken();
		}
		break;
	case 2:
		var _g1 = _g.c;
		name = stream.consumeConst();
		break;
	case 3:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		if(!stream.hasMore()) {
			return parent.getFirstChild();
		}
		var _g1 = stream.token();
		if(_g1._hx_index == 2) {
			var _g2 = _g1.c;
			name = stream.consumeConst();
		} else {
			return parent.getFirstChild();
		}
		break;
	case 4:
		var _g1 = _g.s;
		name = stream.consumeToken();
		break;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		return parent.getFirstChild();
	case 17:
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		return parent.getFirstChild();
	case 19:
		name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(stream.tokenForMatch()._hx_index == 21) {
			tokentree_walk_WalkQuestion.walkQuestion(stream,name);
		}
		bAdd = false;
		break;
	default:
		name = stream.consumeToken();
	}
	stream.applyTempStore(name);
	if(bAdd) {
		parent.addChild(name);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
	return name;
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue = function(stream,parent) {
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	if(stream.tokenForMatch()._hx_index == 11) {
		var dot = stream.consumeToken();
		parent.addChild(dot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 9) {
		tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrow = stream.consumeToken();
		parent.addChild(arrow);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
		return;
	}
	if(stream.tokenForMatch()._hx_index == 15) {
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment = function(stream,parent) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			var _g1 = _g.op;
			var _g2 = 0;
			while(_g2 < comments.length) {
				var comment = comments[_g2];
				++_g2;
				parent.addChild(comment);
			}
			return;
		case 7:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 8:
			var _g4 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 10:case 11:case 12:case 14:case 15:case 17:case 19:
			var _g5 = 0;
			while(_g5 < comments.length) {
				var comment1 = comments[_g5];
				++_g5;
				parent.addChild(comment1);
			}
			return;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkTypedef = function() { };
$hxClasses["tokentree.walk.WalkTypedef"] = tokentree_walk_WalkTypedef;
tokentree_walk_WalkTypedef.__name__ = "tokentree.walk.WalkTypedef";
tokentree_walk_WalkTypedef.walkTypedef = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		var assign = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		name.addChild(assign);
		name = assign;
	}
	tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
};
var tokentree_walk_WalkTypedefBody = function() { };
$hxClasses["tokentree.walk.WalkTypedefBody"] = tokentree_walk_WalkTypedefBody;
tokentree_walk_WalkTypedefBody.__name__ = "tokentree.walk.WalkTypedefBody";
tokentree_walk_WalkTypedefBody.walkTypedefBody = function(stream,parent) {
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeToken();
		parent.addChild(openTok);
		tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
		openTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	} else {
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 11) {
		var and = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		parent.getLastChild().addChild(and);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody = function(stream,openTok) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,openTok);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,openTok);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,openTok);
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 3:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
			break;
		case 6:
			if(_g.op._hx_index == 7) {
				tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 7:
			var _g2 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 8:
			var _g3 = _g.s;
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(openTok);
			break;
		}
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefAlias = function(stream,parent) {
	var newParent;
	if(stream.tokenForMatch()._hx_index == 19) {
		newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	} else {
		newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrowTok = stream.consumeToken();
		newParent.addChild(arrowTok);
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		newParent.addChild(stream.consumeToken());
	}
};
tokentree_walk_WalkTypedefBody.walkStructureExtension = function(stream,parent) {
	var gt = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
	parent.addChild(gt);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	gt.addChild(name);
	if(stream.tokenForMatch()._hx_index == 14) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkVar = function() { };
$hxClasses["tokentree.walk.WalkVar"] = tokentree_walk_WalkVar;
tokentree_walk_WalkVar.__name__ = "tokentree.walk.WalkVar";
tokentree_walk_WalkVar.walkVar = function(stream,parent) {
	var name = null;
	var varTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
	parent.addChild(varTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 2) {
			return;
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = varTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			varTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g1 = stream.tokenForMatch();
		if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			var comma = stream.consumeToken();
			name.addChild(comma);
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkWhile = function() { };
$hxClasses["tokentree.walk.WalkWhile"] = tokentree_walk_WalkWhile;
tokentree_walk_WalkWhile.__name__ = "tokentree.walk.WalkWhile";
tokentree_walk_WalkWhile.walkWhile = function(stream,parent) {
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	parent.addChild(whileTok);
	stream.applyTempStore(whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
};
function $iterator(o) { if( o instanceof Array ) return function() { return new haxe_iterators_ArrayIterator(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
var JQueryDefined = typeof($) != "undefined";
if(JQueryDefined && $.fn != null) {
	$.fn.elements = function() {
		return new js_jquery_JqEltsIterator(this);
	};
}
var JQueryDefined = typeof($) != "undefined";
if(JQueryDefined && $.fn != null) {
	$.fn.iterator = function() {
		return new js_jquery_JqIterator(this);
	};
}
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
Editor.MIN_HEIGHT = 525;
Editor.THEME_STORAGE_KEY = "theme";
Editor.DARK_THEME_CLASS = "dark-theme";
Libs.available = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["JS"] = [{ name : "actuate", help : "https://github.com/openfl/actuate", args : []},{ name : "box2d", help : "https://github.com/openfl/box2d"},{ name : "format", help : "https://github.com/HaxeFoundation/format"},{ name : "hx3compat", help : "https://github.com/HaxeFoundation/hx3compat"},{ name : "hxColorToolkit", help : "https://github.com/andyli/hxColorToolkit"},{ name : "hxmath", help : "https://github.com/tbrosman/hxmath", args : []},{ name : "nape", help : "https://github.com/deltaluca/nape"},{ name : "pecan", help : "https://github.com/Aurel300/pecan"},{ name : "pixijs", head : ["<script src='../../../lib/js/pixi.min.js'></script>"]},{ name : "thx.core", help : "https://github.com/fponticelli/thx.core"},{ name : "thx.culture", help : "https://github.com/fponticelli/thx.culture"},{ name : "tink_core", help : "https://github.com/haxetink/tink_core"},{ name : "tink_lang", help : "https://github.com/haxetink/tink_lang"},{ name : "tink_state", help : "https://github.com/haxetink/tink_state"},{ name : "threejs", head : ["<script src='../../../lib/js/three.min.js'></script>"]},{ name : "safety", help : "https://github.com/RealyUniqueName/Safety"},{ name : "utest", help : "https://github.com/haxe-utest/utest"}];
	_g.h["NEKO"] = [{ name : "actuate", help : "https://github.com/openfl/actuate", args : []},{ name : "format", help : "https://github.com/HaxeFoundation/format"},{ name : "hx3compat", help : "https://github.com/HaxeFoundation/hx3compat"},{ name : "hxColorToolkit", help : "https://github.com/andyli/hxColorToolkit"},{ name : "hxmath", help : "https://github.com/tbrosman/hxmath", args : []},{ name : "pecan", help : "https://github.com/Aurel300/pecan"},{ name : "thx.core", help : "https://github.com/fponticelli/thx.core"},{ name : "thx.culture", help : "https://github.com/fponticelli/thx.culture"},{ name : "tink_core", help : "https://github.com/haxetink/tink_core"},{ name : "tink_lang", help : "https://github.com/haxetink/tink_lang"},{ name : "tink_macro", help : "https://github.com/haxetink/tink_macro"},{ name : "safety", help : "https://github.com/RealyUniqueName/Safety"},{ name : "utest", help : "https://github.com/haxe-utest/utest"}];
	_g.h["EVAL"] = [{ name : "actuate", help : "https://github.com/openfl/actuate", args : []},{ name : "format", help : "https://github.com/HaxeFoundation/format"},{ name : "hx3compat", help : "https://github.com/HaxeFoundation/hx3compat"},{ name : "hxColorToolkit", help : "https://github.com/andyli/hxColorToolkit"},{ name : "hxmath", help : "https://github.com/tbrosman/hxmath", args : []},{ name : "pecan", help : "https://github.com/Aurel300/pecan"},{ name : "thx.core", help : "https://github.com/fponticelli/thx.core"},{ name : "thx.culture", help : "https://github.com/fponticelli/thx.culture"},{ name : "tink_core", help : "https://github.com/haxetink/tink_core"},{ name : "tink_lang", help : "https://github.com/haxetink/tink_lang"},{ name : "tink_macro", help : "https://github.com/haxetink/tink_macro"},{ name : "safety", help : "https://github.com/RealyUniqueName/Safety"},{ name : "utest", help : "https://github.com/haxe-utest/utest"}];
	_g.h["HL"] = [{ name : "actuate", help : "https://github.com/openfl/actuate", args : []},{ name : "format", help : "https://github.com/HaxeFoundation/format"},{ name : "hx3compat", help : "https://github.com/HaxeFoundation/hx3compat"},{ name : "hxColorToolkit", help : "https://github.com/andyli/hxColorToolkit"},{ name : "hxmath", help : "https://github.com/tbrosman/hxmath", args : []},{ name : "pecan", help : "https://github.com/Aurel300/pecan"},{ name : "safety", help : "https://github.com/RealyUniqueName/Safety"},{ name : "thx.core", help : "https://github.com/fponticelli/thx.core"},{ name : "thx.culture", help : "https://github.com/fponticelli/thx.culture"},{ name : "tink_core", help : "https://github.com/haxetink/tink_core"},{ name : "tink_lang", help : "https://github.com/haxetink/tink_lang"},{ name : "tink_macro", help : "https://github.com/haxetink/tink_macro"},{ name : "utest", help : "https://github.com/haxe-utest/utest"}];
	$r = _g;
	return $r;
}(this));
Libs.defaultChecked = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["JS"] = [];
	_g.h["NEKO"] = [];
	_g.h["EVAL"] = [];
	_g.h["HL"] = [];
	$r = _g;
	return $r;
}(this));
formatter_FormatStats.totalFiles = 0;
formatter_FormatStats.successFiles = 0;
formatter_FormatStats.failedFiles = 0;
formatter_FormatStats.disabledFiles = 0;
formatter_FormatStats.totalLinesOrig = 0;
formatter_FormatStats.totalLinesFormatted = 0;
formatter_Formatter.FORMATTER_JSON = "hxformat.json";
formatter_codedata_CodeLines.FORMATTER_OFF = " @formatter:off";
formatter_codedata_CodeLines.FORMATTER_ON = " @formatter:on";
formatter_codedata_ParsedCode.BAD_OFFSET = "Bad offset";
formatter_codedata_TokenList.BAD_OFFSET = "Bad offset";
formatter_codedata_TokenList.NEWLINE_TO_SPACE = "Newline -> Space";
formatter_config_WhitespacePolicy.None = "none";
formatter_config_WhitespacePolicy.Before = "before";
formatter_config_WhitespacePolicy.NoneBefore = "noneBefore";
formatter_config_WhitespacePolicy.OnlyBefore = "onlyBefore";
formatter_config_WhitespacePolicy.After = "after";
formatter_config_WhitespacePolicy.OnlyAfter = "onlyAfter";
formatter_config_WhitespacePolicy.NoneAfter = "noneAfter";
formatter_config_WhitespacePolicy.Around = "around";
formatter_marker_MarkLineEnds.SHARP_IF = "if";
formatter_marker_MarkLineEnds.SHARP_ELSE_IF = "elseif";
formatter_marker_MarkLineEnds.SHARP_ELSE = "else";
formatter_marker_MarkLineEnds.SHARP_END = "end";
formatter_marker_MarkLineEnds.SHARP_ERROR = "error";
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
hxparse_LexEngine.MAX_CODE = 255;
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [new hxparse__$LexEngine_CharRange(0,255)];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["abstract"] = haxeparser_Keyword.KwdAbstract;
	_g.h["break"] = haxeparser_Keyword.KwdBreak;
	_g.h["case"] = haxeparser_Keyword.KwdCase;
	_g.h["cast"] = haxeparser_Keyword.KwdCast;
	_g.h["catch"] = haxeparser_Keyword.KwdCatch;
	_g.h["class"] = haxeparser_Keyword.KwdClass;
	_g.h["continue"] = haxeparser_Keyword.KwdContinue;
	_g.h["default"] = haxeparser_Keyword.KwdDefault;
	_g.h["do"] = haxeparser_Keyword.KwdDo;
	_g.h["dynamic"] = haxeparser_Keyword.KwdDynamic;
	_g.h["else"] = haxeparser_Keyword.KwdElse;
	_g.h["enum"] = haxeparser_Keyword.KwdEnum;
	_g.h["extends"] = haxeparser_Keyword.KwdExtends;
	_g.h["extern"] = haxeparser_Keyword.KwdExtern;
	_g.h["false"] = haxeparser_Keyword.KwdFalse;
	_g.h["final"] = haxeparser_Keyword.KwdFinal;
	_g.h["for"] = haxeparser_Keyword.KwdFor;
	_g.h["function"] = haxeparser_Keyword.KwdFunction;
	_g.h["if"] = haxeparser_Keyword.KwdIf;
	_g.h["implements"] = haxeparser_Keyword.KwdImplements;
	_g.h["import"] = haxeparser_Keyword.KwdImport;
	_g.h["inline"] = haxeparser_Keyword.KwdInline;
	_g.h["interface"] = haxeparser_Keyword.KwdInterface;
	_g.h["macro"] = haxeparser_Keyword.KwdMacro;
	_g.h["new"] = haxeparser_Keyword.KwdNew;
	_g.h["null"] = haxeparser_Keyword.KwdNull;
	_g.h["operator"] = haxeparser_Keyword.KwdOperator;
	_g.h["overload"] = haxeparser_Keyword.KwdOverload;
	_g.h["override"] = haxeparser_Keyword.KwdOverride;
	_g.h["package"] = haxeparser_Keyword.KwdPackage;
	_g.h["private"] = haxeparser_Keyword.KwdPrivate;
	_g.h["public"] = haxeparser_Keyword.KwdPublic;
	_g.h["return"] = haxeparser_Keyword.KwdReturn;
	_g.h["static"] = haxeparser_Keyword.KwdStatic;
	_g.h["switch"] = haxeparser_Keyword.KwdSwitch;
	_g.h["this"] = haxeparser_Keyword.KwdThis;
	_g.h["throw"] = haxeparser_Keyword.KwdThrow;
	_g.h["true"] = haxeparser_Keyword.KwdTrue;
	_g.h["try"] = haxeparser_Keyword.KwdTry;
	_g.h["typedef"] = haxeparser_Keyword.KwdTypedef;
	_g.h["untyped"] = haxeparser_Keyword.KwdUntyped;
	_g.h["using"] = haxeparser_Keyword.KwdUsing;
	_g.h["var"] = haxeparser_Keyword.KwdVar;
	_g.h["while"] = haxeparser_Keyword.KwdWhile;
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.ident = "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*";
haxeparser_HaxeLexer.sharp_ident = "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*";
haxeparser_HaxeLexer.idtype = "_*[A-Z][a-zA-Z0-9_]*";
haxeparser_HaxeLexer.integer = "([1-9][0-9]*)|0";
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}},{ rule : "0x[0-9a-fA-F]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "([1-9][0-9]*)|0", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "\\.[0-9]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)([eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]*[eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.\\.\\.)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer.current,2,null)));
}},{ rule : "+\\+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "==", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpInterval));
}},{ rule : "=>", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comma);
}},{ rule : "\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "in", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpIn));
}},{ rule : "[", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.PClose);
}},{ rule : "?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.DoubleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.SingleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "~/", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var info;
	try {
		info = lexer.token(haxeparser_HaxeLexer.regexp);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "/\\*", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var pmax;
	try {
		pmax = lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer) {
	var kwd = haxeparser_HaxeLexer.keywords.h[lexer.current];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	try {
		lexer.token(haxeparser_HaxeLexer.codeString);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "}", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "/\\*", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "/", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
haxeparser_HaxeLexer.sharp_token = hxparse_Lexer.buildRuleset([{ rule : "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.sharp_token);
}},{ rule : "/\\*", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.sharp_token);
}},{ rule : "[.]*", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}}],"sharp_token");
haxeparser_HaxeLexer.generatedRulesets = [haxeparser_HaxeLexer.tok,haxeparser_HaxeLexer.string,haxeparser_HaxeLexer.string2,haxeparser_HaxeLexer.codeString,haxeparser_HaxeLexer.comment,haxeparser_HaxeLexer.regexp,haxeparser_HaxeLexer.regexp_options,haxeparser_HaxeLexer.sharp_token];
tokentree_TokenStream.NO_MORE_TOKENS = "no more tokens";
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Strict;
tokentree_TokenTree.MAX_LEVEL = 9999;
App.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
